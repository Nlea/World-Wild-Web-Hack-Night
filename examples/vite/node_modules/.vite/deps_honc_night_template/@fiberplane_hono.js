import {
  Hono,
  decodeURIComponent_,
  escapeToBuffer,
  raw,
  resolveCallbackSync,
  stringBufferToString
} from "./chunk-TOZEMAX4.js";
import {
  __commonJS,
  __export,
  __toESM
} from "./chunk-G3PMV62Z.js";

// node_modules/@sagold/json-pointer/dist/jsonPointer.js
var require_jsonPointer = __commonJS({
  "node_modules/@sagold/json-pointer/dist/jsonPointer.js"(exports, module) {
    !function(t, e) {
      "object" == typeof exports && "object" == typeof module ? module.exports = e() : "function" == typeof define && define.amd ? define("jsonPointer", [], e) : "object" == typeof exports ? exports.jsonPointer = e() : t.jsonPointer = e();
    }("undefined" != typeof self ? self : exports, () => (() => {
      "use strict";
      var t = { d: (e2, n2) => {
        for (var o2 in n2) t.o(n2, o2) && !t.o(e2, o2) && Object.defineProperty(e2, o2, { enumerable: true, get: n2[o2] });
      }, o: (t2, e2) => Object.prototype.hasOwnProperty.call(t2, e2), r: (t2) => {
        "undefined" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(t2, Symbol.toStringTag, { value: "Module" }), Object.defineProperty(t2, "__esModule", { value: true });
      } }, e = {};
      function n(t2) {
        return "#" === t2 || "" === t2 || Array.isArray(t2) && 0 === t2.length || false;
      }
      t.r(e), t.d(e, { default: () => _, get: () => s, isRoot: () => n, join: () => P, remove: () => m, removeUndefinedItems: () => v, set: () => g, split: () => f, splitLast: () => O });
      const o = /~1/g, r = /~0/g, i = /(^#?\/?)/g;
      function l(t2) {
        return t2.replace(o, "/").replace(r, "~");
      }
      function u(t2) {
        return l(decodeURIComponent(t2));
      }
      function f(t2) {
        if (null == t2 || "string" != typeof t2 || n(t2)) return Array.isArray(t2) ? t2 : [];
        const e2 = t2.indexOf("#") >= 0 ? u : l, o2 = (t2 = t2.replace(i, "")).split("/");
        for (let t3 = 0, n2 = o2.length; t3 < n2; t3 += 1) o2[t3] = e2(o2[t3]);
        return o2;
      }
      function s(t2, e2, o2 = void 0) {
        if (null == e2 || null == t2) return o2;
        if (n(e2)) return t2;
        const r2 = c(t2, f(e2));
        return void 0 === r2 ? o2 : r2;
      }
      function c(t2, e2) {
        const n2 = e2.shift();
        if (void 0 !== t2) return void 0 !== n2 ? c(t2[n2], e2) : t2;
      }
      const p = /^\[.*\]$/, d = /^\[(.+)\]$/;
      function a(t2, e2) {
        return "__proto__" === t2 || "constructor" == t2 && e2.length > 0 && "prototype" == e2[0];
      }
      function g(t2, e2, n2) {
        if (null == e2) return t2;
        const o2 = f(e2);
        if (0 === o2.length) return t2;
        null == t2 && (t2 = p.test(o2[0]) ? [] : {});
        let r2, i2, l2 = t2;
        for (; o2.length > 1; ) r2 = o2.shift(), i2 = p.test(o2[0]), a(r2, o2) || (l2 = h(l2, r2, i2));
        return r2 = o2.pop(), y(l2, r2, n2), t2;
      }
      function y(t2, e2, n2) {
        let o2;
        const r2 = e2.match(d);
        "[]" === e2 && Array.isArray(t2) ? t2.push(n2) : r2 ? (o2 = r2.pop(), t2[o2] = n2) : t2[e2] = n2;
      }
      function h(t2, e2, n2) {
        var o2, r2;
        const i2 = null !== (r2 = null === (o2 = e2.match(d)) || void 0 === o2 ? void 0 : o2.pop()) && void 0 !== r2 ? r2 : e2;
        if (null != t2[i2]) return t2[i2];
        const l2 = n2 ? [] : {};
        return y(t2, e2, l2), l2;
      }
      function v(t2) {
        let e2 = 0, n2 = 0;
        for (; e2 + n2 < t2.length; ) void 0 === t2[e2 + n2] && (n2 += 1), t2[e2] = t2[e2 + n2], e2 += 1;
        return t2.length = t2.length - n2, t2;
      }
      function m(t2, e2, n2) {
        const o2 = f(e2), r2 = o2.pop(), i2 = s(t2, o2);
        return i2 && delete i2[r2], Array.isArray(i2) && true !== n2 && v(i2), t2;
      }
      const j = /~/g, b = /\//g;
      function A(t2, e2) {
        if (0 === t2.length) return e2 ? "#" : "";
        for (let n2 = 0, o2 = t2.length; n2 < o2; n2 += 1) t2[n2] = t2[n2].replace(j, "~0").replace(b, "~1"), e2 && (t2[n2] = encodeURIComponent(t2[n2]));
        return (e2 ? "#/" : "/") + t2.join("/");
      }
      function P(t2, ...e2) {
        const n2 = [];
        if (Array.isArray(t2)) return A(t2, true === arguments[1]);
        const o2 = arguments[arguments.length - 1], r2 = "boolean" == typeof o2 ? o2 : t2 && "#" === t2[0];
        for (let t3 = 0, e3 = arguments.length; t3 < e3; t3 += 1) n2.push.apply(n2, f(arguments[t3]));
        const i2 = [];
        for (let t3 = 0, e3 = n2.length; t3 < e3; t3 += 1) if (".." === n2[t3]) {
          if (0 === i2.length) return r2 ? "#" : "";
          i2.pop();
        } else i2.push(n2[t3]);
        return A(i2, r2);
      }
      function O(t2) {
        const e2 = f(t2);
        if (0 === e2.length) return "string" == typeof t2 && "#" === t2[0] ? ["#", e2[0]] : ["", void 0];
        if (1 === e2.length) return "#" === t2[0] ? ["#", e2[0]] : ["", e2[0]];
        const n2 = e2.pop();
        return [P(e2, "#" === t2[0]), n2];
      }
      const _ = { get: s, set: g, remove: m, join: P, split: f, splitLast: O, isRoot: n, removeUndefinedItems: v };
      return e;
    })());
  }
});

// node_modules/valid-url/index.js
var require_valid_url = __commonJS({
  "node_modules/valid-url/index.js"(exports, module) {
    (function(module2) {
      "use strict";
      module2.exports.is_uri = is_iri;
      module2.exports.is_http_uri = is_http_iri;
      module2.exports.is_https_uri = is_https_iri;
      module2.exports.is_web_uri = is_web_iri;
      module2.exports.isUri = is_iri;
      module2.exports.isHttpUri = is_http_iri;
      module2.exports.isHttpsUri = is_https_iri;
      module2.exports.isWebUri = is_web_iri;
      var splitUri = function(uri) {
        var splitted = uri.match(/(?:([^:\/?#]+):)?(?:\/\/([^\/?#]*))?([^?#]*)(?:\?([^#]*))?(?:#(.*))?/);
        return splitted;
      };
      function is_iri(value) {
        if (!value) {
          return;
        }
        if (/[^a-z0-9\:\/\?\#\[\]\@\!\$\&\'\(\)\*\+\,\;\=\.\-\_\~\%]/i.test(value)) return;
        if (/%[^0-9a-f]/i.test(value)) return;
        if (/%[0-9a-f](:?[^0-9a-f]|$)/i.test(value)) return;
        var splitted = [];
        var scheme = "";
        var authority = "";
        var path = "";
        var query = "";
        var fragment = "";
        var out = "";
        splitted = splitUri(value);
        scheme = splitted[1];
        authority = splitted[2];
        path = splitted[3];
        query = splitted[4];
        fragment = splitted[5];
        if (!(scheme && scheme.length && path.length >= 0)) return;
        if (authority && authority.length) {
          if (!(path.length === 0 || /^\//.test(path))) return;
        } else {
          if (/^\/\//.test(path)) return;
        }
        if (!/^[a-z][a-z0-9\+\-\.]*$/.test(scheme.toLowerCase())) return;
        out += scheme + ":";
        if (authority && authority.length) {
          out += "//" + authority;
        }
        out += path;
        if (query && query.length) {
          out += "?" + query;
        }
        if (fragment && fragment.length) {
          out += "#" + fragment;
        }
        return out;
      }
      function is_http_iri(value, allowHttps) {
        if (!is_iri(value)) {
          return;
        }
        var splitted = [];
        var scheme = "";
        var authority = "";
        var path = "";
        var port = "";
        var query = "";
        var fragment = "";
        var out = "";
        splitted = splitUri(value);
        scheme = splitted[1];
        authority = splitted[2];
        path = splitted[3];
        query = splitted[4];
        fragment = splitted[5];
        if (!scheme) return;
        if (allowHttps) {
          if (scheme.toLowerCase() != "https") return;
        } else {
          if (scheme.toLowerCase() != "http") return;
        }
        if (!authority) {
          return;
        }
        if (/:(\d+)$/.test(authority)) {
          port = authority.match(/:(\d+)$/)[0];
          authority = authority.replace(/:\d+$/, "");
        }
        out += scheme + ":";
        out += "//" + authority;
        if (port) {
          out += port;
        }
        out += path;
        if (query && query.length) {
          out += "?" + query;
        }
        if (fragment && fragment.length) {
          out += "#" + fragment;
        }
        return out;
      }
      function is_https_iri(value) {
        return is_http_iri(value, true);
      }
      function is_web_iri(value) {
        return is_http_iri(value) || is_https_iri(value);
      }
    })(module);
  }
});

// node_modules/nearley/lib/nearley.js
var require_nearley = __commonJS({
  "node_modules/nearley/lib/nearley.js"(exports, module) {
    (function(root, factory) {
      if (typeof module === "object" && module.exports) {
        module.exports = factory();
      } else {
        root.nearley = factory();
      }
    })(exports, function() {
      function Rule(name, symbols, postprocess) {
        this.id = ++Rule.highestId;
        this.name = name;
        this.symbols = symbols;
        this.postprocess = postprocess;
        return this;
      }
      Rule.highestId = 0;
      Rule.prototype.toString = function(withCursorAt) {
        var symbolSequence = typeof withCursorAt === "undefined" ? this.symbols.map(getSymbolShortDisplay).join(" ") : this.symbols.slice(0, withCursorAt).map(getSymbolShortDisplay).join(" ") + " ● " + this.symbols.slice(withCursorAt).map(getSymbolShortDisplay).join(" ");
        return this.name + " → " + symbolSequence;
      };
      function State(rule, dot, reference, wantedBy) {
        this.rule = rule;
        this.dot = dot;
        this.reference = reference;
        this.data = [];
        this.wantedBy = wantedBy;
        this.isComplete = this.dot === rule.symbols.length;
      }
      State.prototype.toString = function() {
        return "{" + this.rule.toString(this.dot) + "}, from: " + (this.reference || 0);
      };
      State.prototype.nextState = function(child) {
        var state = new State(this.rule, this.dot + 1, this.reference, this.wantedBy);
        state.left = this;
        state.right = child;
        if (state.isComplete) {
          state.data = state.build();
          state.right = void 0;
        }
        return state;
      };
      State.prototype.build = function() {
        var children = [];
        var node = this;
        do {
          children.push(node.right.data);
          node = node.left;
        } while (node.left);
        children.reverse();
        return children;
      };
      State.prototype.finish = function() {
        if (this.rule.postprocess) {
          this.data = this.rule.postprocess(this.data, this.reference, Parser.fail);
        }
      };
      function Column(grammar, index3) {
        this.grammar = grammar;
        this.index = index3;
        this.states = [];
        this.wants = {};
        this.scannable = [];
        this.completed = {};
      }
      Column.prototype.process = function(nextColumn) {
        var states = this.states;
        var wants = this.wants;
        var completed = this.completed;
        for (var w = 0; w < states.length; w++) {
          var state = states[w];
          if (state.isComplete) {
            state.finish();
            if (state.data !== Parser.fail) {
              var wantedBy = state.wantedBy;
              for (var i = wantedBy.length; i--; ) {
                var left = wantedBy[i];
                this.complete(left, state);
              }
              if (state.reference === this.index) {
                var exp = state.rule.name;
                (this.completed[exp] = this.completed[exp] || []).push(state);
              }
            }
          } else {
            var exp = state.rule.symbols[state.dot];
            if (typeof exp !== "string") {
              this.scannable.push(state);
              continue;
            }
            if (wants[exp]) {
              wants[exp].push(state);
              if (completed.hasOwnProperty(exp)) {
                var nulls = completed[exp];
                for (var i = 0; i < nulls.length; i++) {
                  var right = nulls[i];
                  this.complete(state, right);
                }
              }
            } else {
              wants[exp] = [state];
              this.predict(exp);
            }
          }
        }
      };
      Column.prototype.predict = function(exp) {
        var rules = this.grammar.byName[exp] || [];
        for (var i = 0; i < rules.length; i++) {
          var r = rules[i];
          var wantedBy = this.wants[exp];
          var s = new State(r, 0, this.index, wantedBy);
          this.states.push(s);
        }
      };
      Column.prototype.complete = function(left, right) {
        var copy = left.nextState(right);
        this.states.push(copy);
      };
      function Grammar(rules, start) {
        this.rules = rules;
        this.start = start || this.rules[0].name;
        var byName = this.byName = {};
        this.rules.forEach(function(rule) {
          if (!byName.hasOwnProperty(rule.name)) {
            byName[rule.name] = [];
          }
          byName[rule.name].push(rule);
        });
      }
      Grammar.fromCompiled = function(rules, start) {
        var lexer = rules.Lexer;
        if (rules.ParserStart) {
          start = rules.ParserStart;
          rules = rules.ParserRules;
        }
        var rules = rules.map(function(r) {
          return new Rule(r.name, r.symbols, r.postprocess);
        });
        var g = new Grammar(rules, start);
        g.lexer = lexer;
        return g;
      };
      function StreamLexer() {
        this.reset("");
      }
      StreamLexer.prototype.reset = function(data, state) {
        this.buffer = data;
        this.index = 0;
        this.line = state ? state.line : 1;
        this.lastLineBreak = state ? -state.col : 0;
      };
      StreamLexer.prototype.next = function() {
        if (this.index < this.buffer.length) {
          var ch = this.buffer[this.index++];
          if (ch === "\n") {
            this.line += 1;
            this.lastLineBreak = this.index;
          }
          return { value: ch };
        }
      };
      StreamLexer.prototype.save = function() {
        return {
          line: this.line,
          col: this.index - this.lastLineBreak
        };
      };
      StreamLexer.prototype.formatError = function(token, message) {
        var buffer = this.buffer;
        if (typeof buffer === "string") {
          var lines = buffer.split("\n").slice(
            Math.max(0, this.line - 5),
            this.line
          );
          var nextLineBreak = buffer.indexOf("\n", this.index);
          if (nextLineBreak === -1) nextLineBreak = buffer.length;
          var col = this.index - this.lastLineBreak;
          var lastLineDigits = String(this.line).length;
          message += " at line " + this.line + " col " + col + ":\n\n";
          message += lines.map(function(line, i) {
            return pad(this.line - lines.length + i + 1, lastLineDigits) + " " + line;
          }, this).join("\n");
          message += "\n" + pad("", lastLineDigits + col) + "^\n";
          return message;
        } else {
          return message + " at index " + (this.index - 1);
        }
        function pad(n, length) {
          var s = String(n);
          return Array(length - s.length + 1).join(" ") + s;
        }
      };
      function Parser(rules, start, options) {
        if (rules instanceof Grammar) {
          var grammar = rules;
          var options = start;
        } else {
          var grammar = Grammar.fromCompiled(rules, start);
        }
        this.grammar = grammar;
        this.options = {
          keepHistory: false,
          lexer: grammar.lexer || new StreamLexer()
        };
        for (var key in options || {}) {
          this.options[key] = options[key];
        }
        this.lexer = this.options.lexer;
        this.lexerState = void 0;
        var column = new Column(grammar, 0);
        var table = this.table = [column];
        column.wants[grammar.start] = [];
        column.predict(grammar.start);
        column.process();
        this.current = 0;
      }
      Parser.fail = {};
      Parser.prototype.feed = function(chunk) {
        var lexer = this.lexer;
        lexer.reset(chunk, this.lexerState);
        var token;
        while (true) {
          try {
            token = lexer.next();
            if (!token) {
              break;
            }
          } catch (e) {
            var nextColumn = new Column(this.grammar, this.current + 1);
            this.table.push(nextColumn);
            var err = new Error(this.reportLexerError(e));
            err.offset = this.current;
            err.token = e.token;
            throw err;
          }
          var column = this.table[this.current];
          if (!this.options.keepHistory) {
            delete this.table[this.current - 1];
          }
          var n = this.current + 1;
          var nextColumn = new Column(this.grammar, n);
          this.table.push(nextColumn);
          var literal = token.text !== void 0 ? token.text : token.value;
          var value = lexer.constructor === StreamLexer ? token.value : token;
          var scannable = column.scannable;
          for (var w = scannable.length; w--; ) {
            var state = scannable[w];
            var expect = state.rule.symbols[state.dot];
            if (expect.test ? expect.test(value) : expect.type ? expect.type === token.type : expect.literal === literal) {
              var next2 = state.nextState({ data: value, token, isToken: true, reference: n - 1 });
              nextColumn.states.push(next2);
            }
          }
          nextColumn.process();
          if (nextColumn.states.length === 0) {
            var err = new Error(this.reportError(token));
            err.offset = this.current;
            err.token = token;
            throw err;
          }
          if (this.options.keepHistory) {
            column.lexerState = lexer.save();
          }
          this.current++;
        }
        if (column) {
          this.lexerState = lexer.save();
        }
        this.results = this.finish();
        return this;
      };
      Parser.prototype.reportLexerError = function(lexerError) {
        var tokenDisplay, lexerMessage;
        var token = lexerError.token;
        if (token) {
          tokenDisplay = "input " + JSON.stringify(token.text[0]) + " (lexer error)";
          lexerMessage = this.lexer.formatError(token, "Syntax error");
        } else {
          tokenDisplay = "input (lexer error)";
          lexerMessage = lexerError.message;
        }
        return this.reportErrorCommon(lexerMessage, tokenDisplay);
      };
      Parser.prototype.reportError = function(token) {
        var tokenDisplay = (token.type ? token.type + " token: " : "") + JSON.stringify(token.value !== void 0 ? token.value : token);
        var lexerMessage = this.lexer.formatError(token, "Syntax error");
        return this.reportErrorCommon(lexerMessage, tokenDisplay);
      };
      Parser.prototype.reportErrorCommon = function(lexerMessage, tokenDisplay) {
        var lines = [];
        lines.push(lexerMessage);
        var lastColumnIndex = this.table.length - 2;
        var lastColumn = this.table[lastColumnIndex];
        var expectantStates = lastColumn.states.filter(function(state) {
          var nextSymbol = state.rule.symbols[state.dot];
          return nextSymbol && typeof nextSymbol !== "string";
        });
        if (expectantStates.length === 0) {
          lines.push("Unexpected " + tokenDisplay + ". I did not expect any more input. Here is the state of my parse table:\n");
          this.displayStateStack(lastColumn.states, lines);
        } else {
          lines.push("Unexpected " + tokenDisplay + ". Instead, I was expecting to see one of the following:\n");
          var stateStacks = expectantStates.map(function(state) {
            return this.buildFirstStateStack(state, []) || [state];
          }, this);
          stateStacks.forEach(function(stateStack) {
            var state = stateStack[0];
            var nextSymbol = state.rule.symbols[state.dot];
            var symbolDisplay = this.getSymbolDisplay(nextSymbol);
            lines.push("A " + symbolDisplay + " based on:");
            this.displayStateStack(stateStack, lines);
          }, this);
        }
        lines.push("");
        return lines.join("\n");
      };
      Parser.prototype.displayStateStack = function(stateStack, lines) {
        var lastDisplay;
        var sameDisplayCount = 0;
        for (var j = 0; j < stateStack.length; j++) {
          var state = stateStack[j];
          var display = state.rule.toString(state.dot);
          if (display === lastDisplay) {
            sameDisplayCount++;
          } else {
            if (sameDisplayCount > 0) {
              lines.push("    ^ " + sameDisplayCount + " more lines identical to this");
            }
            sameDisplayCount = 0;
            lines.push("    " + display);
          }
          lastDisplay = display;
        }
      };
      Parser.prototype.getSymbolDisplay = function(symbol) {
        return getSymbolLongDisplay(symbol);
      };
      Parser.prototype.buildFirstStateStack = function(state, visited) {
        if (visited.indexOf(state) !== -1) {
          return null;
        }
        if (state.wantedBy.length === 0) {
          return [state];
        }
        var prevState = state.wantedBy[0];
        var childVisited = [state].concat(visited);
        var childResult = this.buildFirstStateStack(prevState, childVisited);
        if (childResult === null) {
          return null;
        }
        return [state].concat(childResult);
      };
      Parser.prototype.save = function() {
        var column = this.table[this.current];
        column.lexerState = this.lexerState;
        return column;
      };
      Parser.prototype.restore = function(column) {
        var index3 = column.index;
        this.current = index3;
        this.table[index3] = column;
        this.table.splice(index3 + 1);
        this.lexerState = column.lexerState;
        this.results = this.finish();
      };
      Parser.prototype.rewind = function(index3) {
        if (!this.options.keepHistory) {
          throw new Error("set option `keepHistory` to enable rewinding");
        }
        this.restore(this.table[index3]);
      };
      Parser.prototype.finish = function() {
        var considerations = [];
        var start = this.grammar.start;
        var column = this.table[this.table.length - 1];
        column.states.forEach(function(t) {
          if (t.rule.name === start && t.dot === t.rule.symbols.length && t.reference === 0 && t.data !== Parser.fail) {
            considerations.push(t);
          }
        });
        return considerations.map(function(c) {
          return c.data;
        });
      };
      function getSymbolLongDisplay(symbol) {
        var type = typeof symbol;
        if (type === "string") {
          return symbol;
        } else if (type === "object") {
          if (symbol.literal) {
            return JSON.stringify(symbol.literal);
          } else if (symbol instanceof RegExp) {
            return "character matching " + symbol;
          } else if (symbol.type) {
            return symbol.type + " token";
          } else if (symbol.test) {
            return "token matching " + String(symbol.test);
          } else {
            throw new Error("Unknown symbol type: " + symbol);
          }
        }
      }
      function getSymbolShortDisplay(symbol) {
        var type = typeof symbol;
        if (type === "string") {
          return symbol;
        } else if (type === "object") {
          if (symbol.literal) {
            return JSON.stringify(symbol.literal);
          } else if (symbol instanceof RegExp) {
            return symbol.toString();
          } else if (symbol.type) {
            return "%" + symbol.type;
          } else if (symbol.test) {
            return "<" + String(symbol.test) + ">";
          } else {
            throw new Error("Unknown symbol type: " + symbol);
          }
        }
      }
      return {
        Parser,
        Grammar,
        Rule
      };
    });
  }
});

// node_modules/smtp-address-parser/dist/lib/grammar.js
var require_grammar = __commonJS({
  "node_modules/smtp-address-parser/dist/lib/grammar.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function id(d) {
      return d[0];
    }
    var deepFlatten = (arr) => [].concat(...arr.map((v) => Array.isArray(v) ? deepFlatten(v) : v));
    function flat_string(d) {
      if (d) {
        if (Array.isArray(d))
          return deepFlatten(d).join("");
        return d;
      }
      return "";
    }
    var grammar = {
      Lexer: void 0,
      ParserRules: [
        { "name": "Reverse_path", "symbols": ["Path"] },
        { "name": "Reverse_path$string$1", "symbols": [{ "literal": "<" }, { "literal": ">" }], "postprocess": (d) => d.join("") },
        { "name": "Reverse_path", "symbols": ["Reverse_path$string$1"] },
        { "name": "Forward_path$subexpression$1$subexpression$1", "symbols": [{ "literal": "<" }, /[pP]/, /[oO]/, /[sS]/, /[tT]/, /[mM]/, /[aA]/, /[sS]/, /[tT]/, /[eE]/, /[rR]/, { "literal": "@" }], "postprocess": function(d) {
          return d.join("");
        } },
        { "name": "Forward_path$subexpression$1", "symbols": ["Forward_path$subexpression$1$subexpression$1", "Domain", { "literal": ">" }] },
        { "name": "Forward_path", "symbols": ["Forward_path$subexpression$1"] },
        { "name": "Forward_path$subexpression$2", "symbols": [{ "literal": "<" }, /[pP]/, /[oO]/, /[sS]/, /[tT]/, /[mM]/, /[aA]/, /[sS]/, /[tT]/, /[eE]/, /[rR]/, { "literal": ">" }], "postprocess": function(d) {
          return d.join("");
        } },
        { "name": "Forward_path", "symbols": ["Forward_path$subexpression$2"] },
        { "name": "Forward_path", "symbols": ["Path"] },
        { "name": "Path$ebnf$1$subexpression$1", "symbols": ["A_d_l", { "literal": ":" }] },
        { "name": "Path$ebnf$1", "symbols": ["Path$ebnf$1$subexpression$1"], "postprocess": id },
        { "name": "Path$ebnf$1", "symbols": [], "postprocess": () => null },
        { "name": "Path", "symbols": [{ "literal": "<" }, "Path$ebnf$1", "Mailbox", { "literal": ">" }] },
        { "name": "A_d_l$ebnf$1", "symbols": [] },
        { "name": "A_d_l$ebnf$1$subexpression$1", "symbols": [{ "literal": "," }, "At_domain"] },
        { "name": "A_d_l$ebnf$1", "symbols": ["A_d_l$ebnf$1", "A_d_l$ebnf$1$subexpression$1"], "postprocess": (d) => d[0].concat([d[1]]) },
        { "name": "A_d_l", "symbols": ["At_domain", "A_d_l$ebnf$1"] },
        { "name": "At_domain", "symbols": [{ "literal": "@" }, "Domain"] },
        { "name": "Domain$ebnf$1", "symbols": [] },
        { "name": "Domain$ebnf$1$subexpression$1", "symbols": [{ "literal": "." }, "sub_domain"] },
        { "name": "Domain$ebnf$1", "symbols": ["Domain$ebnf$1", "Domain$ebnf$1$subexpression$1"], "postprocess": (d) => d[0].concat([d[1]]) },
        { "name": "Domain", "symbols": ["sub_domain", "Domain$ebnf$1"] },
        { "name": "sub_domain", "symbols": ["U_label"] },
        { "name": "Let_dig", "symbols": ["ALPHA_DIGIT"], "postprocess": id },
        { "name": "Ldh_str$ebnf$1", "symbols": [] },
        { "name": "Ldh_str$ebnf$1", "symbols": ["Ldh_str$ebnf$1", "ALPHA_DIG_DASH"], "postprocess": (d) => d[0].concat([d[1]]) },
        { "name": "Ldh_str", "symbols": ["Ldh_str$ebnf$1", "Let_dig"] },
        { "name": "U_Let_dig", "symbols": ["ALPHA_DIGIT_U"], "postprocess": id },
        { "name": "U_Ldh_str$ebnf$1", "symbols": [] },
        { "name": "U_Ldh_str$ebnf$1", "symbols": ["U_Ldh_str$ebnf$1", "ALPHA_DIG_DASH_U"], "postprocess": (d) => d[0].concat([d[1]]) },
        { "name": "U_Ldh_str", "symbols": ["U_Ldh_str$ebnf$1", "U_Let_dig"] },
        { "name": "U_label$ebnf$1$subexpression$1", "symbols": ["U_Ldh_str"] },
        { "name": "U_label$ebnf$1", "symbols": ["U_label$ebnf$1$subexpression$1"], "postprocess": id },
        { "name": "U_label$ebnf$1", "symbols": [], "postprocess": () => null },
        { "name": "U_label", "symbols": ["U_Let_dig", "U_label$ebnf$1"] },
        { "name": "address_literal$subexpression$1", "symbols": ["IPv4_address_literal"] },
        { "name": "address_literal$subexpression$1", "symbols": ["IPv6_address_literal"] },
        { "name": "address_literal$subexpression$1", "symbols": ["General_address_literal"] },
        { "name": "address_literal", "symbols": [{ "literal": "[" }, "address_literal$subexpression$1", { "literal": "]" }] },
        {
          "name": "non_local_part",
          "symbols": ["Domain"],
          "postprocess": function(d) {
            return { DomainName: flat_string(d[0]) };
          }
        },
        {
          "name": "non_local_part",
          "symbols": ["address_literal"],
          "postprocess": function(d) {
            return { AddressLiteral: flat_string(d[0]) };
          }
        },
        {
          "name": "Mailbox",
          "symbols": ["Local_part", { "literal": "@" }, "non_local_part"],
          "postprocess": function(d) {
            return { localPart: flat_string(d[0]), domainPart: flat_string(d[2]) };
          }
        },
        {
          "name": "Local_part",
          "symbols": ["Dot_string"],
          "postprocess": function(d) {
            return { DotString: flat_string(d[0]) };
          }
        },
        {
          "name": "Local_part",
          "symbols": ["Quoted_string"],
          "postprocess": function(d) {
            return { QuotedString: flat_string(d[0]) };
          }
        },
        { "name": "Dot_string$ebnf$1", "symbols": [] },
        { "name": "Dot_string$ebnf$1$subexpression$1", "symbols": [{ "literal": "." }, "Atom"] },
        { "name": "Dot_string$ebnf$1", "symbols": ["Dot_string$ebnf$1", "Dot_string$ebnf$1$subexpression$1"], "postprocess": (d) => d[0].concat([d[1]]) },
        { "name": "Dot_string", "symbols": ["Atom", "Dot_string$ebnf$1"] },
        { "name": "Atom$ebnf$1", "symbols": [/[0-9A-Za-z!#$%&'*+\-/=?^_`{|}~\u0080-\uFFFF/]/] },
        { "name": "Atom$ebnf$1", "symbols": ["Atom$ebnf$1", /[0-9A-Za-z!#$%&'*+\-/=?^_`{|}~\u0080-\uFFFF/]/], "postprocess": (d) => d[0].concat([d[1]]) },
        { "name": "Atom", "symbols": ["Atom$ebnf$1"] },
        { "name": "Quoted_string$ebnf$1", "symbols": [] },
        { "name": "Quoted_string$ebnf$1", "symbols": ["Quoted_string$ebnf$1", "QcontentSMTP"], "postprocess": (d) => d[0].concat([d[1]]) },
        { "name": "Quoted_string", "symbols": ["DQUOTE", "Quoted_string$ebnf$1", "DQUOTE"] },
        { "name": "QcontentSMTP", "symbols": ["qtextSMTP"] },
        { "name": "QcontentSMTP", "symbols": ["quoted_pairSMTP"] },
        { "name": "quoted_pairSMTP", "symbols": [{ "literal": "\\" }, /[\x20-\x7e]/] },
        { "name": "qtextSMTP", "symbols": [/[\x20-\x21\x23-\x5b\x5d-\x7e\u0080-\uFFFF]/], "postprocess": id },
        { "name": "IPv4_address_literal$macrocall$2", "symbols": [{ "literal": "." }, "Snum"] },
        { "name": "IPv4_address_literal$macrocall$1", "symbols": ["IPv4_address_literal$macrocall$2", "IPv4_address_literal$macrocall$2", "IPv4_address_literal$macrocall$2"] },
        { "name": "IPv4_address_literal", "symbols": ["Snum", "IPv4_address_literal$macrocall$1"] },
        { "name": "IPv6_address_literal$subexpression$1", "symbols": [/[iI]/, /[pP]/, /[vV]/, { "literal": "6" }, { "literal": ":" }], "postprocess": function(d) {
          return d.join("");
        } },
        { "name": "IPv6_address_literal", "symbols": ["IPv6_address_literal$subexpression$1", "IPv6_addr"] },
        { "name": "General_address_literal$ebnf$1", "symbols": ["dcontent"] },
        { "name": "General_address_literal$ebnf$1", "symbols": ["General_address_literal$ebnf$1", "dcontent"], "postprocess": (d) => d[0].concat([d[1]]) },
        { "name": "General_address_literal", "symbols": ["Standardized_tag", { "literal": ":" }, "General_address_literal$ebnf$1"] },
        { "name": "Standardized_tag", "symbols": ["Ldh_str"] },
        { "name": "dcontent", "symbols": [/[\x21-\x5a\x5e-\x7e]/], "postprocess": id },
        { "name": "Snum", "symbols": ["DIGIT"] },
        { "name": "Snum$subexpression$1", "symbols": [/[1-9]/, "DIGIT"] },
        { "name": "Snum", "symbols": ["Snum$subexpression$1"] },
        { "name": "Snum$subexpression$2", "symbols": [{ "literal": "1" }, "DIGIT", "DIGIT"] },
        { "name": "Snum", "symbols": ["Snum$subexpression$2"] },
        { "name": "Snum$subexpression$3", "symbols": [{ "literal": "2" }, /[0-4]/, "DIGIT"] },
        { "name": "Snum", "symbols": ["Snum$subexpression$3"] },
        { "name": "Snum$subexpression$4", "symbols": [{ "literal": "2" }, { "literal": "5" }, /[0-5]/] },
        { "name": "Snum", "symbols": ["Snum$subexpression$4"] },
        { "name": "IPv6_addr", "symbols": ["IPv6_full"] },
        { "name": "IPv6_addr", "symbols": ["IPv6_comp"] },
        { "name": "IPv6_addr", "symbols": ["IPv6v4_full"] },
        { "name": "IPv6_addr", "symbols": ["IPv6v4_comp"] },
        { "name": "IPv6_hex", "symbols": ["HEXDIG"] },
        { "name": "IPv6_hex$subexpression$1", "symbols": ["HEXDIG", "HEXDIG"] },
        { "name": "IPv6_hex", "symbols": ["IPv6_hex$subexpression$1"] },
        { "name": "IPv6_hex$subexpression$2", "symbols": ["HEXDIG", "HEXDIG", "HEXDIG"] },
        { "name": "IPv6_hex", "symbols": ["IPv6_hex$subexpression$2"] },
        { "name": "IPv6_hex$subexpression$3", "symbols": ["HEXDIG", "HEXDIG", "HEXDIG", "HEXDIG"] },
        { "name": "IPv6_hex", "symbols": ["IPv6_hex$subexpression$3"] },
        { "name": "IPv6_full$macrocall$2", "symbols": [{ "literal": ":" }, "IPv6_hex"] },
        { "name": "IPv6_full$macrocall$1", "symbols": ["IPv6_full$macrocall$2", "IPv6_full$macrocall$2", "IPv6_full$macrocall$2", "IPv6_full$macrocall$2", "IPv6_full$macrocall$2", "IPv6_full$macrocall$2", "IPv6_full$macrocall$2"] },
        { "name": "IPv6_full", "symbols": ["IPv6_hex", "IPv6_full$macrocall$1"] },
        { "name": "IPv6_comp$ebnf$1$subexpression$1$macrocall$2", "symbols": [{ "literal": ":" }, "IPv6_hex"] },
        { "name": "IPv6_comp$ebnf$1$subexpression$1$macrocall$1", "symbols": ["IPv6_comp$ebnf$1$subexpression$1$macrocall$2", "IPv6_comp$ebnf$1$subexpression$1$macrocall$2", "IPv6_comp$ebnf$1$subexpression$1$macrocall$2", "IPv6_comp$ebnf$1$subexpression$1$macrocall$2", "IPv6_comp$ebnf$1$subexpression$1$macrocall$2"] },
        { "name": "IPv6_comp$ebnf$1$subexpression$1", "symbols": ["IPv6_hex", "IPv6_comp$ebnf$1$subexpression$1$macrocall$1"] },
        { "name": "IPv6_comp$ebnf$1", "symbols": ["IPv6_comp$ebnf$1$subexpression$1"], "postprocess": id },
        { "name": "IPv6_comp$ebnf$1", "symbols": [], "postprocess": () => null },
        { "name": "IPv6_comp$string$1", "symbols": [{ "literal": ":" }, { "literal": ":" }], "postprocess": (d) => d.join("") },
        { "name": "IPv6_comp$ebnf$2$subexpression$1$macrocall$2", "symbols": [{ "literal": ":" }, "IPv6_hex"] },
        { "name": "IPv6_comp$ebnf$2$subexpression$1$macrocall$1", "symbols": ["IPv6_comp$ebnf$2$subexpression$1$macrocall$2", "IPv6_comp$ebnf$2$subexpression$1$macrocall$2", "IPv6_comp$ebnf$2$subexpression$1$macrocall$2", "IPv6_comp$ebnf$2$subexpression$1$macrocall$2", "IPv6_comp$ebnf$2$subexpression$1$macrocall$2"] },
        { "name": "IPv6_comp$ebnf$2$subexpression$1", "symbols": ["IPv6_hex", "IPv6_comp$ebnf$2$subexpression$1$macrocall$1"] },
        { "name": "IPv6_comp$ebnf$2", "symbols": ["IPv6_comp$ebnf$2$subexpression$1"], "postprocess": id },
        { "name": "IPv6_comp$ebnf$2", "symbols": [], "postprocess": () => null },
        { "name": "IPv6_comp", "symbols": ["IPv6_comp$ebnf$1", "IPv6_comp$string$1", "IPv6_comp$ebnf$2"] },
        { "name": "IPv6v4_full$macrocall$2", "symbols": [{ "literal": ":" }, "IPv6_hex"] },
        { "name": "IPv6v4_full$macrocall$1", "symbols": ["IPv6v4_full$macrocall$2", "IPv6v4_full$macrocall$2", "IPv6v4_full$macrocall$2", "IPv6v4_full$macrocall$2", "IPv6v4_full$macrocall$2"] },
        { "name": "IPv6v4_full", "symbols": ["IPv6_hex", "IPv6v4_full$macrocall$1", { "literal": ":" }, "IPv4_address_literal"] },
        { "name": "IPv6v4_comp$ebnf$1$subexpression$1$macrocall$2", "symbols": [{ "literal": ":" }, "IPv6_hex"] },
        { "name": "IPv6v4_comp$ebnf$1$subexpression$1$macrocall$1", "symbols": ["IPv6v4_comp$ebnf$1$subexpression$1$macrocall$2", "IPv6v4_comp$ebnf$1$subexpression$1$macrocall$2", "IPv6v4_comp$ebnf$1$subexpression$1$macrocall$2"] },
        { "name": "IPv6v4_comp$ebnf$1$subexpression$1", "symbols": ["IPv6_hex", "IPv6v4_comp$ebnf$1$subexpression$1$macrocall$1"] },
        { "name": "IPv6v4_comp$ebnf$1", "symbols": ["IPv6v4_comp$ebnf$1$subexpression$1"], "postprocess": id },
        { "name": "IPv6v4_comp$ebnf$1", "symbols": [], "postprocess": () => null },
        { "name": "IPv6v4_comp$string$1", "symbols": [{ "literal": ":" }, { "literal": ":" }], "postprocess": (d) => d.join("") },
        { "name": "IPv6v4_comp$ebnf$2$subexpression$1$macrocall$2", "symbols": [{ "literal": ":" }, "IPv6_hex"] },
        { "name": "IPv6v4_comp$ebnf$2$subexpression$1$macrocall$1", "symbols": ["IPv6v4_comp$ebnf$2$subexpression$1$macrocall$2", "IPv6v4_comp$ebnf$2$subexpression$1$macrocall$2", "IPv6v4_comp$ebnf$2$subexpression$1$macrocall$2"] },
        { "name": "IPv6v4_comp$ebnf$2$subexpression$1", "symbols": ["IPv6_hex", "IPv6v4_comp$ebnf$2$subexpression$1$macrocall$1", { "literal": ":" }] },
        { "name": "IPv6v4_comp$ebnf$2", "symbols": ["IPv6v4_comp$ebnf$2$subexpression$1"], "postprocess": id },
        { "name": "IPv6v4_comp$ebnf$2", "symbols": [], "postprocess": () => null },
        { "name": "IPv6v4_comp", "symbols": ["IPv6v4_comp$ebnf$1", "IPv6v4_comp$string$1", "IPv6v4_comp$ebnf$2", "IPv4_address_literal"] },
        { "name": "DIGIT", "symbols": [/[0-9]/], "postprocess": id },
        { "name": "ALPHA_DIGIT_U", "symbols": [/[0-9A-Za-z\u0080-\uFFFF]/], "postprocess": id },
        { "name": "ALPHA_DIGIT", "symbols": [/[0-9A-Za-z]/], "postprocess": id },
        { "name": "ALPHA_DIG_DASH", "symbols": [/[-0-9A-Za-z]/], "postprocess": id },
        { "name": "ALPHA_DIG_DASH_U", "symbols": [/[-0-9A-Za-z\u0080-\uFFFF]/], "postprocess": id },
        { "name": "HEXDIG", "symbols": [/[0-9A-Fa-f]/], "postprocess": id },
        { "name": "DQUOTE", "symbols": [{ "literal": '"' }], "postprocess": id }
      ],
      ParserStart: "Reverse_path"
    };
    exports.default = grammar;
  }
});

// node_modules/smtp-address-parser/dist/lib/index.js
var require_lib = __commonJS({
  "node_modules/smtp-address-parser/dist/lib/index.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.canonicalize = exports.canonicalize_quoted_string = exports.normalize = exports.normalize_dot_string = exports.parse = void 0;
    var nearley = require_nearley();
    var grammar_1 = __importDefault(require_grammar());
    grammar_1.default.ParserStart = "Mailbox";
    var grammar = nearley.Grammar.fromCompiled(grammar_1.default);
    function parse2(address) {
      const parser = new nearley.Parser(grammar);
      parser.feed(address);
      if (parser.results.length !== 1) {
        throw new Error("address parsing failed: ambiguous grammar");
      }
      return parser.results[0];
    }
    exports.parse = parse2;
    function normalize_dot_string(dot_string) {
      const tagless = function() {
        const plus_loc = dot_string.indexOf("+");
        if (plus_loc === -1) {
          return dot_string;
        }
        return dot_string.substr(0, plus_loc);
      }();
      const dotless = tagless.replace(/\./g, "");
      return dotless.toLowerCase();
    }
    exports.normalize_dot_string = normalize_dot_string;
    function normalize(address) {
      var _a2, _b;
      const a = parse2(address);
      const domain = (_a2 = a.domainPart.AddressLiteral) !== null && _a2 !== void 0 ? _a2 : a.domainPart.DomainName.toLowerCase();
      const local = (_b = a.localPart.QuotedString) !== null && _b !== void 0 ? _b : normalize_dot_string(a.localPart.DotString);
      return `${local}@${domain}`;
    }
    exports.normalize = normalize;
    function canonicalize_quoted_string(quoted_string) {
      const unquoted = quoted_string.substr(1).substr(0, quoted_string.length - 2);
      const unescaped = unquoted.replace(/(?:\\(.))/g, "$1");
      const reescaped = unescaped.replace(/(?:(["\\]))/g, "\\$1");
      return `"${reescaped}"`;
    }
    exports.canonicalize_quoted_string = canonicalize_quoted_string;
    function canonicalize(address) {
      var _a2;
      const a = parse2(address);
      const domain = (_a2 = a.domainPart.AddressLiteral) !== null && _a2 !== void 0 ? _a2 : a.domainPart.DomainName.toLowerCase();
      const local = a.localPart.QuotedString ? canonicalize_quoted_string(a.localPart.QuotedString) : a.localPart.DotString;
      return `${local}@${domain}`;
    }
    exports.canonicalize = canonicalize;
  }
});

// node_modules/deepmerge/dist/cjs.js
var require_cjs = __commonJS({
  "node_modules/deepmerge/dist/cjs.js"(exports, module) {
    "use strict";
    var isMergeableObject = function isMergeableObject2(value) {
      return isNonNullObject(value) && !isSpecial(value);
    };
    function isNonNullObject(value) {
      return !!value && typeof value === "object";
    }
    function isSpecial(value) {
      var stringValue = Object.prototype.toString.call(value);
      return stringValue === "[object RegExp]" || stringValue === "[object Date]" || isReactElement(value);
    }
    var canUseSymbol = typeof Symbol === "function" && Symbol.for;
    var REACT_ELEMENT_TYPE = canUseSymbol ? Symbol.for("react.element") : 60103;
    function isReactElement(value) {
      return value.$$typeof === REACT_ELEMENT_TYPE;
    }
    function emptyTarget(val) {
      return Array.isArray(val) ? [] : {};
    }
    function cloneUnlessOtherwiseSpecified(value, options) {
      return options.clone !== false && options.isMergeableObject(value) ? deepmerge2(emptyTarget(value), value, options) : value;
    }
    function defaultArrayMerge(target, source, options) {
      return target.concat(source).map(function(element) {
        return cloneUnlessOtherwiseSpecified(element, options);
      });
    }
    function getMergeFunction(key, options) {
      if (!options.customMerge) {
        return deepmerge2;
      }
      var customMerge = options.customMerge(key);
      return typeof customMerge === "function" ? customMerge : deepmerge2;
    }
    function getEnumerableOwnPropertySymbols(target) {
      return Object.getOwnPropertySymbols ? Object.getOwnPropertySymbols(target).filter(function(symbol) {
        return Object.propertyIsEnumerable.call(target, symbol);
      }) : [];
    }
    function getKeys(target) {
      return Object.keys(target).concat(getEnumerableOwnPropertySymbols(target));
    }
    function propertyIsOnObject(object, property) {
      try {
        return property in object;
      } catch (_) {
        return false;
      }
    }
    function propertyIsUnsafe(target, key) {
      return propertyIsOnObject(target, key) && !(Object.hasOwnProperty.call(target, key) && Object.propertyIsEnumerable.call(target, key));
    }
    function mergeObject(target, source, options) {
      var destination = {};
      if (options.isMergeableObject(target)) {
        getKeys(target).forEach(function(key) {
          destination[key] = cloneUnlessOtherwiseSpecified(target[key], options);
        });
      }
      getKeys(source).forEach(function(key) {
        if (propertyIsUnsafe(target, key)) {
          return;
        }
        if (propertyIsOnObject(target, key) && options.isMergeableObject(source[key])) {
          destination[key] = getMergeFunction(key, options)(target[key], source[key], options);
        } else {
          destination[key] = cloneUnlessOtherwiseSpecified(source[key], options);
        }
      });
      return destination;
    }
    function deepmerge2(target, source, options) {
      options = options || {};
      options.arrayMerge = options.arrayMerge || defaultArrayMerge;
      options.isMergeableObject = options.isMergeableObject || isMergeableObject;
      options.cloneUnlessOtherwiseSpecified = cloneUnlessOtherwiseSpecified;
      var sourceIsArray = Array.isArray(source);
      var targetIsArray = Array.isArray(target);
      var sourceAndTargetTypesMatch = sourceIsArray === targetIsArray;
      if (!sourceAndTargetTypesMatch) {
        return cloneUnlessOtherwiseSpecified(source, options);
      } else if (sourceIsArray) {
        return options.arrayMerge(target, source, options);
      } else {
        return mergeObject(target, source, options);
      }
    }
    deepmerge2.all = function deepmergeAll(array, options) {
      if (!Array.isArray(array)) {
        throw new Error("first argument should be an array");
      }
      return array.reduce(function(prev, next2) {
        return deepmerge2(prev, next2, options);
      }, {});
    };
    var deepmerge_1 = deepmerge2;
    module.exports = deepmerge_1;
  }
});

// node_modules/fast-deep-equal/index.js
var require_fast_deep_equal = __commonJS({
  "node_modules/fast-deep-equal/index.js"(exports, module) {
    "use strict";
    module.exports = function equal2(a, b) {
      if (a === b) return true;
      if (a && b && typeof a == "object" && typeof b == "object") {
        if (a.constructor !== b.constructor) return false;
        var length, i, keys;
        if (Array.isArray(a)) {
          length = a.length;
          if (length != b.length) return false;
          for (i = length; i-- !== 0; )
            if (!equal2(a[i], b[i])) return false;
          return true;
        }
        if (a.constructor === RegExp) return a.source === b.source && a.flags === b.flags;
        if (a.valueOf !== Object.prototype.valueOf) return a.valueOf() === b.valueOf();
        if (a.toString !== Object.prototype.toString) return a.toString() === b.toString();
        keys = Object.keys(a);
        length = keys.length;
        if (length !== Object.keys(b).length) return false;
        for (i = length; i-- !== 0; )
          if (!Object.prototype.hasOwnProperty.call(b, keys[i])) return false;
        for (i = length; i-- !== 0; ) {
          var key = keys[i];
          if (!equal2(a[key], b[key])) return false;
        }
        return true;
      }
      return a !== a && b !== b;
    };
  }
});

// node_modules/jsonpointer/jsonpointer.js
var require_jsonpointer = __commonJS({
  "node_modules/jsonpointer/jsonpointer.js"(exports) {
    var hasExcape = /~/;
    var escapeMatcher = /~[01]/g;
    function escapeReplacer(m) {
      switch (m) {
        case "~1":
          return "/";
        case "~0":
          return "~";
      }
      throw new Error("Invalid tilde escape: " + m);
    }
    function untilde(str) {
      if (!hasExcape.test(str)) return str;
      return str.replace(escapeMatcher, escapeReplacer);
    }
    function setter(obj, pointer, value) {
      var part;
      var hasNextPart;
      for (var p = 1, len = pointer.length; p < len; ) {
        if (pointer[p] === "constructor" || pointer[p] === "prototype" || pointer[p] === "__proto__") return obj;
        part = untilde(pointer[p++]);
        hasNextPart = len > p;
        if (typeof obj[part] === "undefined") {
          if (Array.isArray(obj) && part === "-") {
            part = obj.length;
          }
          if (hasNextPart) {
            if (pointer[p] !== "" && pointer[p] < Infinity || pointer[p] === "-") obj[part] = [];
            else obj[part] = {};
          }
        }
        if (!hasNextPart) break;
        obj = obj[part];
      }
      var oldValue = obj[part];
      if (value === void 0) delete obj[part];
      else obj[part] = value;
      return oldValue;
    }
    function compilePointer(pointer) {
      if (typeof pointer === "string") {
        pointer = pointer.split("/");
        if (pointer[0] === "") return pointer;
        throw new Error("Invalid JSON pointer.");
      } else if (Array.isArray(pointer)) {
        for (const part of pointer) {
          if (typeof part !== "string" && typeof part !== "number") {
            throw new Error("Invalid JSON pointer. Must be of type string or number.");
          }
        }
        return pointer;
      }
      throw new Error("Invalid JSON pointer.");
    }
    function get4(obj, pointer) {
      if (typeof obj !== "object") throw new Error("Invalid input object.");
      pointer = compilePointer(pointer);
      var len = pointer.length;
      if (len === 1) return obj;
      for (var p = 1; p < len; ) {
        obj = obj[untilde(pointer[p++])];
        if (len === p) return obj;
        if (typeof obj !== "object" || obj === null) return void 0;
      }
    }
    function set(obj, pointer, value) {
      if (typeof obj !== "object") throw new Error("Invalid input object.");
      pointer = compilePointer(pointer);
      if (pointer.length === 0) throw new Error("Invalid JSON pointer for set.");
      return setter(obj, pointer, value);
    }
    function compile(pointer) {
      var compiled = compilePointer(pointer);
      return {
        get: function(object) {
          return get4(object, compiled);
        },
        set: function(object, value) {
          return set(object, compiled, value);
        }
      };
    }
    exports.get = get4;
    exports.set = set;
    exports.compile = compile;
  }
});

// node_modules/@fiberplane/hono/dist/create-open-api/index.js
function createOpenAPISpec(app, options) {
  const routes = app.routes;
  const paths = routes.filter(({ method }) => method.toLowerCase() !== "all").reduce((paths2, { path, method }) => {
    const methodLower = method.toLowerCase();
    const { openApiPath, pathParams } = (path.match(/:([^/]+)/g) || []).reduce((acc, param) => ({
      openApiPath: acc.openApiPath.replace(param, `{${param.slice(1)}}`),
      pathParams: [...acc.pathParams, param.slice(1)]
    }), { openApiPath: path, pathParams: [] });
    const operation = {
      summary: `${method.toUpperCase()} ${openApiPath}`,
      ...pathParams.length > 0 && {
        parameters: pathParams.map((param) => ({
          name: param,
          in: "path",
          required: true,
          schema: { type: "string" }
        }))
      },
      responses: {
        "200": { description: "Successful operation" }
      }
    };
    paths2[openApiPath] = {
      ...paths2[openApiPath],
      [methodLower]: operation
    };
    return paths2;
  }, {});
  const spec = {
    openapi: "3.0.0",
    info: options.info ?? { title: "Hono API", version: "1.0.0" },
    paths
  };
  if (options.tags) {
    spec.tags = options.tags;
  }
  if (options.servers) {
    spec.servers = options.servers;
  }
  if (options.components) {
    spec.components = options.components;
  }
  if (options.security) {
    spec.security = options.security;
  }
  return spec;
}

// node_modules/@fiberplane/hono/dist/constants.js
var DEFAULT_PLAYGROUND_SERVICES_URL = "https://services.fp.dev";
var ENV_FIBERPLANE_SERVICES_URL = "FIBERPLANE_SERVICES_URL";
var ENV_FIBERPLANE_OTEL_TOKEN = "FIBERPLANE_OTEL_TOKEN";
var ENV_FPX_AUTH_TOKEN = "FPX_AUTH_TOKEN";
var ENV_FIBERPLANE_OTEL_ENDPOINT = "FIBERPLANE_OTEL_ENDPOINT";
var ENV_FPX_ENDPOINT = "FPX_ENDPOINT";

// node_modules/@fiberplane/hono/dist/debug.js
function logIfDebug(debug, message, ...params) {
  try {
    const debugEnabled = typeof debug === "boolean" ? debug : !!debug?.get("debug");
    if (debugEnabled) {
      console.debug("[fiberplane:debug] ", message, ...params);
    }
  } catch {
  }
}

// node_modules/@fiberplane/hono/dist/fetch.js
var webStandardFetch = fetch;

// node_modules/@fiberplane/hono/dist/routes/api/assistant.js
function createAssistantApiRoute(apiKey, fetchFn, fiberplaneServicesUrl) {
  const app = new Hono();
  app.all("*", async (c) => {
    logIfDebug(c, "[assistant]", `- ${c.req.method} ${c.req.path} -`, "Proxying request to fiberplane api");
    const url = `${fiberplaneServicesUrl}${c.req.path}`;
    const contentType = c.req.header("content-type");
    const headers = new Headers();
    headers.set("Authorization", `Bearer ${apiKey}`);
    if (contentType) {
      logIfDebug(c, "[assistant]", `- ${c.req.method} ${c.req.path} -`, "content type attached to proxied request:", contentType);
      headers.set("content-type", contentType);
    }
    const result = fetchFn(url, {
      method: c.req.method,
      headers,
      body: c.req.raw.body
    });
    return result;
  });
  return app;
}

// node_modules/@fiberplane/hono/dist/routes/api/reports.js
function createReportsApiRoute(apiKey, fetchFn, fiberplaneServicesUrl) {
  const app = new Hono();
  app.all("*", async (c) => {
    logIfDebug(c, "[reports]", `- ${c.req.method} ${c.req.path} -`, "Proxying request to fiberplane api");
    const url = `${fiberplaneServicesUrl}${c.req.path}`;
    const contentType = c.req.header("content-type");
    const headers = new Headers();
    headers.set("Authorization", `Bearer ${apiKey}`);
    if (contentType) {
      logIfDebug(c, "[reports]", `- ${c.req.method} ${c.req.path} -`, "content type attached to proxied request:", contentType);
      headers.set("content-type", contentType);
    }
    const result = fetchFn(url, {
      method: c.req.method,
      headers,
      body: c.req.raw.body
    });
    return result;
  });
  return app;
}

// node_modules/zod/lib/index.mjs
var util;
(function(util2) {
  util2.assertEqual = (val) => val;
  function assertIs(_arg) {
  }
  util2.assertIs = assertIs;
  function assertNever(_x) {
    throw new Error();
  }
  util2.assertNever = assertNever;
  util2.arrayToEnum = (items) => {
    const obj = {};
    for (const item of items) {
      obj[item] = item;
    }
    return obj;
  };
  util2.getValidEnumValues = (obj) => {
    const validKeys = util2.objectKeys(obj).filter((k) => typeof obj[obj[k]] !== "number");
    const filtered = {};
    for (const k of validKeys) {
      filtered[k] = obj[k];
    }
    return util2.objectValues(filtered);
  };
  util2.objectValues = (obj) => {
    return util2.objectKeys(obj).map(function(e) {
      return obj[e];
    });
  };
  util2.objectKeys = typeof Object.keys === "function" ? (obj) => Object.keys(obj) : (object) => {
    const keys = [];
    for (const key in object) {
      if (Object.prototype.hasOwnProperty.call(object, key)) {
        keys.push(key);
      }
    }
    return keys;
  };
  util2.find = (arr, checker) => {
    for (const item of arr) {
      if (checker(item))
        return item;
    }
    return void 0;
  };
  util2.isInteger = typeof Number.isInteger === "function" ? (val) => Number.isInteger(val) : (val) => typeof val === "number" && isFinite(val) && Math.floor(val) === val;
  function joinValues(array, separator = " | ") {
    return array.map((val) => typeof val === "string" ? `'${val}'` : val).join(separator);
  }
  util2.joinValues = joinValues;
  util2.jsonStringifyReplacer = (_, value) => {
    if (typeof value === "bigint") {
      return value.toString();
    }
    return value;
  };
})(util || (util = {}));
var objectUtil;
(function(objectUtil2) {
  objectUtil2.mergeShapes = (first, second) => {
    return {
      ...first,
      ...second
      // second overwrites first
    };
  };
})(objectUtil || (objectUtil = {}));
var ZodParsedType = util.arrayToEnum([
  "string",
  "nan",
  "number",
  "integer",
  "float",
  "boolean",
  "date",
  "bigint",
  "symbol",
  "function",
  "undefined",
  "null",
  "array",
  "object",
  "unknown",
  "promise",
  "void",
  "never",
  "map",
  "set"
]);
var getParsedType = (data) => {
  const t = typeof data;
  switch (t) {
    case "undefined":
      return ZodParsedType.undefined;
    case "string":
      return ZodParsedType.string;
    case "number":
      return isNaN(data) ? ZodParsedType.nan : ZodParsedType.number;
    case "boolean":
      return ZodParsedType.boolean;
    case "function":
      return ZodParsedType.function;
    case "bigint":
      return ZodParsedType.bigint;
    case "symbol":
      return ZodParsedType.symbol;
    case "object":
      if (Array.isArray(data)) {
        return ZodParsedType.array;
      }
      if (data === null) {
        return ZodParsedType.null;
      }
      if (data.then && typeof data.then === "function" && data.catch && typeof data.catch === "function") {
        return ZodParsedType.promise;
      }
      if (typeof Map !== "undefined" && data instanceof Map) {
        return ZodParsedType.map;
      }
      if (typeof Set !== "undefined" && data instanceof Set) {
        return ZodParsedType.set;
      }
      if (typeof Date !== "undefined" && data instanceof Date) {
        return ZodParsedType.date;
      }
      return ZodParsedType.object;
    default:
      return ZodParsedType.unknown;
  }
};
var ZodIssueCode = util.arrayToEnum([
  "invalid_type",
  "invalid_literal",
  "custom",
  "invalid_union",
  "invalid_union_discriminator",
  "invalid_enum_value",
  "unrecognized_keys",
  "invalid_arguments",
  "invalid_return_type",
  "invalid_date",
  "invalid_string",
  "too_small",
  "too_big",
  "invalid_intersection_types",
  "not_multiple_of",
  "not_finite"
]);
var quotelessJson = (obj) => {
  const json = JSON.stringify(obj, null, 2);
  return json.replace(/"([^"]+)":/g, "$1:");
};
var ZodError = class _ZodError extends Error {
  get errors() {
    return this.issues;
  }
  constructor(issues) {
    super();
    this.issues = [];
    this.addIssue = (sub) => {
      this.issues = [...this.issues, sub];
    };
    this.addIssues = (subs = []) => {
      this.issues = [...this.issues, ...subs];
    };
    const actualProto = new.target.prototype;
    if (Object.setPrototypeOf) {
      Object.setPrototypeOf(this, actualProto);
    } else {
      this.__proto__ = actualProto;
    }
    this.name = "ZodError";
    this.issues = issues;
  }
  format(_mapper) {
    const mapper = _mapper || function(issue) {
      return issue.message;
    };
    const fieldErrors = { _errors: [] };
    const processError = (error) => {
      for (const issue of error.issues) {
        if (issue.code === "invalid_union") {
          issue.unionErrors.map(processError);
        } else if (issue.code === "invalid_return_type") {
          processError(issue.returnTypeError);
        } else if (issue.code === "invalid_arguments") {
          processError(issue.argumentsError);
        } else if (issue.path.length === 0) {
          fieldErrors._errors.push(mapper(issue));
        } else {
          let curr = fieldErrors;
          let i = 0;
          while (i < issue.path.length) {
            const el = issue.path[i];
            const terminal = i === issue.path.length - 1;
            if (!terminal) {
              curr[el] = curr[el] || { _errors: [] };
            } else {
              curr[el] = curr[el] || { _errors: [] };
              curr[el]._errors.push(mapper(issue));
            }
            curr = curr[el];
            i++;
          }
        }
      }
    };
    processError(this);
    return fieldErrors;
  }
  static assert(value) {
    if (!(value instanceof _ZodError)) {
      throw new Error(`Not a ZodError: ${value}`);
    }
  }
  toString() {
    return this.message;
  }
  get message() {
    return JSON.stringify(this.issues, util.jsonStringifyReplacer, 2);
  }
  get isEmpty() {
    return this.issues.length === 0;
  }
  flatten(mapper = (issue) => issue.message) {
    const fieldErrors = {};
    const formErrors = [];
    for (const sub of this.issues) {
      if (sub.path.length > 0) {
        fieldErrors[sub.path[0]] = fieldErrors[sub.path[0]] || [];
        fieldErrors[sub.path[0]].push(mapper(sub));
      } else {
        formErrors.push(mapper(sub));
      }
    }
    return { formErrors, fieldErrors };
  }
  get formErrors() {
    return this.flatten();
  }
};
ZodError.create = (issues) => {
  const error = new ZodError(issues);
  return error;
};
var errorMap = (issue, _ctx) => {
  let message;
  switch (issue.code) {
    case ZodIssueCode.invalid_type:
      if (issue.received === ZodParsedType.undefined) {
        message = "Required";
      } else {
        message = `Expected ${issue.expected}, received ${issue.received}`;
      }
      break;
    case ZodIssueCode.invalid_literal:
      message = `Invalid literal value, expected ${JSON.stringify(issue.expected, util.jsonStringifyReplacer)}`;
      break;
    case ZodIssueCode.unrecognized_keys:
      message = `Unrecognized key(s) in object: ${util.joinValues(issue.keys, ", ")}`;
      break;
    case ZodIssueCode.invalid_union:
      message = `Invalid input`;
      break;
    case ZodIssueCode.invalid_union_discriminator:
      message = `Invalid discriminator value. Expected ${util.joinValues(issue.options)}`;
      break;
    case ZodIssueCode.invalid_enum_value:
      message = `Invalid enum value. Expected ${util.joinValues(issue.options)}, received '${issue.received}'`;
      break;
    case ZodIssueCode.invalid_arguments:
      message = `Invalid function arguments`;
      break;
    case ZodIssueCode.invalid_return_type:
      message = `Invalid function return type`;
      break;
    case ZodIssueCode.invalid_date:
      message = `Invalid date`;
      break;
    case ZodIssueCode.invalid_string:
      if (typeof issue.validation === "object") {
        if ("includes" in issue.validation) {
          message = `Invalid input: must include "${issue.validation.includes}"`;
          if (typeof issue.validation.position === "number") {
            message = `${message} at one or more positions greater than or equal to ${issue.validation.position}`;
          }
        } else if ("startsWith" in issue.validation) {
          message = `Invalid input: must start with "${issue.validation.startsWith}"`;
        } else if ("endsWith" in issue.validation) {
          message = `Invalid input: must end with "${issue.validation.endsWith}"`;
        } else {
          util.assertNever(issue.validation);
        }
      } else if (issue.validation !== "regex") {
        message = `Invalid ${issue.validation}`;
      } else {
        message = "Invalid";
      }
      break;
    case ZodIssueCode.too_small:
      if (issue.type === "array")
        message = `Array must contain ${issue.exact ? "exactly" : issue.inclusive ? `at least` : `more than`} ${issue.minimum} element(s)`;
      else if (issue.type === "string")
        message = `String must contain ${issue.exact ? "exactly" : issue.inclusive ? `at least` : `over`} ${issue.minimum} character(s)`;
      else if (issue.type === "number")
        message = `Number must be ${issue.exact ? `exactly equal to ` : issue.inclusive ? `greater than or equal to ` : `greater than `}${issue.minimum}`;
      else if (issue.type === "date")
        message = `Date must be ${issue.exact ? `exactly equal to ` : issue.inclusive ? `greater than or equal to ` : `greater than `}${new Date(Number(issue.minimum))}`;
      else
        message = "Invalid input";
      break;
    case ZodIssueCode.too_big:
      if (issue.type === "array")
        message = `Array must contain ${issue.exact ? `exactly` : issue.inclusive ? `at most` : `less than`} ${issue.maximum} element(s)`;
      else if (issue.type === "string")
        message = `String must contain ${issue.exact ? `exactly` : issue.inclusive ? `at most` : `under`} ${issue.maximum} character(s)`;
      else if (issue.type === "number")
        message = `Number must be ${issue.exact ? `exactly` : issue.inclusive ? `less than or equal to` : `less than`} ${issue.maximum}`;
      else if (issue.type === "bigint")
        message = `BigInt must be ${issue.exact ? `exactly` : issue.inclusive ? `less than or equal to` : `less than`} ${issue.maximum}`;
      else if (issue.type === "date")
        message = `Date must be ${issue.exact ? `exactly` : issue.inclusive ? `smaller than or equal to` : `smaller than`} ${new Date(Number(issue.maximum))}`;
      else
        message = "Invalid input";
      break;
    case ZodIssueCode.custom:
      message = `Invalid input`;
      break;
    case ZodIssueCode.invalid_intersection_types:
      message = `Intersection results could not be merged`;
      break;
    case ZodIssueCode.not_multiple_of:
      message = `Number must be a multiple of ${issue.multipleOf}`;
      break;
    case ZodIssueCode.not_finite:
      message = "Number must be finite";
      break;
    default:
      message = _ctx.defaultError;
      util.assertNever(issue);
  }
  return { message };
};
var overrideErrorMap = errorMap;
function setErrorMap(map) {
  overrideErrorMap = map;
}
function getErrorMap() {
  return overrideErrorMap;
}
var makeIssue = (params) => {
  const { data, path, errorMaps, issueData } = params;
  const fullPath = [...path, ...issueData.path || []];
  const fullIssue = {
    ...issueData,
    path: fullPath
  };
  if (issueData.message !== void 0) {
    return {
      ...issueData,
      path: fullPath,
      message: issueData.message
    };
  }
  let errorMessage = "";
  const maps = errorMaps.filter((m) => !!m).slice().reverse();
  for (const map of maps) {
    errorMessage = map(fullIssue, { data, defaultError: errorMessage }).message;
  }
  return {
    ...issueData,
    path: fullPath,
    message: errorMessage
  };
};
var EMPTY_PATH = [];
function addIssueToContext(ctx, issueData) {
  const overrideMap = getErrorMap();
  const issue = makeIssue({
    issueData,
    data: ctx.data,
    path: ctx.path,
    errorMaps: [
      ctx.common.contextualErrorMap,
      // contextual error map is first priority
      ctx.schemaErrorMap,
      // then schema-bound map if available
      overrideMap,
      // then global override map
      overrideMap === errorMap ? void 0 : errorMap
      // then global default map
    ].filter((x) => !!x)
  });
  ctx.common.issues.push(issue);
}
var ParseStatus = class _ParseStatus {
  constructor() {
    this.value = "valid";
  }
  dirty() {
    if (this.value === "valid")
      this.value = "dirty";
  }
  abort() {
    if (this.value !== "aborted")
      this.value = "aborted";
  }
  static mergeArray(status, results) {
    const arrayValue = [];
    for (const s of results) {
      if (s.status === "aborted")
        return INVALID;
      if (s.status === "dirty")
        status.dirty();
      arrayValue.push(s.value);
    }
    return { status: status.value, value: arrayValue };
  }
  static async mergeObjectAsync(status, pairs) {
    const syncPairs = [];
    for (const pair of pairs) {
      const key = await pair.key;
      const value = await pair.value;
      syncPairs.push({
        key,
        value
      });
    }
    return _ParseStatus.mergeObjectSync(status, syncPairs);
  }
  static mergeObjectSync(status, pairs) {
    const finalObject = {};
    for (const pair of pairs) {
      const { key, value } = pair;
      if (key.status === "aborted")
        return INVALID;
      if (value.status === "aborted")
        return INVALID;
      if (key.status === "dirty")
        status.dirty();
      if (value.status === "dirty")
        status.dirty();
      if (key.value !== "__proto__" && (typeof value.value !== "undefined" || pair.alwaysSet)) {
        finalObject[key.value] = value.value;
      }
    }
    return { status: status.value, value: finalObject };
  }
};
var INVALID = Object.freeze({
  status: "aborted"
});
var DIRTY = (value) => ({ status: "dirty", value });
var OK = (value) => ({ status: "valid", value });
var isAborted = (x) => x.status === "aborted";
var isDirty = (x) => x.status === "dirty";
var isValid = (x) => x.status === "valid";
var isAsync = (x) => typeof Promise !== "undefined" && x instanceof Promise;
function __classPrivateFieldGet(receiver, state, kind, f) {
  if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
}
function __classPrivateFieldSet(receiver, state, value, kind, f) {
  if (kind === "m") throw new TypeError("Private method is not writable");
  if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
}
var errorUtil;
(function(errorUtil2) {
  errorUtil2.errToObj = (message) => typeof message === "string" ? { message } : message || {};
  errorUtil2.toString = (message) => typeof message === "string" ? message : message === null || message === void 0 ? void 0 : message.message;
})(errorUtil || (errorUtil = {}));
var _ZodEnum_cache;
var _ZodNativeEnum_cache;
var ParseInputLazyPath = class {
  constructor(parent, value, path, key) {
    this._cachedPath = [];
    this.parent = parent;
    this.data = value;
    this._path = path;
    this._key = key;
  }
  get path() {
    if (!this._cachedPath.length) {
      if (this._key instanceof Array) {
        this._cachedPath.push(...this._path, ...this._key);
      } else {
        this._cachedPath.push(...this._path, this._key);
      }
    }
    return this._cachedPath;
  }
};
var handleResult = (ctx, result) => {
  if (isValid(result)) {
    return { success: true, data: result.value };
  } else {
    if (!ctx.common.issues.length) {
      throw new Error("Validation failed but no issues detected.");
    }
    return {
      success: false,
      get error() {
        if (this._error)
          return this._error;
        const error = new ZodError(ctx.common.issues);
        this._error = error;
        return this._error;
      }
    };
  }
};
function processCreateParams(params) {
  if (!params)
    return {};
  const { errorMap: errorMap2, invalid_type_error, required_error, description } = params;
  if (errorMap2 && (invalid_type_error || required_error)) {
    throw new Error(`Can't use "invalid_type_error" or "required_error" in conjunction with custom error map.`);
  }
  if (errorMap2)
    return { errorMap: errorMap2, description };
  const customMap = (iss, ctx) => {
    var _a2, _b;
    const { message } = params;
    if (iss.code === "invalid_enum_value") {
      return { message: message !== null && message !== void 0 ? message : ctx.defaultError };
    }
    if (typeof ctx.data === "undefined") {
      return { message: (_a2 = message !== null && message !== void 0 ? message : required_error) !== null && _a2 !== void 0 ? _a2 : ctx.defaultError };
    }
    if (iss.code !== "invalid_type")
      return { message: ctx.defaultError };
    return { message: (_b = message !== null && message !== void 0 ? message : invalid_type_error) !== null && _b !== void 0 ? _b : ctx.defaultError };
  };
  return { errorMap: customMap, description };
}
var ZodType = class {
  get description() {
    return this._def.description;
  }
  _getType(input2) {
    return getParsedType(input2.data);
  }
  _getOrReturnCtx(input2, ctx) {
    return ctx || {
      common: input2.parent.common,
      data: input2.data,
      parsedType: getParsedType(input2.data),
      schemaErrorMap: this._def.errorMap,
      path: input2.path,
      parent: input2.parent
    };
  }
  _processInputParams(input2) {
    return {
      status: new ParseStatus(),
      ctx: {
        common: input2.parent.common,
        data: input2.data,
        parsedType: getParsedType(input2.data),
        schemaErrorMap: this._def.errorMap,
        path: input2.path,
        parent: input2.parent
      }
    };
  }
  _parseSync(input2) {
    const result = this._parse(input2);
    if (isAsync(result)) {
      throw new Error("Synchronous parse encountered promise.");
    }
    return result;
  }
  _parseAsync(input2) {
    const result = this._parse(input2);
    return Promise.resolve(result);
  }
  parse(data, params) {
    const result = this.safeParse(data, params);
    if (result.success)
      return result.data;
    throw result.error;
  }
  safeParse(data, params) {
    var _a2;
    const ctx = {
      common: {
        issues: [],
        async: (_a2 = params === null || params === void 0 ? void 0 : params.async) !== null && _a2 !== void 0 ? _a2 : false,
        contextualErrorMap: params === null || params === void 0 ? void 0 : params.errorMap
      },
      path: (params === null || params === void 0 ? void 0 : params.path) || [],
      schemaErrorMap: this._def.errorMap,
      parent: null,
      data,
      parsedType: getParsedType(data)
    };
    const result = this._parseSync({ data, path: ctx.path, parent: ctx });
    return handleResult(ctx, result);
  }
  "~validate"(data) {
    var _a2, _b;
    const ctx = {
      common: {
        issues: [],
        async: !!this["~standard"].async
      },
      path: [],
      schemaErrorMap: this._def.errorMap,
      parent: null,
      data,
      parsedType: getParsedType(data)
    };
    if (!this["~standard"].async) {
      try {
        const result = this._parseSync({ data, path: [], parent: ctx });
        return isValid(result) ? {
          value: result.value
        } : {
          issues: ctx.common.issues
        };
      } catch (err) {
        if ((_b = (_a2 = err === null || err === void 0 ? void 0 : err.message) === null || _a2 === void 0 ? void 0 : _a2.toLowerCase()) === null || _b === void 0 ? void 0 : _b.includes("encountered")) {
          this["~standard"].async = true;
        }
        ctx.common = {
          issues: [],
          async: true
        };
      }
    }
    return this._parseAsync({ data, path: [], parent: ctx }).then((result) => isValid(result) ? {
      value: result.value
    } : {
      issues: ctx.common.issues
    });
  }
  async parseAsync(data, params) {
    const result = await this.safeParseAsync(data, params);
    if (result.success)
      return result.data;
    throw result.error;
  }
  async safeParseAsync(data, params) {
    const ctx = {
      common: {
        issues: [],
        contextualErrorMap: params === null || params === void 0 ? void 0 : params.errorMap,
        async: true
      },
      path: (params === null || params === void 0 ? void 0 : params.path) || [],
      schemaErrorMap: this._def.errorMap,
      parent: null,
      data,
      parsedType: getParsedType(data)
    };
    const maybeAsyncResult = this._parse({ data, path: ctx.path, parent: ctx });
    const result = await (isAsync(maybeAsyncResult) ? maybeAsyncResult : Promise.resolve(maybeAsyncResult));
    return handleResult(ctx, result);
  }
  refine(check, message) {
    const getIssueProperties = (val) => {
      if (typeof message === "string" || typeof message === "undefined") {
        return { message };
      } else if (typeof message === "function") {
        return message(val);
      } else {
        return message;
      }
    };
    return this._refinement((val, ctx) => {
      const result = check(val);
      const setError = () => ctx.addIssue({
        code: ZodIssueCode.custom,
        ...getIssueProperties(val)
      });
      if (typeof Promise !== "undefined" && result instanceof Promise) {
        return result.then((data) => {
          if (!data) {
            setError();
            return false;
          } else {
            return true;
          }
        });
      }
      if (!result) {
        setError();
        return false;
      } else {
        return true;
      }
    });
  }
  refinement(check, refinementData) {
    return this._refinement((val, ctx) => {
      if (!check(val)) {
        ctx.addIssue(typeof refinementData === "function" ? refinementData(val, ctx) : refinementData);
        return false;
      } else {
        return true;
      }
    });
  }
  _refinement(refinement) {
    return new ZodEffects({
      schema: this,
      typeName: ZodFirstPartyTypeKind.ZodEffects,
      effect: { type: "refinement", refinement }
    });
  }
  superRefine(refinement) {
    return this._refinement(refinement);
  }
  constructor(def) {
    this.spa = this.safeParseAsync;
    this._def = def;
    this.parse = this.parse.bind(this);
    this.safeParse = this.safeParse.bind(this);
    this.parseAsync = this.parseAsync.bind(this);
    this.safeParseAsync = this.safeParseAsync.bind(this);
    this.spa = this.spa.bind(this);
    this.refine = this.refine.bind(this);
    this.refinement = this.refinement.bind(this);
    this.superRefine = this.superRefine.bind(this);
    this.optional = this.optional.bind(this);
    this.nullable = this.nullable.bind(this);
    this.nullish = this.nullish.bind(this);
    this.array = this.array.bind(this);
    this.promise = this.promise.bind(this);
    this.or = this.or.bind(this);
    this.and = this.and.bind(this);
    this.transform = this.transform.bind(this);
    this.brand = this.brand.bind(this);
    this.default = this.default.bind(this);
    this.catch = this.catch.bind(this);
    this.describe = this.describe.bind(this);
    this.pipe = this.pipe.bind(this);
    this.readonly = this.readonly.bind(this);
    this.isNullable = this.isNullable.bind(this);
    this.isOptional = this.isOptional.bind(this);
    this["~standard"] = {
      version: 1,
      vendor: "zod",
      validate: (data) => this["~validate"](data)
    };
  }
  optional() {
    return ZodOptional.create(this, this._def);
  }
  nullable() {
    return ZodNullable.create(this, this._def);
  }
  nullish() {
    return this.nullable().optional();
  }
  array() {
    return ZodArray.create(this);
  }
  promise() {
    return ZodPromise.create(this, this._def);
  }
  or(option) {
    return ZodUnion.create([this, option], this._def);
  }
  and(incoming) {
    return ZodIntersection.create(this, incoming, this._def);
  }
  transform(transform) {
    return new ZodEffects({
      ...processCreateParams(this._def),
      schema: this,
      typeName: ZodFirstPartyTypeKind.ZodEffects,
      effect: { type: "transform", transform }
    });
  }
  default(def) {
    const defaultValueFunc = typeof def === "function" ? def : () => def;
    return new ZodDefault({
      ...processCreateParams(this._def),
      innerType: this,
      defaultValue: defaultValueFunc,
      typeName: ZodFirstPartyTypeKind.ZodDefault
    });
  }
  brand() {
    return new ZodBranded({
      typeName: ZodFirstPartyTypeKind.ZodBranded,
      type: this,
      ...processCreateParams(this._def)
    });
  }
  catch(def) {
    const catchValueFunc = typeof def === "function" ? def : () => def;
    return new ZodCatch({
      ...processCreateParams(this._def),
      innerType: this,
      catchValue: catchValueFunc,
      typeName: ZodFirstPartyTypeKind.ZodCatch
    });
  }
  describe(description) {
    const This = this.constructor;
    return new This({
      ...this._def,
      description
    });
  }
  pipe(target) {
    return ZodPipeline.create(this, target);
  }
  readonly() {
    return ZodReadonly.create(this);
  }
  isOptional() {
    return this.safeParse(void 0).success;
  }
  isNullable() {
    return this.safeParse(null).success;
  }
};
var cuidRegex = /^c[^\s-]{8,}$/i;
var cuid2Regex = /^[0-9a-z]+$/;
var ulidRegex = /^[0-9A-HJKMNP-TV-Z]{26}$/i;
var uuidRegex = /^[0-9a-fA-F]{8}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{12}$/i;
var nanoidRegex = /^[a-z0-9_-]{21}$/i;
var jwtRegex = /^[A-Za-z0-9-_]+\.[A-Za-z0-9-_]+\.[A-Za-z0-9-_]*$/;
var durationRegex = /^[-+]?P(?!$)(?:(?:[-+]?\d+Y)|(?:[-+]?\d+[.,]\d+Y$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:(?:[-+]?\d+W)|(?:[-+]?\d+[.,]\d+W$))?(?:(?:[-+]?\d+D)|(?:[-+]?\d+[.,]\d+D$))?(?:T(?=[\d+-])(?:(?:[-+]?\d+H)|(?:[-+]?\d+[.,]\d+H$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:[-+]?\d+(?:[.,]\d+)?S)?)??$/;
var emailRegex = /^(?!\.)(?!.*\.\.)([A-Z0-9_'+\-\.]*)[A-Z0-9_+-]@([A-Z0-9][A-Z0-9\-]*\.)+[A-Z]{2,}$/i;
var _emojiRegex = `^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$`;
var emojiRegex;
var ipv4Regex = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/;
var ipv4CidrRegex = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\/(3[0-2]|[12]?[0-9])$/;
var ipv6Regex = /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))$/;
var ipv6CidrRegex = /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))\/(12[0-8]|1[01][0-9]|[1-9]?[0-9])$/;
var base64Regex = /^([0-9a-zA-Z+/]{4})*(([0-9a-zA-Z+/]{2}==)|([0-9a-zA-Z+/]{3}=))?$/;
var base64urlRegex = /^([0-9a-zA-Z-_]{4})*(([0-9a-zA-Z-_]{2}(==)?)|([0-9a-zA-Z-_]{3}(=)?))?$/;
var dateRegexSource = `((\\d\\d[2468][048]|\\d\\d[13579][26]|\\d\\d0[48]|[02468][048]00|[13579][26]00)-02-29|\\d{4}-((0[13578]|1[02])-(0[1-9]|[12]\\d|3[01])|(0[469]|11)-(0[1-9]|[12]\\d|30)|(02)-(0[1-9]|1\\d|2[0-8])))`;
var dateRegex = new RegExp(`^${dateRegexSource}$`);
function timeRegexSource(args) {
  let regex = `([01]\\d|2[0-3]):[0-5]\\d:[0-5]\\d`;
  if (args.precision) {
    regex = `${regex}\\.\\d{${args.precision}}`;
  } else if (args.precision == null) {
    regex = `${regex}(\\.\\d+)?`;
  }
  return regex;
}
function timeRegex(args) {
  return new RegExp(`^${timeRegexSource(args)}$`);
}
function datetimeRegex(args) {
  let regex = `${dateRegexSource}T${timeRegexSource(args)}`;
  const opts = [];
  opts.push(args.local ? `Z?` : `Z`);
  if (args.offset)
    opts.push(`([+-]\\d{2}:?\\d{2})`);
  regex = `${regex}(${opts.join("|")})`;
  return new RegExp(`^${regex}$`);
}
function isValidIP(ip, version) {
  if ((version === "v4" || !version) && ipv4Regex.test(ip)) {
    return true;
  }
  if ((version === "v6" || !version) && ipv6Regex.test(ip)) {
    return true;
  }
  return false;
}
function isValidJWT(jwt, alg) {
  if (!jwtRegex.test(jwt))
    return false;
  try {
    const [header] = jwt.split(".");
    const base64 = header.replace(/-/g, "+").replace(/_/g, "/").padEnd(header.length + (4 - header.length % 4) % 4, "=");
    const decoded = JSON.parse(atob(base64));
    if (typeof decoded !== "object" || decoded === null)
      return false;
    if (!decoded.typ || !decoded.alg)
      return false;
    if (alg && decoded.alg !== alg)
      return false;
    return true;
  } catch (_a2) {
    return false;
  }
}
function isValidCidr(ip, version) {
  if ((version === "v4" || !version) && ipv4CidrRegex.test(ip)) {
    return true;
  }
  if ((version === "v6" || !version) && ipv6CidrRegex.test(ip)) {
    return true;
  }
  return false;
}
var ZodString = class _ZodString extends ZodType {
  _parse(input2) {
    if (this._def.coerce) {
      input2.data = String(input2.data);
    }
    const parsedType = this._getType(input2);
    if (parsedType !== ZodParsedType.string) {
      const ctx2 = this._getOrReturnCtx(input2);
      addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.string,
        received: ctx2.parsedType
      });
      return INVALID;
    }
    const status = new ParseStatus();
    let ctx = void 0;
    for (const check of this._def.checks) {
      if (check.kind === "min") {
        if (input2.data.length < check.value) {
          ctx = this._getOrReturnCtx(input2, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_small,
            minimum: check.value,
            type: "string",
            inclusive: true,
            exact: false,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "max") {
        if (input2.data.length > check.value) {
          ctx = this._getOrReturnCtx(input2, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_big,
            maximum: check.value,
            type: "string",
            inclusive: true,
            exact: false,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "length") {
        const tooBig = input2.data.length > check.value;
        const tooSmall = input2.data.length < check.value;
        if (tooBig || tooSmall) {
          ctx = this._getOrReturnCtx(input2, ctx);
          if (tooBig) {
            addIssueToContext(ctx, {
              code: ZodIssueCode.too_big,
              maximum: check.value,
              type: "string",
              inclusive: true,
              exact: true,
              message: check.message
            });
          } else if (tooSmall) {
            addIssueToContext(ctx, {
              code: ZodIssueCode.too_small,
              minimum: check.value,
              type: "string",
              inclusive: true,
              exact: true,
              message: check.message
            });
          }
          status.dirty();
        }
      } else if (check.kind === "email") {
        if (!emailRegex.test(input2.data)) {
          ctx = this._getOrReturnCtx(input2, ctx);
          addIssueToContext(ctx, {
            validation: "email",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "emoji") {
        if (!emojiRegex) {
          emojiRegex = new RegExp(_emojiRegex, "u");
        }
        if (!emojiRegex.test(input2.data)) {
          ctx = this._getOrReturnCtx(input2, ctx);
          addIssueToContext(ctx, {
            validation: "emoji",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "uuid") {
        if (!uuidRegex.test(input2.data)) {
          ctx = this._getOrReturnCtx(input2, ctx);
          addIssueToContext(ctx, {
            validation: "uuid",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "nanoid") {
        if (!nanoidRegex.test(input2.data)) {
          ctx = this._getOrReturnCtx(input2, ctx);
          addIssueToContext(ctx, {
            validation: "nanoid",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "cuid") {
        if (!cuidRegex.test(input2.data)) {
          ctx = this._getOrReturnCtx(input2, ctx);
          addIssueToContext(ctx, {
            validation: "cuid",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "cuid2") {
        if (!cuid2Regex.test(input2.data)) {
          ctx = this._getOrReturnCtx(input2, ctx);
          addIssueToContext(ctx, {
            validation: "cuid2",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "ulid") {
        if (!ulidRegex.test(input2.data)) {
          ctx = this._getOrReturnCtx(input2, ctx);
          addIssueToContext(ctx, {
            validation: "ulid",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "url") {
        try {
          new URL(input2.data);
        } catch (_a2) {
          ctx = this._getOrReturnCtx(input2, ctx);
          addIssueToContext(ctx, {
            validation: "url",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "regex") {
        check.regex.lastIndex = 0;
        const testResult = check.regex.test(input2.data);
        if (!testResult) {
          ctx = this._getOrReturnCtx(input2, ctx);
          addIssueToContext(ctx, {
            validation: "regex",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "trim") {
        input2.data = input2.data.trim();
      } else if (check.kind === "includes") {
        if (!input2.data.includes(check.value, check.position)) {
          ctx = this._getOrReturnCtx(input2, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_string,
            validation: { includes: check.value, position: check.position },
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "toLowerCase") {
        input2.data = input2.data.toLowerCase();
      } else if (check.kind === "toUpperCase") {
        input2.data = input2.data.toUpperCase();
      } else if (check.kind === "startsWith") {
        if (!input2.data.startsWith(check.value)) {
          ctx = this._getOrReturnCtx(input2, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_string,
            validation: { startsWith: check.value },
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "endsWith") {
        if (!input2.data.endsWith(check.value)) {
          ctx = this._getOrReturnCtx(input2, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_string,
            validation: { endsWith: check.value },
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "datetime") {
        const regex = datetimeRegex(check);
        if (!regex.test(input2.data)) {
          ctx = this._getOrReturnCtx(input2, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_string,
            validation: "datetime",
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "date") {
        const regex = dateRegex;
        if (!regex.test(input2.data)) {
          ctx = this._getOrReturnCtx(input2, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_string,
            validation: "date",
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "time") {
        const regex = timeRegex(check);
        if (!regex.test(input2.data)) {
          ctx = this._getOrReturnCtx(input2, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_string,
            validation: "time",
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "duration") {
        if (!durationRegex.test(input2.data)) {
          ctx = this._getOrReturnCtx(input2, ctx);
          addIssueToContext(ctx, {
            validation: "duration",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "ip") {
        if (!isValidIP(input2.data, check.version)) {
          ctx = this._getOrReturnCtx(input2, ctx);
          addIssueToContext(ctx, {
            validation: "ip",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "jwt") {
        if (!isValidJWT(input2.data, check.alg)) {
          ctx = this._getOrReturnCtx(input2, ctx);
          addIssueToContext(ctx, {
            validation: "jwt",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "cidr") {
        if (!isValidCidr(input2.data, check.version)) {
          ctx = this._getOrReturnCtx(input2, ctx);
          addIssueToContext(ctx, {
            validation: "cidr",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "base64") {
        if (!base64Regex.test(input2.data)) {
          ctx = this._getOrReturnCtx(input2, ctx);
          addIssueToContext(ctx, {
            validation: "base64",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "base64url") {
        if (!base64urlRegex.test(input2.data)) {
          ctx = this._getOrReturnCtx(input2, ctx);
          addIssueToContext(ctx, {
            validation: "base64url",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else {
        util.assertNever(check);
      }
    }
    return { status: status.value, value: input2.data };
  }
  _regex(regex, validation, message) {
    return this.refinement((data) => regex.test(data), {
      validation,
      code: ZodIssueCode.invalid_string,
      ...errorUtil.errToObj(message)
    });
  }
  _addCheck(check) {
    return new _ZodString({
      ...this._def,
      checks: [...this._def.checks, check]
    });
  }
  email(message) {
    return this._addCheck({ kind: "email", ...errorUtil.errToObj(message) });
  }
  url(message) {
    return this._addCheck({ kind: "url", ...errorUtil.errToObj(message) });
  }
  emoji(message) {
    return this._addCheck({ kind: "emoji", ...errorUtil.errToObj(message) });
  }
  uuid(message) {
    return this._addCheck({ kind: "uuid", ...errorUtil.errToObj(message) });
  }
  nanoid(message) {
    return this._addCheck({ kind: "nanoid", ...errorUtil.errToObj(message) });
  }
  cuid(message) {
    return this._addCheck({ kind: "cuid", ...errorUtil.errToObj(message) });
  }
  cuid2(message) {
    return this._addCheck({ kind: "cuid2", ...errorUtil.errToObj(message) });
  }
  ulid(message) {
    return this._addCheck({ kind: "ulid", ...errorUtil.errToObj(message) });
  }
  base64(message) {
    return this._addCheck({ kind: "base64", ...errorUtil.errToObj(message) });
  }
  base64url(message) {
    return this._addCheck({
      kind: "base64url",
      ...errorUtil.errToObj(message)
    });
  }
  jwt(options) {
    return this._addCheck({ kind: "jwt", ...errorUtil.errToObj(options) });
  }
  ip(options) {
    return this._addCheck({ kind: "ip", ...errorUtil.errToObj(options) });
  }
  cidr(options) {
    return this._addCheck({ kind: "cidr", ...errorUtil.errToObj(options) });
  }
  datetime(options) {
    var _a2, _b;
    if (typeof options === "string") {
      return this._addCheck({
        kind: "datetime",
        precision: null,
        offset: false,
        local: false,
        message: options
      });
    }
    return this._addCheck({
      kind: "datetime",
      precision: typeof (options === null || options === void 0 ? void 0 : options.precision) === "undefined" ? null : options === null || options === void 0 ? void 0 : options.precision,
      offset: (_a2 = options === null || options === void 0 ? void 0 : options.offset) !== null && _a2 !== void 0 ? _a2 : false,
      local: (_b = options === null || options === void 0 ? void 0 : options.local) !== null && _b !== void 0 ? _b : false,
      ...errorUtil.errToObj(options === null || options === void 0 ? void 0 : options.message)
    });
  }
  date(message) {
    return this._addCheck({ kind: "date", message });
  }
  time(options) {
    if (typeof options === "string") {
      return this._addCheck({
        kind: "time",
        precision: null,
        message: options
      });
    }
    return this._addCheck({
      kind: "time",
      precision: typeof (options === null || options === void 0 ? void 0 : options.precision) === "undefined" ? null : options === null || options === void 0 ? void 0 : options.precision,
      ...errorUtil.errToObj(options === null || options === void 0 ? void 0 : options.message)
    });
  }
  duration(message) {
    return this._addCheck({ kind: "duration", ...errorUtil.errToObj(message) });
  }
  regex(regex, message) {
    return this._addCheck({
      kind: "regex",
      regex,
      ...errorUtil.errToObj(message)
    });
  }
  includes(value, options) {
    return this._addCheck({
      kind: "includes",
      value,
      position: options === null || options === void 0 ? void 0 : options.position,
      ...errorUtil.errToObj(options === null || options === void 0 ? void 0 : options.message)
    });
  }
  startsWith(value, message) {
    return this._addCheck({
      kind: "startsWith",
      value,
      ...errorUtil.errToObj(message)
    });
  }
  endsWith(value, message) {
    return this._addCheck({
      kind: "endsWith",
      value,
      ...errorUtil.errToObj(message)
    });
  }
  min(minLength, message) {
    return this._addCheck({
      kind: "min",
      value: minLength,
      ...errorUtil.errToObj(message)
    });
  }
  max(maxLength, message) {
    return this._addCheck({
      kind: "max",
      value: maxLength,
      ...errorUtil.errToObj(message)
    });
  }
  length(len, message) {
    return this._addCheck({
      kind: "length",
      value: len,
      ...errorUtil.errToObj(message)
    });
  }
  /**
   * Equivalent to `.min(1)`
   */
  nonempty(message) {
    return this.min(1, errorUtil.errToObj(message));
  }
  trim() {
    return new _ZodString({
      ...this._def,
      checks: [...this._def.checks, { kind: "trim" }]
    });
  }
  toLowerCase() {
    return new _ZodString({
      ...this._def,
      checks: [...this._def.checks, { kind: "toLowerCase" }]
    });
  }
  toUpperCase() {
    return new _ZodString({
      ...this._def,
      checks: [...this._def.checks, { kind: "toUpperCase" }]
    });
  }
  get isDatetime() {
    return !!this._def.checks.find((ch) => ch.kind === "datetime");
  }
  get isDate() {
    return !!this._def.checks.find((ch) => ch.kind === "date");
  }
  get isTime() {
    return !!this._def.checks.find((ch) => ch.kind === "time");
  }
  get isDuration() {
    return !!this._def.checks.find((ch) => ch.kind === "duration");
  }
  get isEmail() {
    return !!this._def.checks.find((ch) => ch.kind === "email");
  }
  get isURL() {
    return !!this._def.checks.find((ch) => ch.kind === "url");
  }
  get isEmoji() {
    return !!this._def.checks.find((ch) => ch.kind === "emoji");
  }
  get isUUID() {
    return !!this._def.checks.find((ch) => ch.kind === "uuid");
  }
  get isNANOID() {
    return !!this._def.checks.find((ch) => ch.kind === "nanoid");
  }
  get isCUID() {
    return !!this._def.checks.find((ch) => ch.kind === "cuid");
  }
  get isCUID2() {
    return !!this._def.checks.find((ch) => ch.kind === "cuid2");
  }
  get isULID() {
    return !!this._def.checks.find((ch) => ch.kind === "ulid");
  }
  get isIP() {
    return !!this._def.checks.find((ch) => ch.kind === "ip");
  }
  get isCIDR() {
    return !!this._def.checks.find((ch) => ch.kind === "cidr");
  }
  get isBase64() {
    return !!this._def.checks.find((ch) => ch.kind === "base64");
  }
  get isBase64url() {
    return !!this._def.checks.find((ch) => ch.kind === "base64url");
  }
  get minLength() {
    let min = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "min") {
        if (min === null || ch.value > min)
          min = ch.value;
      }
    }
    return min;
  }
  get maxLength() {
    let max = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "max") {
        if (max === null || ch.value < max)
          max = ch.value;
      }
    }
    return max;
  }
};
ZodString.create = (params) => {
  var _a2;
  return new ZodString({
    checks: [],
    typeName: ZodFirstPartyTypeKind.ZodString,
    coerce: (_a2 = params === null || params === void 0 ? void 0 : params.coerce) !== null && _a2 !== void 0 ? _a2 : false,
    ...processCreateParams(params)
  });
};
function floatSafeRemainder(val, step2) {
  const valDecCount = (val.toString().split(".")[1] || "").length;
  const stepDecCount = (step2.toString().split(".")[1] || "").length;
  const decCount = valDecCount > stepDecCount ? valDecCount : stepDecCount;
  const valInt = parseInt(val.toFixed(decCount).replace(".", ""));
  const stepInt = parseInt(step2.toFixed(decCount).replace(".", ""));
  return valInt % stepInt / Math.pow(10, decCount);
}
var ZodNumber = class _ZodNumber extends ZodType {
  constructor() {
    super(...arguments);
    this.min = this.gte;
    this.max = this.lte;
    this.step = this.multipleOf;
  }
  _parse(input2) {
    if (this._def.coerce) {
      input2.data = Number(input2.data);
    }
    const parsedType = this._getType(input2);
    if (parsedType !== ZodParsedType.number) {
      const ctx2 = this._getOrReturnCtx(input2);
      addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.number,
        received: ctx2.parsedType
      });
      return INVALID;
    }
    let ctx = void 0;
    const status = new ParseStatus();
    for (const check of this._def.checks) {
      if (check.kind === "int") {
        if (!util.isInteger(input2.data)) {
          ctx = this._getOrReturnCtx(input2, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_type,
            expected: "integer",
            received: "float",
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "min") {
        const tooSmall = check.inclusive ? input2.data < check.value : input2.data <= check.value;
        if (tooSmall) {
          ctx = this._getOrReturnCtx(input2, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_small,
            minimum: check.value,
            type: "number",
            inclusive: check.inclusive,
            exact: false,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "max") {
        const tooBig = check.inclusive ? input2.data > check.value : input2.data >= check.value;
        if (tooBig) {
          ctx = this._getOrReturnCtx(input2, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_big,
            maximum: check.value,
            type: "number",
            inclusive: check.inclusive,
            exact: false,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "multipleOf") {
        if (floatSafeRemainder(input2.data, check.value) !== 0) {
          ctx = this._getOrReturnCtx(input2, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.not_multiple_of,
            multipleOf: check.value,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "finite") {
        if (!Number.isFinite(input2.data)) {
          ctx = this._getOrReturnCtx(input2, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.not_finite,
            message: check.message
          });
          status.dirty();
        }
      } else {
        util.assertNever(check);
      }
    }
    return { status: status.value, value: input2.data };
  }
  gte(value, message) {
    return this.setLimit("min", value, true, errorUtil.toString(message));
  }
  gt(value, message) {
    return this.setLimit("min", value, false, errorUtil.toString(message));
  }
  lte(value, message) {
    return this.setLimit("max", value, true, errorUtil.toString(message));
  }
  lt(value, message) {
    return this.setLimit("max", value, false, errorUtil.toString(message));
  }
  setLimit(kind, value, inclusive, message) {
    return new _ZodNumber({
      ...this._def,
      checks: [
        ...this._def.checks,
        {
          kind,
          value,
          inclusive,
          message: errorUtil.toString(message)
        }
      ]
    });
  }
  _addCheck(check) {
    return new _ZodNumber({
      ...this._def,
      checks: [...this._def.checks, check]
    });
  }
  int(message) {
    return this._addCheck({
      kind: "int",
      message: errorUtil.toString(message)
    });
  }
  positive(message) {
    return this._addCheck({
      kind: "min",
      value: 0,
      inclusive: false,
      message: errorUtil.toString(message)
    });
  }
  negative(message) {
    return this._addCheck({
      kind: "max",
      value: 0,
      inclusive: false,
      message: errorUtil.toString(message)
    });
  }
  nonpositive(message) {
    return this._addCheck({
      kind: "max",
      value: 0,
      inclusive: true,
      message: errorUtil.toString(message)
    });
  }
  nonnegative(message) {
    return this._addCheck({
      kind: "min",
      value: 0,
      inclusive: true,
      message: errorUtil.toString(message)
    });
  }
  multipleOf(value, message) {
    return this._addCheck({
      kind: "multipleOf",
      value,
      message: errorUtil.toString(message)
    });
  }
  finite(message) {
    return this._addCheck({
      kind: "finite",
      message: errorUtil.toString(message)
    });
  }
  safe(message) {
    return this._addCheck({
      kind: "min",
      inclusive: true,
      value: Number.MIN_SAFE_INTEGER,
      message: errorUtil.toString(message)
    })._addCheck({
      kind: "max",
      inclusive: true,
      value: Number.MAX_SAFE_INTEGER,
      message: errorUtil.toString(message)
    });
  }
  get minValue() {
    let min = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "min") {
        if (min === null || ch.value > min)
          min = ch.value;
      }
    }
    return min;
  }
  get maxValue() {
    let max = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "max") {
        if (max === null || ch.value < max)
          max = ch.value;
      }
    }
    return max;
  }
  get isInt() {
    return !!this._def.checks.find((ch) => ch.kind === "int" || ch.kind === "multipleOf" && util.isInteger(ch.value));
  }
  get isFinite() {
    let max = null, min = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "finite" || ch.kind === "int" || ch.kind === "multipleOf") {
        return true;
      } else if (ch.kind === "min") {
        if (min === null || ch.value > min)
          min = ch.value;
      } else if (ch.kind === "max") {
        if (max === null || ch.value < max)
          max = ch.value;
      }
    }
    return Number.isFinite(min) && Number.isFinite(max);
  }
};
ZodNumber.create = (params) => {
  return new ZodNumber({
    checks: [],
    typeName: ZodFirstPartyTypeKind.ZodNumber,
    coerce: (params === null || params === void 0 ? void 0 : params.coerce) || false,
    ...processCreateParams(params)
  });
};
var ZodBigInt = class _ZodBigInt extends ZodType {
  constructor() {
    super(...arguments);
    this.min = this.gte;
    this.max = this.lte;
  }
  _parse(input2) {
    if (this._def.coerce) {
      try {
        input2.data = BigInt(input2.data);
      } catch (_a2) {
        return this._getInvalidInput(input2);
      }
    }
    const parsedType = this._getType(input2);
    if (parsedType !== ZodParsedType.bigint) {
      return this._getInvalidInput(input2);
    }
    let ctx = void 0;
    const status = new ParseStatus();
    for (const check of this._def.checks) {
      if (check.kind === "min") {
        const tooSmall = check.inclusive ? input2.data < check.value : input2.data <= check.value;
        if (tooSmall) {
          ctx = this._getOrReturnCtx(input2, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_small,
            type: "bigint",
            minimum: check.value,
            inclusive: check.inclusive,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "max") {
        const tooBig = check.inclusive ? input2.data > check.value : input2.data >= check.value;
        if (tooBig) {
          ctx = this._getOrReturnCtx(input2, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_big,
            type: "bigint",
            maximum: check.value,
            inclusive: check.inclusive,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "multipleOf") {
        if (input2.data % check.value !== BigInt(0)) {
          ctx = this._getOrReturnCtx(input2, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.not_multiple_of,
            multipleOf: check.value,
            message: check.message
          });
          status.dirty();
        }
      } else {
        util.assertNever(check);
      }
    }
    return { status: status.value, value: input2.data };
  }
  _getInvalidInput(input2) {
    const ctx = this._getOrReturnCtx(input2);
    addIssueToContext(ctx, {
      code: ZodIssueCode.invalid_type,
      expected: ZodParsedType.bigint,
      received: ctx.parsedType
    });
    return INVALID;
  }
  gte(value, message) {
    return this.setLimit("min", value, true, errorUtil.toString(message));
  }
  gt(value, message) {
    return this.setLimit("min", value, false, errorUtil.toString(message));
  }
  lte(value, message) {
    return this.setLimit("max", value, true, errorUtil.toString(message));
  }
  lt(value, message) {
    return this.setLimit("max", value, false, errorUtil.toString(message));
  }
  setLimit(kind, value, inclusive, message) {
    return new _ZodBigInt({
      ...this._def,
      checks: [
        ...this._def.checks,
        {
          kind,
          value,
          inclusive,
          message: errorUtil.toString(message)
        }
      ]
    });
  }
  _addCheck(check) {
    return new _ZodBigInt({
      ...this._def,
      checks: [...this._def.checks, check]
    });
  }
  positive(message) {
    return this._addCheck({
      kind: "min",
      value: BigInt(0),
      inclusive: false,
      message: errorUtil.toString(message)
    });
  }
  negative(message) {
    return this._addCheck({
      kind: "max",
      value: BigInt(0),
      inclusive: false,
      message: errorUtil.toString(message)
    });
  }
  nonpositive(message) {
    return this._addCheck({
      kind: "max",
      value: BigInt(0),
      inclusive: true,
      message: errorUtil.toString(message)
    });
  }
  nonnegative(message) {
    return this._addCheck({
      kind: "min",
      value: BigInt(0),
      inclusive: true,
      message: errorUtil.toString(message)
    });
  }
  multipleOf(value, message) {
    return this._addCheck({
      kind: "multipleOf",
      value,
      message: errorUtil.toString(message)
    });
  }
  get minValue() {
    let min = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "min") {
        if (min === null || ch.value > min)
          min = ch.value;
      }
    }
    return min;
  }
  get maxValue() {
    let max = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "max") {
        if (max === null || ch.value < max)
          max = ch.value;
      }
    }
    return max;
  }
};
ZodBigInt.create = (params) => {
  var _a2;
  return new ZodBigInt({
    checks: [],
    typeName: ZodFirstPartyTypeKind.ZodBigInt,
    coerce: (_a2 = params === null || params === void 0 ? void 0 : params.coerce) !== null && _a2 !== void 0 ? _a2 : false,
    ...processCreateParams(params)
  });
};
var ZodBoolean = class extends ZodType {
  _parse(input2) {
    if (this._def.coerce) {
      input2.data = Boolean(input2.data);
    }
    const parsedType = this._getType(input2);
    if (parsedType !== ZodParsedType.boolean) {
      const ctx = this._getOrReturnCtx(input2);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.boolean,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return OK(input2.data);
  }
};
ZodBoolean.create = (params) => {
  return new ZodBoolean({
    typeName: ZodFirstPartyTypeKind.ZodBoolean,
    coerce: (params === null || params === void 0 ? void 0 : params.coerce) || false,
    ...processCreateParams(params)
  });
};
var ZodDate = class _ZodDate extends ZodType {
  _parse(input2) {
    if (this._def.coerce) {
      input2.data = new Date(input2.data);
    }
    const parsedType = this._getType(input2);
    if (parsedType !== ZodParsedType.date) {
      const ctx2 = this._getOrReturnCtx(input2);
      addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.date,
        received: ctx2.parsedType
      });
      return INVALID;
    }
    if (isNaN(input2.data.getTime())) {
      const ctx2 = this._getOrReturnCtx(input2);
      addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_date
      });
      return INVALID;
    }
    const status = new ParseStatus();
    let ctx = void 0;
    for (const check of this._def.checks) {
      if (check.kind === "min") {
        if (input2.data.getTime() < check.value) {
          ctx = this._getOrReturnCtx(input2, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_small,
            message: check.message,
            inclusive: true,
            exact: false,
            minimum: check.value,
            type: "date"
          });
          status.dirty();
        }
      } else if (check.kind === "max") {
        if (input2.data.getTime() > check.value) {
          ctx = this._getOrReturnCtx(input2, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_big,
            message: check.message,
            inclusive: true,
            exact: false,
            maximum: check.value,
            type: "date"
          });
          status.dirty();
        }
      } else {
        util.assertNever(check);
      }
    }
    return {
      status: status.value,
      value: new Date(input2.data.getTime())
    };
  }
  _addCheck(check) {
    return new _ZodDate({
      ...this._def,
      checks: [...this._def.checks, check]
    });
  }
  min(minDate, message) {
    return this._addCheck({
      kind: "min",
      value: minDate.getTime(),
      message: errorUtil.toString(message)
    });
  }
  max(maxDate, message) {
    return this._addCheck({
      kind: "max",
      value: maxDate.getTime(),
      message: errorUtil.toString(message)
    });
  }
  get minDate() {
    let min = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "min") {
        if (min === null || ch.value > min)
          min = ch.value;
      }
    }
    return min != null ? new Date(min) : null;
  }
  get maxDate() {
    let max = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "max") {
        if (max === null || ch.value < max)
          max = ch.value;
      }
    }
    return max != null ? new Date(max) : null;
  }
};
ZodDate.create = (params) => {
  return new ZodDate({
    checks: [],
    coerce: (params === null || params === void 0 ? void 0 : params.coerce) || false,
    typeName: ZodFirstPartyTypeKind.ZodDate,
    ...processCreateParams(params)
  });
};
var ZodSymbol = class extends ZodType {
  _parse(input2) {
    const parsedType = this._getType(input2);
    if (parsedType !== ZodParsedType.symbol) {
      const ctx = this._getOrReturnCtx(input2);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.symbol,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return OK(input2.data);
  }
};
ZodSymbol.create = (params) => {
  return new ZodSymbol({
    typeName: ZodFirstPartyTypeKind.ZodSymbol,
    ...processCreateParams(params)
  });
};
var ZodUndefined = class extends ZodType {
  _parse(input2) {
    const parsedType = this._getType(input2);
    if (parsedType !== ZodParsedType.undefined) {
      const ctx = this._getOrReturnCtx(input2);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.undefined,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return OK(input2.data);
  }
};
ZodUndefined.create = (params) => {
  return new ZodUndefined({
    typeName: ZodFirstPartyTypeKind.ZodUndefined,
    ...processCreateParams(params)
  });
};
var ZodNull = class extends ZodType {
  _parse(input2) {
    const parsedType = this._getType(input2);
    if (parsedType !== ZodParsedType.null) {
      const ctx = this._getOrReturnCtx(input2);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.null,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return OK(input2.data);
  }
};
ZodNull.create = (params) => {
  return new ZodNull({
    typeName: ZodFirstPartyTypeKind.ZodNull,
    ...processCreateParams(params)
  });
};
var ZodAny = class extends ZodType {
  constructor() {
    super(...arguments);
    this._any = true;
  }
  _parse(input2) {
    return OK(input2.data);
  }
};
ZodAny.create = (params) => {
  return new ZodAny({
    typeName: ZodFirstPartyTypeKind.ZodAny,
    ...processCreateParams(params)
  });
};
var ZodUnknown = class extends ZodType {
  constructor() {
    super(...arguments);
    this._unknown = true;
  }
  _parse(input2) {
    return OK(input2.data);
  }
};
ZodUnknown.create = (params) => {
  return new ZodUnknown({
    typeName: ZodFirstPartyTypeKind.ZodUnknown,
    ...processCreateParams(params)
  });
};
var ZodNever = class extends ZodType {
  _parse(input2) {
    const ctx = this._getOrReturnCtx(input2);
    addIssueToContext(ctx, {
      code: ZodIssueCode.invalid_type,
      expected: ZodParsedType.never,
      received: ctx.parsedType
    });
    return INVALID;
  }
};
ZodNever.create = (params) => {
  return new ZodNever({
    typeName: ZodFirstPartyTypeKind.ZodNever,
    ...processCreateParams(params)
  });
};
var ZodVoid = class extends ZodType {
  _parse(input2) {
    const parsedType = this._getType(input2);
    if (parsedType !== ZodParsedType.undefined) {
      const ctx = this._getOrReturnCtx(input2);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.void,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return OK(input2.data);
  }
};
ZodVoid.create = (params) => {
  return new ZodVoid({
    typeName: ZodFirstPartyTypeKind.ZodVoid,
    ...processCreateParams(params)
  });
};
var ZodArray = class _ZodArray extends ZodType {
  _parse(input2) {
    const { ctx, status } = this._processInputParams(input2);
    const def = this._def;
    if (ctx.parsedType !== ZodParsedType.array) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.array,
        received: ctx.parsedType
      });
      return INVALID;
    }
    if (def.exactLength !== null) {
      const tooBig = ctx.data.length > def.exactLength.value;
      const tooSmall = ctx.data.length < def.exactLength.value;
      if (tooBig || tooSmall) {
        addIssueToContext(ctx, {
          code: tooBig ? ZodIssueCode.too_big : ZodIssueCode.too_small,
          minimum: tooSmall ? def.exactLength.value : void 0,
          maximum: tooBig ? def.exactLength.value : void 0,
          type: "array",
          inclusive: true,
          exact: true,
          message: def.exactLength.message
        });
        status.dirty();
      }
    }
    if (def.minLength !== null) {
      if (ctx.data.length < def.minLength.value) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.too_small,
          minimum: def.minLength.value,
          type: "array",
          inclusive: true,
          exact: false,
          message: def.minLength.message
        });
        status.dirty();
      }
    }
    if (def.maxLength !== null) {
      if (ctx.data.length > def.maxLength.value) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.too_big,
          maximum: def.maxLength.value,
          type: "array",
          inclusive: true,
          exact: false,
          message: def.maxLength.message
        });
        status.dirty();
      }
    }
    if (ctx.common.async) {
      return Promise.all([...ctx.data].map((item, i) => {
        return def.type._parseAsync(new ParseInputLazyPath(ctx, item, ctx.path, i));
      })).then((result2) => {
        return ParseStatus.mergeArray(status, result2);
      });
    }
    const result = [...ctx.data].map((item, i) => {
      return def.type._parseSync(new ParseInputLazyPath(ctx, item, ctx.path, i));
    });
    return ParseStatus.mergeArray(status, result);
  }
  get element() {
    return this._def.type;
  }
  min(minLength, message) {
    return new _ZodArray({
      ...this._def,
      minLength: { value: minLength, message: errorUtil.toString(message) }
    });
  }
  max(maxLength, message) {
    return new _ZodArray({
      ...this._def,
      maxLength: { value: maxLength, message: errorUtil.toString(message) }
    });
  }
  length(len, message) {
    return new _ZodArray({
      ...this._def,
      exactLength: { value: len, message: errorUtil.toString(message) }
    });
  }
  nonempty(message) {
    return this.min(1, message);
  }
};
ZodArray.create = (schema, params) => {
  return new ZodArray({
    type: schema,
    minLength: null,
    maxLength: null,
    exactLength: null,
    typeName: ZodFirstPartyTypeKind.ZodArray,
    ...processCreateParams(params)
  });
};
function deepPartialify(schema) {
  if (schema instanceof ZodObject) {
    const newShape = {};
    for (const key in schema.shape) {
      const fieldSchema = schema.shape[key];
      newShape[key] = ZodOptional.create(deepPartialify(fieldSchema));
    }
    return new ZodObject({
      ...schema._def,
      shape: () => newShape
    });
  } else if (schema instanceof ZodArray) {
    return new ZodArray({
      ...schema._def,
      type: deepPartialify(schema.element)
    });
  } else if (schema instanceof ZodOptional) {
    return ZodOptional.create(deepPartialify(schema.unwrap()));
  } else if (schema instanceof ZodNullable) {
    return ZodNullable.create(deepPartialify(schema.unwrap()));
  } else if (schema instanceof ZodTuple) {
    return ZodTuple.create(schema.items.map((item) => deepPartialify(item)));
  } else {
    return schema;
  }
}
var ZodObject = class _ZodObject extends ZodType {
  constructor() {
    super(...arguments);
    this._cached = null;
    this.nonstrict = this.passthrough;
    this.augment = this.extend;
  }
  _getCached() {
    if (this._cached !== null)
      return this._cached;
    const shape = this._def.shape();
    const keys = util.objectKeys(shape);
    return this._cached = { shape, keys };
  }
  _parse(input2) {
    const parsedType = this._getType(input2);
    if (parsedType !== ZodParsedType.object) {
      const ctx2 = this._getOrReturnCtx(input2);
      addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.object,
        received: ctx2.parsedType
      });
      return INVALID;
    }
    const { status, ctx } = this._processInputParams(input2);
    const { shape, keys: shapeKeys } = this._getCached();
    const extraKeys = [];
    if (!(this._def.catchall instanceof ZodNever && this._def.unknownKeys === "strip")) {
      for (const key in ctx.data) {
        if (!shapeKeys.includes(key)) {
          extraKeys.push(key);
        }
      }
    }
    const pairs = [];
    for (const key of shapeKeys) {
      const keyValidator = shape[key];
      const value = ctx.data[key];
      pairs.push({
        key: { status: "valid", value: key },
        value: keyValidator._parse(new ParseInputLazyPath(ctx, value, ctx.path, key)),
        alwaysSet: key in ctx.data
      });
    }
    if (this._def.catchall instanceof ZodNever) {
      const unknownKeys = this._def.unknownKeys;
      if (unknownKeys === "passthrough") {
        for (const key of extraKeys) {
          pairs.push({
            key: { status: "valid", value: key },
            value: { status: "valid", value: ctx.data[key] }
          });
        }
      } else if (unknownKeys === "strict") {
        if (extraKeys.length > 0) {
          addIssueToContext(ctx, {
            code: ZodIssueCode.unrecognized_keys,
            keys: extraKeys
          });
          status.dirty();
        }
      } else if (unknownKeys === "strip") ;
      else {
        throw new Error(`Internal ZodObject error: invalid unknownKeys value.`);
      }
    } else {
      const catchall = this._def.catchall;
      for (const key of extraKeys) {
        const value = ctx.data[key];
        pairs.push({
          key: { status: "valid", value: key },
          value: catchall._parse(
            new ParseInputLazyPath(ctx, value, ctx.path, key)
            //, ctx.child(key), value, getParsedType(value)
          ),
          alwaysSet: key in ctx.data
        });
      }
    }
    if (ctx.common.async) {
      return Promise.resolve().then(async () => {
        const syncPairs = [];
        for (const pair of pairs) {
          const key = await pair.key;
          const value = await pair.value;
          syncPairs.push({
            key,
            value,
            alwaysSet: pair.alwaysSet
          });
        }
        return syncPairs;
      }).then((syncPairs) => {
        return ParseStatus.mergeObjectSync(status, syncPairs);
      });
    } else {
      return ParseStatus.mergeObjectSync(status, pairs);
    }
  }
  get shape() {
    return this._def.shape();
  }
  strict(message) {
    errorUtil.errToObj;
    return new _ZodObject({
      ...this._def,
      unknownKeys: "strict",
      ...message !== void 0 ? {
        errorMap: (issue, ctx) => {
          var _a2, _b, _c, _d;
          const defaultError = (_c = (_b = (_a2 = this._def).errorMap) === null || _b === void 0 ? void 0 : _b.call(_a2, issue, ctx).message) !== null && _c !== void 0 ? _c : ctx.defaultError;
          if (issue.code === "unrecognized_keys")
            return {
              message: (_d = errorUtil.errToObj(message).message) !== null && _d !== void 0 ? _d : defaultError
            };
          return {
            message: defaultError
          };
        }
      } : {}
    });
  }
  strip() {
    return new _ZodObject({
      ...this._def,
      unknownKeys: "strip"
    });
  }
  passthrough() {
    return new _ZodObject({
      ...this._def,
      unknownKeys: "passthrough"
    });
  }
  // const AugmentFactory =
  //   <Def extends ZodObjectDef>(def: Def) =>
  //   <Augmentation extends ZodRawShape>(
  //     augmentation: Augmentation
  //   ): ZodObject<
  //     extendShape<ReturnType<Def["shape"]>, Augmentation>,
  //     Def["unknownKeys"],
  //     Def["catchall"]
  //   > => {
  //     return new ZodObject({
  //       ...def,
  //       shape: () => ({
  //         ...def.shape(),
  //         ...augmentation,
  //       }),
  //     }) as any;
  //   };
  extend(augmentation) {
    return new _ZodObject({
      ...this._def,
      shape: () => ({
        ...this._def.shape(),
        ...augmentation
      })
    });
  }
  /**
   * Prior to zod@1.0.12 there was a bug in the
   * inferred type of merged objects. Please
   * upgrade if you are experiencing issues.
   */
  merge(merging) {
    const merged = new _ZodObject({
      unknownKeys: merging._def.unknownKeys,
      catchall: merging._def.catchall,
      shape: () => ({
        ...this._def.shape(),
        ...merging._def.shape()
      }),
      typeName: ZodFirstPartyTypeKind.ZodObject
    });
    return merged;
  }
  // merge<
  //   Incoming extends AnyZodObject,
  //   Augmentation extends Incoming["shape"],
  //   NewOutput extends {
  //     [k in keyof Augmentation | keyof Output]: k extends keyof Augmentation
  //       ? Augmentation[k]["_output"]
  //       : k extends keyof Output
  //       ? Output[k]
  //       : never;
  //   },
  //   NewInput extends {
  //     [k in keyof Augmentation | keyof Input]: k extends keyof Augmentation
  //       ? Augmentation[k]["_input"]
  //       : k extends keyof Input
  //       ? Input[k]
  //       : never;
  //   }
  // >(
  //   merging: Incoming
  // ): ZodObject<
  //   extendShape<T, ReturnType<Incoming["_def"]["shape"]>>,
  //   Incoming["_def"]["unknownKeys"],
  //   Incoming["_def"]["catchall"],
  //   NewOutput,
  //   NewInput
  // > {
  //   const merged: any = new ZodObject({
  //     unknownKeys: merging._def.unknownKeys,
  //     catchall: merging._def.catchall,
  //     shape: () =>
  //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),
  //     typeName: ZodFirstPartyTypeKind.ZodObject,
  //   }) as any;
  //   return merged;
  // }
  setKey(key, schema) {
    return this.augment({ [key]: schema });
  }
  // merge<Incoming extends AnyZodObject>(
  //   merging: Incoming
  // ): //ZodObject<T & Incoming["_shape"], UnknownKeys, Catchall> = (merging) => {
  // ZodObject<
  //   extendShape<T, ReturnType<Incoming["_def"]["shape"]>>,
  //   Incoming["_def"]["unknownKeys"],
  //   Incoming["_def"]["catchall"]
  // > {
  //   // const mergedShape = objectUtil.mergeShapes(
  //   //   this._def.shape(),
  //   //   merging._def.shape()
  //   // );
  //   const merged: any = new ZodObject({
  //     unknownKeys: merging._def.unknownKeys,
  //     catchall: merging._def.catchall,
  //     shape: () =>
  //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),
  //     typeName: ZodFirstPartyTypeKind.ZodObject,
  //   }) as any;
  //   return merged;
  // }
  catchall(index3) {
    return new _ZodObject({
      ...this._def,
      catchall: index3
    });
  }
  pick(mask) {
    const shape = {};
    util.objectKeys(mask).forEach((key) => {
      if (mask[key] && this.shape[key]) {
        shape[key] = this.shape[key];
      }
    });
    return new _ZodObject({
      ...this._def,
      shape: () => shape
    });
  }
  omit(mask) {
    const shape = {};
    util.objectKeys(this.shape).forEach((key) => {
      if (!mask[key]) {
        shape[key] = this.shape[key];
      }
    });
    return new _ZodObject({
      ...this._def,
      shape: () => shape
    });
  }
  /**
   * @deprecated
   */
  deepPartial() {
    return deepPartialify(this);
  }
  partial(mask) {
    const newShape = {};
    util.objectKeys(this.shape).forEach((key) => {
      const fieldSchema = this.shape[key];
      if (mask && !mask[key]) {
        newShape[key] = fieldSchema;
      } else {
        newShape[key] = fieldSchema.optional();
      }
    });
    return new _ZodObject({
      ...this._def,
      shape: () => newShape
    });
  }
  required(mask) {
    const newShape = {};
    util.objectKeys(this.shape).forEach((key) => {
      if (mask && !mask[key]) {
        newShape[key] = this.shape[key];
      } else {
        const fieldSchema = this.shape[key];
        let newField = fieldSchema;
        while (newField instanceof ZodOptional) {
          newField = newField._def.innerType;
        }
        newShape[key] = newField;
      }
    });
    return new _ZodObject({
      ...this._def,
      shape: () => newShape
    });
  }
  keyof() {
    return createZodEnum(util.objectKeys(this.shape));
  }
};
ZodObject.create = (shape, params) => {
  return new ZodObject({
    shape: () => shape,
    unknownKeys: "strip",
    catchall: ZodNever.create(),
    typeName: ZodFirstPartyTypeKind.ZodObject,
    ...processCreateParams(params)
  });
};
ZodObject.strictCreate = (shape, params) => {
  return new ZodObject({
    shape: () => shape,
    unknownKeys: "strict",
    catchall: ZodNever.create(),
    typeName: ZodFirstPartyTypeKind.ZodObject,
    ...processCreateParams(params)
  });
};
ZodObject.lazycreate = (shape, params) => {
  return new ZodObject({
    shape,
    unknownKeys: "strip",
    catchall: ZodNever.create(),
    typeName: ZodFirstPartyTypeKind.ZodObject,
    ...processCreateParams(params)
  });
};
var ZodUnion = class extends ZodType {
  _parse(input2) {
    const { ctx } = this._processInputParams(input2);
    const options = this._def.options;
    function handleResults(results) {
      for (const result of results) {
        if (result.result.status === "valid") {
          return result.result;
        }
      }
      for (const result of results) {
        if (result.result.status === "dirty") {
          ctx.common.issues.push(...result.ctx.common.issues);
          return result.result;
        }
      }
      const unionErrors = results.map((result) => new ZodError(result.ctx.common.issues));
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_union,
        unionErrors
      });
      return INVALID;
    }
    if (ctx.common.async) {
      return Promise.all(options.map(async (option) => {
        const childCtx = {
          ...ctx,
          common: {
            ...ctx.common,
            issues: []
          },
          parent: null
        };
        return {
          result: await option._parseAsync({
            data: ctx.data,
            path: ctx.path,
            parent: childCtx
          }),
          ctx: childCtx
        };
      })).then(handleResults);
    } else {
      let dirty = void 0;
      const issues = [];
      for (const option of options) {
        const childCtx = {
          ...ctx,
          common: {
            ...ctx.common,
            issues: []
          },
          parent: null
        };
        const result = option._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: childCtx
        });
        if (result.status === "valid") {
          return result;
        } else if (result.status === "dirty" && !dirty) {
          dirty = { result, ctx: childCtx };
        }
        if (childCtx.common.issues.length) {
          issues.push(childCtx.common.issues);
        }
      }
      if (dirty) {
        ctx.common.issues.push(...dirty.ctx.common.issues);
        return dirty.result;
      }
      const unionErrors = issues.map((issues2) => new ZodError(issues2));
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_union,
        unionErrors
      });
      return INVALID;
    }
  }
  get options() {
    return this._def.options;
  }
};
ZodUnion.create = (types, params) => {
  return new ZodUnion({
    options: types,
    typeName: ZodFirstPartyTypeKind.ZodUnion,
    ...processCreateParams(params)
  });
};
var getDiscriminator = (type) => {
  if (type instanceof ZodLazy) {
    return getDiscriminator(type.schema);
  } else if (type instanceof ZodEffects) {
    return getDiscriminator(type.innerType());
  } else if (type instanceof ZodLiteral) {
    return [type.value];
  } else if (type instanceof ZodEnum) {
    return type.options;
  } else if (type instanceof ZodNativeEnum) {
    return util.objectValues(type.enum);
  } else if (type instanceof ZodDefault) {
    return getDiscriminator(type._def.innerType);
  } else if (type instanceof ZodUndefined) {
    return [void 0];
  } else if (type instanceof ZodNull) {
    return [null];
  } else if (type instanceof ZodOptional) {
    return [void 0, ...getDiscriminator(type.unwrap())];
  } else if (type instanceof ZodNullable) {
    return [null, ...getDiscriminator(type.unwrap())];
  } else if (type instanceof ZodBranded) {
    return getDiscriminator(type.unwrap());
  } else if (type instanceof ZodReadonly) {
    return getDiscriminator(type.unwrap());
  } else if (type instanceof ZodCatch) {
    return getDiscriminator(type._def.innerType);
  } else {
    return [];
  }
};
var ZodDiscriminatedUnion = class _ZodDiscriminatedUnion extends ZodType {
  _parse(input2) {
    const { ctx } = this._processInputParams(input2);
    if (ctx.parsedType !== ZodParsedType.object) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.object,
        received: ctx.parsedType
      });
      return INVALID;
    }
    const discriminator = this.discriminator;
    const discriminatorValue = ctx.data[discriminator];
    const option = this.optionsMap.get(discriminatorValue);
    if (!option) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_union_discriminator,
        options: Array.from(this.optionsMap.keys()),
        path: [discriminator]
      });
      return INVALID;
    }
    if (ctx.common.async) {
      return option._parseAsync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      });
    } else {
      return option._parseSync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      });
    }
  }
  get discriminator() {
    return this._def.discriminator;
  }
  get options() {
    return this._def.options;
  }
  get optionsMap() {
    return this._def.optionsMap;
  }
  /**
   * The constructor of the discriminated union schema. Its behaviour is very similar to that of the normal z.union() constructor.
   * However, it only allows a union of objects, all of which need to share a discriminator property. This property must
   * have a different value for each object in the union.
   * @param discriminator the name of the discriminator property
   * @param types an array of object schemas
   * @param params
   */
  static create(discriminator, options, params) {
    const optionsMap = /* @__PURE__ */ new Map();
    for (const type of options) {
      const discriminatorValues = getDiscriminator(type.shape[discriminator]);
      if (!discriminatorValues.length) {
        throw new Error(`A discriminator value for key \`${discriminator}\` could not be extracted from all schema options`);
      }
      for (const value of discriminatorValues) {
        if (optionsMap.has(value)) {
          throw new Error(`Discriminator property ${String(discriminator)} has duplicate value ${String(value)}`);
        }
        optionsMap.set(value, type);
      }
    }
    return new _ZodDiscriminatedUnion({
      typeName: ZodFirstPartyTypeKind.ZodDiscriminatedUnion,
      discriminator,
      options,
      optionsMap,
      ...processCreateParams(params)
    });
  }
};
function mergeValues(a, b) {
  const aType = getParsedType(a);
  const bType = getParsedType(b);
  if (a === b) {
    return { valid: true, data: a };
  } else if (aType === ZodParsedType.object && bType === ZodParsedType.object) {
    const bKeys = util.objectKeys(b);
    const sharedKeys = util.objectKeys(a).filter((key) => bKeys.indexOf(key) !== -1);
    const newObj = { ...a, ...b };
    for (const key of sharedKeys) {
      const sharedValue = mergeValues(a[key], b[key]);
      if (!sharedValue.valid) {
        return { valid: false };
      }
      newObj[key] = sharedValue.data;
    }
    return { valid: true, data: newObj };
  } else if (aType === ZodParsedType.array && bType === ZodParsedType.array) {
    if (a.length !== b.length) {
      return { valid: false };
    }
    const newArray = [];
    for (let index3 = 0; index3 < a.length; index3++) {
      const itemA = a[index3];
      const itemB = b[index3];
      const sharedValue = mergeValues(itemA, itemB);
      if (!sharedValue.valid) {
        return { valid: false };
      }
      newArray.push(sharedValue.data);
    }
    return { valid: true, data: newArray };
  } else if (aType === ZodParsedType.date && bType === ZodParsedType.date && +a === +b) {
    return { valid: true, data: a };
  } else {
    return { valid: false };
  }
}
var ZodIntersection = class extends ZodType {
  _parse(input2) {
    const { status, ctx } = this._processInputParams(input2);
    const handleParsed = (parsedLeft, parsedRight) => {
      if (isAborted(parsedLeft) || isAborted(parsedRight)) {
        return INVALID;
      }
      const merged = mergeValues(parsedLeft.value, parsedRight.value);
      if (!merged.valid) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_intersection_types
        });
        return INVALID;
      }
      if (isDirty(parsedLeft) || isDirty(parsedRight)) {
        status.dirty();
      }
      return { status: status.value, value: merged.data };
    };
    if (ctx.common.async) {
      return Promise.all([
        this._def.left._parseAsync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        }),
        this._def.right._parseAsync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        })
      ]).then(([left, right]) => handleParsed(left, right));
    } else {
      return handleParsed(this._def.left._parseSync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      }), this._def.right._parseSync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      }));
    }
  }
};
ZodIntersection.create = (left, right, params) => {
  return new ZodIntersection({
    left,
    right,
    typeName: ZodFirstPartyTypeKind.ZodIntersection,
    ...processCreateParams(params)
  });
};
var ZodTuple = class _ZodTuple extends ZodType {
  _parse(input2) {
    const { status, ctx } = this._processInputParams(input2);
    if (ctx.parsedType !== ZodParsedType.array) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.array,
        received: ctx.parsedType
      });
      return INVALID;
    }
    if (ctx.data.length < this._def.items.length) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.too_small,
        minimum: this._def.items.length,
        inclusive: true,
        exact: false,
        type: "array"
      });
      return INVALID;
    }
    const rest = this._def.rest;
    if (!rest && ctx.data.length > this._def.items.length) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.too_big,
        maximum: this._def.items.length,
        inclusive: true,
        exact: false,
        type: "array"
      });
      status.dirty();
    }
    const items = [...ctx.data].map((item, itemIndex) => {
      const schema = this._def.items[itemIndex] || this._def.rest;
      if (!schema)
        return null;
      return schema._parse(new ParseInputLazyPath(ctx, item, ctx.path, itemIndex));
    }).filter((x) => !!x);
    if (ctx.common.async) {
      return Promise.all(items).then((results) => {
        return ParseStatus.mergeArray(status, results);
      });
    } else {
      return ParseStatus.mergeArray(status, items);
    }
  }
  get items() {
    return this._def.items;
  }
  rest(rest) {
    return new _ZodTuple({
      ...this._def,
      rest
    });
  }
};
ZodTuple.create = (schemas, params) => {
  if (!Array.isArray(schemas)) {
    throw new Error("You must pass an array of schemas to z.tuple([ ... ])");
  }
  return new ZodTuple({
    items: schemas,
    typeName: ZodFirstPartyTypeKind.ZodTuple,
    rest: null,
    ...processCreateParams(params)
  });
};
var ZodRecord = class _ZodRecord extends ZodType {
  get keySchema() {
    return this._def.keyType;
  }
  get valueSchema() {
    return this._def.valueType;
  }
  _parse(input2) {
    const { status, ctx } = this._processInputParams(input2);
    if (ctx.parsedType !== ZodParsedType.object) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.object,
        received: ctx.parsedType
      });
      return INVALID;
    }
    const pairs = [];
    const keyType = this._def.keyType;
    const valueType = this._def.valueType;
    for (const key in ctx.data) {
      pairs.push({
        key: keyType._parse(new ParseInputLazyPath(ctx, key, ctx.path, key)),
        value: valueType._parse(new ParseInputLazyPath(ctx, ctx.data[key], ctx.path, key)),
        alwaysSet: key in ctx.data
      });
    }
    if (ctx.common.async) {
      return ParseStatus.mergeObjectAsync(status, pairs);
    } else {
      return ParseStatus.mergeObjectSync(status, pairs);
    }
  }
  get element() {
    return this._def.valueType;
  }
  static create(first, second, third) {
    if (second instanceof ZodType) {
      return new _ZodRecord({
        keyType: first,
        valueType: second,
        typeName: ZodFirstPartyTypeKind.ZodRecord,
        ...processCreateParams(third)
      });
    }
    return new _ZodRecord({
      keyType: ZodString.create(),
      valueType: first,
      typeName: ZodFirstPartyTypeKind.ZodRecord,
      ...processCreateParams(second)
    });
  }
};
var ZodMap = class extends ZodType {
  get keySchema() {
    return this._def.keyType;
  }
  get valueSchema() {
    return this._def.valueType;
  }
  _parse(input2) {
    const { status, ctx } = this._processInputParams(input2);
    if (ctx.parsedType !== ZodParsedType.map) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.map,
        received: ctx.parsedType
      });
      return INVALID;
    }
    const keyType = this._def.keyType;
    const valueType = this._def.valueType;
    const pairs = [...ctx.data.entries()].map(([key, value], index3) => {
      return {
        key: keyType._parse(new ParseInputLazyPath(ctx, key, ctx.path, [index3, "key"])),
        value: valueType._parse(new ParseInputLazyPath(ctx, value, ctx.path, [index3, "value"]))
      };
    });
    if (ctx.common.async) {
      const finalMap = /* @__PURE__ */ new Map();
      return Promise.resolve().then(async () => {
        for (const pair of pairs) {
          const key = await pair.key;
          const value = await pair.value;
          if (key.status === "aborted" || value.status === "aborted") {
            return INVALID;
          }
          if (key.status === "dirty" || value.status === "dirty") {
            status.dirty();
          }
          finalMap.set(key.value, value.value);
        }
        return { status: status.value, value: finalMap };
      });
    } else {
      const finalMap = /* @__PURE__ */ new Map();
      for (const pair of pairs) {
        const key = pair.key;
        const value = pair.value;
        if (key.status === "aborted" || value.status === "aborted") {
          return INVALID;
        }
        if (key.status === "dirty" || value.status === "dirty") {
          status.dirty();
        }
        finalMap.set(key.value, value.value);
      }
      return { status: status.value, value: finalMap };
    }
  }
};
ZodMap.create = (keyType, valueType, params) => {
  return new ZodMap({
    valueType,
    keyType,
    typeName: ZodFirstPartyTypeKind.ZodMap,
    ...processCreateParams(params)
  });
};
var ZodSet = class _ZodSet extends ZodType {
  _parse(input2) {
    const { status, ctx } = this._processInputParams(input2);
    if (ctx.parsedType !== ZodParsedType.set) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.set,
        received: ctx.parsedType
      });
      return INVALID;
    }
    const def = this._def;
    if (def.minSize !== null) {
      if (ctx.data.size < def.minSize.value) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.too_small,
          minimum: def.minSize.value,
          type: "set",
          inclusive: true,
          exact: false,
          message: def.minSize.message
        });
        status.dirty();
      }
    }
    if (def.maxSize !== null) {
      if (ctx.data.size > def.maxSize.value) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.too_big,
          maximum: def.maxSize.value,
          type: "set",
          inclusive: true,
          exact: false,
          message: def.maxSize.message
        });
        status.dirty();
      }
    }
    const valueType = this._def.valueType;
    function finalizeSet(elements2) {
      const parsedSet = /* @__PURE__ */ new Set();
      for (const element of elements2) {
        if (element.status === "aborted")
          return INVALID;
        if (element.status === "dirty")
          status.dirty();
        parsedSet.add(element.value);
      }
      return { status: status.value, value: parsedSet };
    }
    const elements = [...ctx.data.values()].map((item, i) => valueType._parse(new ParseInputLazyPath(ctx, item, ctx.path, i)));
    if (ctx.common.async) {
      return Promise.all(elements).then((elements2) => finalizeSet(elements2));
    } else {
      return finalizeSet(elements);
    }
  }
  min(minSize, message) {
    return new _ZodSet({
      ...this._def,
      minSize: { value: minSize, message: errorUtil.toString(message) }
    });
  }
  max(maxSize, message) {
    return new _ZodSet({
      ...this._def,
      maxSize: { value: maxSize, message: errorUtil.toString(message) }
    });
  }
  size(size, message) {
    return this.min(size, message).max(size, message);
  }
  nonempty(message) {
    return this.min(1, message);
  }
};
ZodSet.create = (valueType, params) => {
  return new ZodSet({
    valueType,
    minSize: null,
    maxSize: null,
    typeName: ZodFirstPartyTypeKind.ZodSet,
    ...processCreateParams(params)
  });
};
var ZodFunction = class _ZodFunction extends ZodType {
  constructor() {
    super(...arguments);
    this.validate = this.implement;
  }
  _parse(input2) {
    const { ctx } = this._processInputParams(input2);
    if (ctx.parsedType !== ZodParsedType.function) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.function,
        received: ctx.parsedType
      });
      return INVALID;
    }
    function makeArgsIssue(args, error) {
      return makeIssue({
        data: args,
        path: ctx.path,
        errorMaps: [
          ctx.common.contextualErrorMap,
          ctx.schemaErrorMap,
          getErrorMap(),
          errorMap
        ].filter((x) => !!x),
        issueData: {
          code: ZodIssueCode.invalid_arguments,
          argumentsError: error
        }
      });
    }
    function makeReturnsIssue(returns, error) {
      return makeIssue({
        data: returns,
        path: ctx.path,
        errorMaps: [
          ctx.common.contextualErrorMap,
          ctx.schemaErrorMap,
          getErrorMap(),
          errorMap
        ].filter((x) => !!x),
        issueData: {
          code: ZodIssueCode.invalid_return_type,
          returnTypeError: error
        }
      });
    }
    const params = { errorMap: ctx.common.contextualErrorMap };
    const fn = ctx.data;
    if (this._def.returns instanceof ZodPromise) {
      const me = this;
      return OK(async function(...args) {
        const error = new ZodError([]);
        const parsedArgs = await me._def.args.parseAsync(args, params).catch((e) => {
          error.addIssue(makeArgsIssue(args, e));
          throw error;
        });
        const result = await Reflect.apply(fn, this, parsedArgs);
        const parsedReturns = await me._def.returns._def.type.parseAsync(result, params).catch((e) => {
          error.addIssue(makeReturnsIssue(result, e));
          throw error;
        });
        return parsedReturns;
      });
    } else {
      const me = this;
      return OK(function(...args) {
        const parsedArgs = me._def.args.safeParse(args, params);
        if (!parsedArgs.success) {
          throw new ZodError([makeArgsIssue(args, parsedArgs.error)]);
        }
        const result = Reflect.apply(fn, this, parsedArgs.data);
        const parsedReturns = me._def.returns.safeParse(result, params);
        if (!parsedReturns.success) {
          throw new ZodError([makeReturnsIssue(result, parsedReturns.error)]);
        }
        return parsedReturns.data;
      });
    }
  }
  parameters() {
    return this._def.args;
  }
  returnType() {
    return this._def.returns;
  }
  args(...items) {
    return new _ZodFunction({
      ...this._def,
      args: ZodTuple.create(items).rest(ZodUnknown.create())
    });
  }
  returns(returnType) {
    return new _ZodFunction({
      ...this._def,
      returns: returnType
    });
  }
  implement(func) {
    const validatedFunc = this.parse(func);
    return validatedFunc;
  }
  strictImplement(func) {
    const validatedFunc = this.parse(func);
    return validatedFunc;
  }
  static create(args, returns, params) {
    return new _ZodFunction({
      args: args ? args : ZodTuple.create([]).rest(ZodUnknown.create()),
      returns: returns || ZodUnknown.create(),
      typeName: ZodFirstPartyTypeKind.ZodFunction,
      ...processCreateParams(params)
    });
  }
};
var ZodLazy = class extends ZodType {
  get schema() {
    return this._def.getter();
  }
  _parse(input2) {
    const { ctx } = this._processInputParams(input2);
    const lazySchema = this._def.getter();
    return lazySchema._parse({ data: ctx.data, path: ctx.path, parent: ctx });
  }
};
ZodLazy.create = (getter, params) => {
  return new ZodLazy({
    getter,
    typeName: ZodFirstPartyTypeKind.ZodLazy,
    ...processCreateParams(params)
  });
};
var ZodLiteral = class extends ZodType {
  _parse(input2) {
    if (input2.data !== this._def.value) {
      const ctx = this._getOrReturnCtx(input2);
      addIssueToContext(ctx, {
        received: ctx.data,
        code: ZodIssueCode.invalid_literal,
        expected: this._def.value
      });
      return INVALID;
    }
    return { status: "valid", value: input2.data };
  }
  get value() {
    return this._def.value;
  }
};
ZodLiteral.create = (value, params) => {
  return new ZodLiteral({
    value,
    typeName: ZodFirstPartyTypeKind.ZodLiteral,
    ...processCreateParams(params)
  });
};
function createZodEnum(values, params) {
  return new ZodEnum({
    values,
    typeName: ZodFirstPartyTypeKind.ZodEnum,
    ...processCreateParams(params)
  });
}
var ZodEnum = class _ZodEnum extends ZodType {
  constructor() {
    super(...arguments);
    _ZodEnum_cache.set(this, void 0);
  }
  _parse(input2) {
    if (typeof input2.data !== "string") {
      const ctx = this._getOrReturnCtx(input2);
      const expectedValues = this._def.values;
      addIssueToContext(ctx, {
        expected: util.joinValues(expectedValues),
        received: ctx.parsedType,
        code: ZodIssueCode.invalid_type
      });
      return INVALID;
    }
    if (!__classPrivateFieldGet(this, _ZodEnum_cache, "f")) {
      __classPrivateFieldSet(this, _ZodEnum_cache, new Set(this._def.values), "f");
    }
    if (!__classPrivateFieldGet(this, _ZodEnum_cache, "f").has(input2.data)) {
      const ctx = this._getOrReturnCtx(input2);
      const expectedValues = this._def.values;
      addIssueToContext(ctx, {
        received: ctx.data,
        code: ZodIssueCode.invalid_enum_value,
        options: expectedValues
      });
      return INVALID;
    }
    return OK(input2.data);
  }
  get options() {
    return this._def.values;
  }
  get enum() {
    const enumValues = {};
    for (const val of this._def.values) {
      enumValues[val] = val;
    }
    return enumValues;
  }
  get Values() {
    const enumValues = {};
    for (const val of this._def.values) {
      enumValues[val] = val;
    }
    return enumValues;
  }
  get Enum() {
    const enumValues = {};
    for (const val of this._def.values) {
      enumValues[val] = val;
    }
    return enumValues;
  }
  extract(values, newDef = this._def) {
    return _ZodEnum.create(values, {
      ...this._def,
      ...newDef
    });
  }
  exclude(values, newDef = this._def) {
    return _ZodEnum.create(this.options.filter((opt) => !values.includes(opt)), {
      ...this._def,
      ...newDef
    });
  }
};
_ZodEnum_cache = /* @__PURE__ */ new WeakMap();
ZodEnum.create = createZodEnum;
var ZodNativeEnum = class extends ZodType {
  constructor() {
    super(...arguments);
    _ZodNativeEnum_cache.set(this, void 0);
  }
  _parse(input2) {
    const nativeEnumValues = util.getValidEnumValues(this._def.values);
    const ctx = this._getOrReturnCtx(input2);
    if (ctx.parsedType !== ZodParsedType.string && ctx.parsedType !== ZodParsedType.number) {
      const expectedValues = util.objectValues(nativeEnumValues);
      addIssueToContext(ctx, {
        expected: util.joinValues(expectedValues),
        received: ctx.parsedType,
        code: ZodIssueCode.invalid_type
      });
      return INVALID;
    }
    if (!__classPrivateFieldGet(this, _ZodNativeEnum_cache, "f")) {
      __classPrivateFieldSet(this, _ZodNativeEnum_cache, new Set(util.getValidEnumValues(this._def.values)), "f");
    }
    if (!__classPrivateFieldGet(this, _ZodNativeEnum_cache, "f").has(input2.data)) {
      const expectedValues = util.objectValues(nativeEnumValues);
      addIssueToContext(ctx, {
        received: ctx.data,
        code: ZodIssueCode.invalid_enum_value,
        options: expectedValues
      });
      return INVALID;
    }
    return OK(input2.data);
  }
  get enum() {
    return this._def.values;
  }
};
_ZodNativeEnum_cache = /* @__PURE__ */ new WeakMap();
ZodNativeEnum.create = (values, params) => {
  return new ZodNativeEnum({
    values,
    typeName: ZodFirstPartyTypeKind.ZodNativeEnum,
    ...processCreateParams(params)
  });
};
var ZodPromise = class extends ZodType {
  unwrap() {
    return this._def.type;
  }
  _parse(input2) {
    const { ctx } = this._processInputParams(input2);
    if (ctx.parsedType !== ZodParsedType.promise && ctx.common.async === false) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.promise,
        received: ctx.parsedType
      });
      return INVALID;
    }
    const promisified = ctx.parsedType === ZodParsedType.promise ? ctx.data : Promise.resolve(ctx.data);
    return OK(promisified.then((data) => {
      return this._def.type.parseAsync(data, {
        path: ctx.path,
        errorMap: ctx.common.contextualErrorMap
      });
    }));
  }
};
ZodPromise.create = (schema, params) => {
  return new ZodPromise({
    type: schema,
    typeName: ZodFirstPartyTypeKind.ZodPromise,
    ...processCreateParams(params)
  });
};
var ZodEffects = class extends ZodType {
  innerType() {
    return this._def.schema;
  }
  sourceType() {
    return this._def.schema._def.typeName === ZodFirstPartyTypeKind.ZodEffects ? this._def.schema.sourceType() : this._def.schema;
  }
  _parse(input2) {
    const { status, ctx } = this._processInputParams(input2);
    const effect = this._def.effect || null;
    const checkCtx = {
      addIssue: (arg) => {
        addIssueToContext(ctx, arg);
        if (arg.fatal) {
          status.abort();
        } else {
          status.dirty();
        }
      },
      get path() {
        return ctx.path;
      }
    };
    checkCtx.addIssue = checkCtx.addIssue.bind(checkCtx);
    if (effect.type === "preprocess") {
      const processed = effect.transform(ctx.data, checkCtx);
      if (ctx.common.async) {
        return Promise.resolve(processed).then(async (processed2) => {
          if (status.value === "aborted")
            return INVALID;
          const result = await this._def.schema._parseAsync({
            data: processed2,
            path: ctx.path,
            parent: ctx
          });
          if (result.status === "aborted")
            return INVALID;
          if (result.status === "dirty")
            return DIRTY(result.value);
          if (status.value === "dirty")
            return DIRTY(result.value);
          return result;
        });
      } else {
        if (status.value === "aborted")
          return INVALID;
        const result = this._def.schema._parseSync({
          data: processed,
          path: ctx.path,
          parent: ctx
        });
        if (result.status === "aborted")
          return INVALID;
        if (result.status === "dirty")
          return DIRTY(result.value);
        if (status.value === "dirty")
          return DIRTY(result.value);
        return result;
      }
    }
    if (effect.type === "refinement") {
      const executeRefinement = (acc) => {
        const result = effect.refinement(acc, checkCtx);
        if (ctx.common.async) {
          return Promise.resolve(result);
        }
        if (result instanceof Promise) {
          throw new Error("Async refinement encountered during synchronous parse operation. Use .parseAsync instead.");
        }
        return acc;
      };
      if (ctx.common.async === false) {
        const inner = this._def.schema._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        });
        if (inner.status === "aborted")
          return INVALID;
        if (inner.status === "dirty")
          status.dirty();
        executeRefinement(inner.value);
        return { status: status.value, value: inner.value };
      } else {
        return this._def.schema._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx }).then((inner) => {
          if (inner.status === "aborted")
            return INVALID;
          if (inner.status === "dirty")
            status.dirty();
          return executeRefinement(inner.value).then(() => {
            return { status: status.value, value: inner.value };
          });
        });
      }
    }
    if (effect.type === "transform") {
      if (ctx.common.async === false) {
        const base = this._def.schema._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        });
        if (!isValid(base))
          return base;
        const result = effect.transform(base.value, checkCtx);
        if (result instanceof Promise) {
          throw new Error(`Asynchronous transform encountered during synchronous parse operation. Use .parseAsync instead.`);
        }
        return { status: status.value, value: result };
      } else {
        return this._def.schema._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx }).then((base) => {
          if (!isValid(base))
            return base;
          return Promise.resolve(effect.transform(base.value, checkCtx)).then((result) => ({ status: status.value, value: result }));
        });
      }
    }
    util.assertNever(effect);
  }
};
ZodEffects.create = (schema, effect, params) => {
  return new ZodEffects({
    schema,
    typeName: ZodFirstPartyTypeKind.ZodEffects,
    effect,
    ...processCreateParams(params)
  });
};
ZodEffects.createWithPreprocess = (preprocess, schema, params) => {
  return new ZodEffects({
    schema,
    effect: { type: "preprocess", transform: preprocess },
    typeName: ZodFirstPartyTypeKind.ZodEffects,
    ...processCreateParams(params)
  });
};
var ZodOptional = class extends ZodType {
  _parse(input2) {
    const parsedType = this._getType(input2);
    if (parsedType === ZodParsedType.undefined) {
      return OK(void 0);
    }
    return this._def.innerType._parse(input2);
  }
  unwrap() {
    return this._def.innerType;
  }
};
ZodOptional.create = (type, params) => {
  return new ZodOptional({
    innerType: type,
    typeName: ZodFirstPartyTypeKind.ZodOptional,
    ...processCreateParams(params)
  });
};
var ZodNullable = class extends ZodType {
  _parse(input2) {
    const parsedType = this._getType(input2);
    if (parsedType === ZodParsedType.null) {
      return OK(null);
    }
    return this._def.innerType._parse(input2);
  }
  unwrap() {
    return this._def.innerType;
  }
};
ZodNullable.create = (type, params) => {
  return new ZodNullable({
    innerType: type,
    typeName: ZodFirstPartyTypeKind.ZodNullable,
    ...processCreateParams(params)
  });
};
var ZodDefault = class extends ZodType {
  _parse(input2) {
    const { ctx } = this._processInputParams(input2);
    let data = ctx.data;
    if (ctx.parsedType === ZodParsedType.undefined) {
      data = this._def.defaultValue();
    }
    return this._def.innerType._parse({
      data,
      path: ctx.path,
      parent: ctx
    });
  }
  removeDefault() {
    return this._def.innerType;
  }
};
ZodDefault.create = (type, params) => {
  return new ZodDefault({
    innerType: type,
    typeName: ZodFirstPartyTypeKind.ZodDefault,
    defaultValue: typeof params.default === "function" ? params.default : () => params.default,
    ...processCreateParams(params)
  });
};
var ZodCatch = class extends ZodType {
  _parse(input2) {
    const { ctx } = this._processInputParams(input2);
    const newCtx = {
      ...ctx,
      common: {
        ...ctx.common,
        issues: []
      }
    };
    const result = this._def.innerType._parse({
      data: newCtx.data,
      path: newCtx.path,
      parent: {
        ...newCtx
      }
    });
    if (isAsync(result)) {
      return result.then((result2) => {
        return {
          status: "valid",
          value: result2.status === "valid" ? result2.value : this._def.catchValue({
            get error() {
              return new ZodError(newCtx.common.issues);
            },
            input: newCtx.data
          })
        };
      });
    } else {
      return {
        status: "valid",
        value: result.status === "valid" ? result.value : this._def.catchValue({
          get error() {
            return new ZodError(newCtx.common.issues);
          },
          input: newCtx.data
        })
      };
    }
  }
  removeCatch() {
    return this._def.innerType;
  }
};
ZodCatch.create = (type, params) => {
  return new ZodCatch({
    innerType: type,
    typeName: ZodFirstPartyTypeKind.ZodCatch,
    catchValue: typeof params.catch === "function" ? params.catch : () => params.catch,
    ...processCreateParams(params)
  });
};
var ZodNaN = class extends ZodType {
  _parse(input2) {
    const parsedType = this._getType(input2);
    if (parsedType !== ZodParsedType.nan) {
      const ctx = this._getOrReturnCtx(input2);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.nan,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return { status: "valid", value: input2.data };
  }
};
ZodNaN.create = (params) => {
  return new ZodNaN({
    typeName: ZodFirstPartyTypeKind.ZodNaN,
    ...processCreateParams(params)
  });
};
var BRAND = Symbol("zod_brand");
var ZodBranded = class extends ZodType {
  _parse(input2) {
    const { ctx } = this._processInputParams(input2);
    const data = ctx.data;
    return this._def.type._parse({
      data,
      path: ctx.path,
      parent: ctx
    });
  }
  unwrap() {
    return this._def.type;
  }
};
var ZodPipeline = class _ZodPipeline extends ZodType {
  _parse(input2) {
    const { status, ctx } = this._processInputParams(input2);
    if (ctx.common.async) {
      const handleAsync = async () => {
        const inResult = await this._def.in._parseAsync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        });
        if (inResult.status === "aborted")
          return INVALID;
        if (inResult.status === "dirty") {
          status.dirty();
          return DIRTY(inResult.value);
        } else {
          return this._def.out._parseAsync({
            data: inResult.value,
            path: ctx.path,
            parent: ctx
          });
        }
      };
      return handleAsync();
    } else {
      const inResult = this._def.in._parseSync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      });
      if (inResult.status === "aborted")
        return INVALID;
      if (inResult.status === "dirty") {
        status.dirty();
        return {
          status: "dirty",
          value: inResult.value
        };
      } else {
        return this._def.out._parseSync({
          data: inResult.value,
          path: ctx.path,
          parent: ctx
        });
      }
    }
  }
  static create(a, b) {
    return new _ZodPipeline({
      in: a,
      out: b,
      typeName: ZodFirstPartyTypeKind.ZodPipeline
    });
  }
};
var ZodReadonly = class extends ZodType {
  _parse(input2) {
    const result = this._def.innerType._parse(input2);
    const freeze = (data) => {
      if (isValid(data)) {
        data.value = Object.freeze(data.value);
      }
      return data;
    };
    return isAsync(result) ? result.then((data) => freeze(data)) : freeze(result);
  }
  unwrap() {
    return this._def.innerType;
  }
};
ZodReadonly.create = (type, params) => {
  return new ZodReadonly({
    innerType: type,
    typeName: ZodFirstPartyTypeKind.ZodReadonly,
    ...processCreateParams(params)
  });
};
function cleanParams(params, data) {
  const p = typeof params === "function" ? params(data) : typeof params === "string" ? { message: params } : params;
  const p2 = typeof p === "string" ? { message: p } : p;
  return p2;
}
function custom(check, _params = {}, fatal) {
  if (check)
    return ZodAny.create().superRefine((data, ctx) => {
      var _a2, _b;
      const r = check(data);
      if (r instanceof Promise) {
        return r.then((r2) => {
          var _a3, _b2;
          if (!r2) {
            const params = cleanParams(_params, data);
            const _fatal = (_b2 = (_a3 = params.fatal) !== null && _a3 !== void 0 ? _a3 : fatal) !== null && _b2 !== void 0 ? _b2 : true;
            ctx.addIssue({ code: "custom", ...params, fatal: _fatal });
          }
        });
      }
      if (!r) {
        const params = cleanParams(_params, data);
        const _fatal = (_b = (_a2 = params.fatal) !== null && _a2 !== void 0 ? _a2 : fatal) !== null && _b !== void 0 ? _b : true;
        ctx.addIssue({ code: "custom", ...params, fatal: _fatal });
      }
      return;
    });
  return ZodAny.create();
}
var late = {
  object: ZodObject.lazycreate
};
var ZodFirstPartyTypeKind;
(function(ZodFirstPartyTypeKind2) {
  ZodFirstPartyTypeKind2["ZodString"] = "ZodString";
  ZodFirstPartyTypeKind2["ZodNumber"] = "ZodNumber";
  ZodFirstPartyTypeKind2["ZodNaN"] = "ZodNaN";
  ZodFirstPartyTypeKind2["ZodBigInt"] = "ZodBigInt";
  ZodFirstPartyTypeKind2["ZodBoolean"] = "ZodBoolean";
  ZodFirstPartyTypeKind2["ZodDate"] = "ZodDate";
  ZodFirstPartyTypeKind2["ZodSymbol"] = "ZodSymbol";
  ZodFirstPartyTypeKind2["ZodUndefined"] = "ZodUndefined";
  ZodFirstPartyTypeKind2["ZodNull"] = "ZodNull";
  ZodFirstPartyTypeKind2["ZodAny"] = "ZodAny";
  ZodFirstPartyTypeKind2["ZodUnknown"] = "ZodUnknown";
  ZodFirstPartyTypeKind2["ZodNever"] = "ZodNever";
  ZodFirstPartyTypeKind2["ZodVoid"] = "ZodVoid";
  ZodFirstPartyTypeKind2["ZodArray"] = "ZodArray";
  ZodFirstPartyTypeKind2["ZodObject"] = "ZodObject";
  ZodFirstPartyTypeKind2["ZodUnion"] = "ZodUnion";
  ZodFirstPartyTypeKind2["ZodDiscriminatedUnion"] = "ZodDiscriminatedUnion";
  ZodFirstPartyTypeKind2["ZodIntersection"] = "ZodIntersection";
  ZodFirstPartyTypeKind2["ZodTuple"] = "ZodTuple";
  ZodFirstPartyTypeKind2["ZodRecord"] = "ZodRecord";
  ZodFirstPartyTypeKind2["ZodMap"] = "ZodMap";
  ZodFirstPartyTypeKind2["ZodSet"] = "ZodSet";
  ZodFirstPartyTypeKind2["ZodFunction"] = "ZodFunction";
  ZodFirstPartyTypeKind2["ZodLazy"] = "ZodLazy";
  ZodFirstPartyTypeKind2["ZodLiteral"] = "ZodLiteral";
  ZodFirstPartyTypeKind2["ZodEnum"] = "ZodEnum";
  ZodFirstPartyTypeKind2["ZodEffects"] = "ZodEffects";
  ZodFirstPartyTypeKind2["ZodNativeEnum"] = "ZodNativeEnum";
  ZodFirstPartyTypeKind2["ZodOptional"] = "ZodOptional";
  ZodFirstPartyTypeKind2["ZodNullable"] = "ZodNullable";
  ZodFirstPartyTypeKind2["ZodDefault"] = "ZodDefault";
  ZodFirstPartyTypeKind2["ZodCatch"] = "ZodCatch";
  ZodFirstPartyTypeKind2["ZodPromise"] = "ZodPromise";
  ZodFirstPartyTypeKind2["ZodBranded"] = "ZodBranded";
  ZodFirstPartyTypeKind2["ZodPipeline"] = "ZodPipeline";
  ZodFirstPartyTypeKind2["ZodReadonly"] = "ZodReadonly";
})(ZodFirstPartyTypeKind || (ZodFirstPartyTypeKind = {}));
var instanceOfType = (cls, params = {
  message: `Input not instance of ${cls.name}`
}) => custom((data) => data instanceof cls, params);
var stringType = ZodString.create;
var numberType = ZodNumber.create;
var nanType = ZodNaN.create;
var bigIntType = ZodBigInt.create;
var booleanType = ZodBoolean.create;
var dateType = ZodDate.create;
var symbolType = ZodSymbol.create;
var undefinedType = ZodUndefined.create;
var nullType = ZodNull.create;
var anyType = ZodAny.create;
var unknownType = ZodUnknown.create;
var neverType = ZodNever.create;
var voidType = ZodVoid.create;
var arrayType = ZodArray.create;
var objectType = ZodObject.create;
var strictObjectType = ZodObject.strictCreate;
var unionType = ZodUnion.create;
var discriminatedUnionType = ZodDiscriminatedUnion.create;
var intersectionType = ZodIntersection.create;
var tupleType = ZodTuple.create;
var recordType = ZodRecord.create;
var mapType = ZodMap.create;
var setType = ZodSet.create;
var functionType = ZodFunction.create;
var lazyType = ZodLazy.create;
var literalType = ZodLiteral.create;
var enumType = ZodEnum.create;
var nativeEnumType = ZodNativeEnum.create;
var promiseType = ZodPromise.create;
var effectsType = ZodEffects.create;
var optionalType = ZodOptional.create;
var nullableType = ZodNullable.create;
var preprocessType = ZodEffects.createWithPreprocess;
var pipelineType = ZodPipeline.create;
var ostring = () => stringType().optional();
var onumber = () => numberType().optional();
var oboolean = () => booleanType().optional();
var coerce = {
  string: (arg) => ZodString.create({ ...arg, coerce: true }),
  number: (arg) => ZodNumber.create({ ...arg, coerce: true }),
  boolean: (arg) => ZodBoolean.create({
    ...arg,
    coerce: true
  }),
  bigint: (arg) => ZodBigInt.create({ ...arg, coerce: true }),
  date: (arg) => ZodDate.create({ ...arg, coerce: true })
};
var NEVER = INVALID;
var z = Object.freeze({
  __proto__: null,
  defaultErrorMap: errorMap,
  setErrorMap,
  getErrorMap,
  makeIssue,
  EMPTY_PATH,
  addIssueToContext,
  ParseStatus,
  INVALID,
  DIRTY,
  OK,
  isAborted,
  isDirty,
  isValid,
  isAsync,
  get util() {
    return util;
  },
  get objectUtil() {
    return objectUtil;
  },
  ZodParsedType,
  getParsedType,
  ZodType,
  datetimeRegex,
  ZodString,
  ZodNumber,
  ZodBigInt,
  ZodBoolean,
  ZodDate,
  ZodSymbol,
  ZodUndefined,
  ZodNull,
  ZodAny,
  ZodUnknown,
  ZodNever,
  ZodVoid,
  ZodArray,
  ZodObject,
  ZodUnion,
  ZodDiscriminatedUnion,
  ZodIntersection,
  ZodTuple,
  ZodRecord,
  ZodMap,
  ZodSet,
  ZodFunction,
  ZodLazy,
  ZodLiteral,
  ZodEnum,
  ZodNativeEnum,
  ZodPromise,
  ZodEffects,
  ZodTransformer: ZodEffects,
  ZodOptional,
  ZodNullable,
  ZodDefault,
  ZodCatch,
  ZodNaN,
  BRAND,
  ZodBranded,
  ZodPipeline,
  ZodReadonly,
  custom,
  Schema: ZodType,
  ZodSchema: ZodType,
  late,
  get ZodFirstPartyTypeKind() {
    return ZodFirstPartyTypeKind;
  },
  coerce,
  any: anyType,
  array: arrayType,
  bigint: bigIntType,
  boolean: booleanType,
  date: dateType,
  discriminatedUnion: discriminatedUnionType,
  effect: effectsType,
  "enum": enumType,
  "function": functionType,
  "instanceof": instanceOfType,
  intersection: intersectionType,
  lazy: lazyType,
  literal: literalType,
  map: mapType,
  nan: nanType,
  nativeEnum: nativeEnumType,
  never: neverType,
  "null": nullType,
  nullable: nullableType,
  number: numberType,
  object: objectType,
  oboolean,
  onumber,
  optional: optionalType,
  ostring,
  pipeline: pipelineType,
  preprocess: preprocessType,
  promise: promiseType,
  record: recordType,
  set: setType,
  strictObject: strictObjectType,
  string: stringType,
  symbol: symbolType,
  transformer: effectsType,
  tuple: tupleType,
  "undefined": undefinedType,
  union: unionType,
  unknown: unknownType,
  "void": voidType,
  NEVER,
  ZodIssueCode,
  quotelessJson,
  ZodError
});

// node_modules/@fiberplane/hono/dist/services/base.js
var BaseService = class {
  apiKey;
  baseUrl;
  fetch;
  constructor(apiKey, baseUrl, fetch2) {
    this.apiKey = apiKey;
    this.baseUrl = baseUrl;
    this.fetch = fetch2;
  }
  async request(schema, endpoint, options = {}) {
    const url = `${this.baseUrl}${endpoint}`;
    const headers = {
      Authorization: `Bearer ${this.apiKey}`,
      "Content-Type": "application/json",
      ...options.headers
    };
    const response = await this.fetch(url, { ...options, headers });
    if (!response.ok) {
      throw new Error(`API request failed: ${response.statusText}`);
    }
    const json = await response.json();
    return schema.parse(json);
  }
};

// node_modules/@fiberplane/hono/dist/services/tokens.js
var CreateTokenResponseSchema = z.object({ token: z.string() });
var VerifyTokenResponseSchema = z.object({ valid: z.boolean() });
var RevokeTokenResponseSchema = z.object({ success: z.boolean() });
var TokenService = class extends BaseService {
  async createToken(metadata) {
    return this.request(CreateTokenResponseSchema, "/tokens", {
      method: "PUT",
      body: JSON.stringify({ metadata })
    });
  }
  async verifyToken(token) {
    return this.request(VerifyTokenResponseSchema, "/tokens/verify", {
      method: "POST",
      body: JSON.stringify({ token })
    });
  }
  async revokeToken(token) {
    return this.request(RevokeTokenResponseSchema, `/tokens/revoke/${token}`, {
      method: "DELETE"
    });
  }
};

// node_modules/@fiberplane/hono/dist/services/index.js
var FpService = class {
  tokens;
  constructor({ apiKey, baseUrl = "http://localhost:7676/api", fetch: fetch2 }) {
    this.tokens = new TokenService(apiKey, baseUrl, fetch2);
  }
};

// node_modules/@fiberplane/hono/dist/routes/api/tokens.js
function createTokensApiRoute(apiKey, fetchFn, fiberplaneServicesUrl) {
  const app = new Hono();
  const service = new FpService({
    apiKey,
    fetch: fetchFn,
    baseUrl: `${fiberplaneServicesUrl}/api`
  });
  app.get("/", async (c) => {
    logIfDebug(c, "[tokens]", "- GET / -");
    c.json({ lol: "broek" });
  });
  app.put("/", async (c) => {
    logIfDebug(c, "[tokens]", "- PUT / -");
    const requestBody = await c.req.json();
    const { metadata } = z.object({ metadata: z.string() }).parse(requestBody);
    const response = await service.tokens.createToken(metadata);
    logIfDebug(c, "[tokens]", "- PUT / -", "Token generated:", response);
    return c.json(response);
  });
  app.post("/verify", async (c) => {
    logIfDebug(c, "[tokens]", "- POST /verify -");
    const requestBody = await c.req.json();
    const { token } = z.object({ token: z.string() }).parse(requestBody);
    const response = await service.tokens.verifyToken(token);
    logIfDebug(c, "[tokens]", "- POST /verify -", "Token verified:", response);
    return c.json(response);
  });
  app.delete("/revoke", async (c) => {
    logIfDebug(c, "[tokens]", "- DELETE /revoke -");
    const requestBody = await c.req.json();
    const { token } = z.object({ token: z.string() }).parse(requestBody);
    const response = await service.tokens.revokeToken(token);
    logIfDebug(c, "[tokens]", "- DELETE /revoke -", "Token revoked:", response);
    return c.json(response);
  });
  return app;
}

// node_modules/@fiberplane/hono/dist/routes/api/workflows.js
function createWorkflowsApiRoute(apiKey, fetchFn, fiberplaneServicesUrl) {
  const app = new Hono();
  app.all("*", async (c) => {
    const url = `${fiberplaneServicesUrl}${c.req.path}`;
    const contentType = c.req.header("content-type");
    const partitionKey = c.req.header("X-Fiberplane-Partition-Key");
    logIfDebug(c, "[workflows]", `- ${c.req.method} ${c.req.path} -`, "Proxying request to: ", url);
    const headers = new Headers();
    headers.set("Authorization", `Bearer ${apiKey}`);
    if (contentType) {
      logIfDebug(c, "[workflows]", `- ${c.req.method} ${c.req.path} -`, "content type attached to proxied request:", contentType);
      headers.set("content-type", contentType);
    }
    if (partitionKey) {
      headers.set("X-Fiberplane-Partition-Key", partitionKey);
      logIfDebug(c, "[workflows]", `- ${c.req.method} ${c.req.path} -`, "partition key attached to proxied request:", partitionKey);
    }
    const result = fetchFn(url, {
      method: c.req.method,
      headers,
      body: c.req.raw.body
    });
    return result;
  });
  return app;
}

// node_modules/@fiberplane/hono/dist/routes/api/index.js
function createApiRoutes(fetchFn, apiKey, fiberplaneServicesUrl) {
  const app = new Hono();
  app.route("/workflows", createWorkflowsApiRoute(apiKey, fetchFn, fiberplaneServicesUrl));
  app.route("/tokens", createTokensApiRoute(apiKey, fetchFn, fiberplaneServicesUrl));
  app.route("/reports", createReportsApiRoute(apiKey, fetchFn, fiberplaneServicesUrl));
  app.route("/assistant", createAssistantApiRoute(apiKey, fetchFn, fiberplaneServicesUrl));
  return app;
}

// node_modules/@fiberplane/hono/dist/routes/api/traces.js
function createTracesApiRoute(fetchFn, otelEndpoint, otelToken) {
  const app = new Hono();
  app.get("/", async (c) => {
    logIfDebug(c, "[traces]", "- GET / -", "Proxying request to fiberplane api");
    if (!otelEndpoint) {
      logIfDebug(c, "[traces]", "- GET / -", "otel endpoint undefined, returning early");
      return c.json({ error: "Tracing is not enabled" }, 402);
    }
    if (!otelToken) {
      logIfDebug(c, "[traces]", "- GET / -", "otel token undefined, skipping auth header");
    } else {
      logIfDebug(c, "[traces]", "- GET / -", "otel token defined, adding auth header");
    }
    try {
      const otelBaseUrl = getOtelBaseUrl(otelEndpoint);
      const requestUrl = `${otelBaseUrl}/v1/traces`;
      const response = await fetchFn(requestUrl, {
        headers: {
          "Content-Type": "application/json",
          Accept: "application/json",
          ...otelToken ? { Authorization: `Bearer ${otelToken}` } : {}
        }
      });
      logIfDebug(c, "[traces]", "- GET / -", "API response from traces endpoint:", response);
      const data = await response.json();
      return c.json(data);
    } catch (error) {
      console.error("Failed to fetch traces:", error);
      return c.json({ error: "Failed to fetch traces" }, 500);
    }
  });
  app.get("/:traceId/spans", async (c) => {
    logIfDebug(c, "[traces]", "- GET /:traceId/spans -", "Proxying request to fiberplane api");
    if (!otelEndpoint) {
      return c.json({ error: "Tracing is not enabled" }, 402);
    }
    if (!otelToken) {
      logIfDebug(c, "[traces]", "- GET /:traceId/spans -", "otel token undefined, skipping auth header");
    }
    try {
      const otelBaseUrl = getOtelBaseUrl(otelEndpoint);
      const traceId = c.req.param("traceId");
      const requestUrl = `${otelBaseUrl}/v1/traces/${traceId}/spans`;
      const response = await fetch(requestUrl, {
        headers: {
          "Content-Type": "application/json",
          Accept: "application/json",
          ...otelToken ? { Authorization: `Bearer ${otelToken}` } : {}
        }
      });
      logIfDebug(c, "[traces]", "- GET /:traceId/spans -", "API response from spans endpoint:", response);
      const data = await response.json();
      return c.json(data);
    } catch (error) {
      console.error("Failed to fetch spans:", error);
      return c.json({ error: "Failed to fetch spans" }, 500);
    }
  });
  return app;
}
function getOtelBaseUrl(otelEndpoint) {
  const url = new URL(otelEndpoint);
  return url.origin;
}

// node_modules/hono/dist/jsx/constants.js
var DOM_RENDERER = Symbol("RENDERER");
var DOM_ERROR_HANDLER = Symbol("ERROR_HANDLER");
var DOM_STASH = Symbol("STASH");
var DOM_INTERNAL_TAG = Symbol("INTERNAL");
var DOM_MEMO = Symbol("MEMO");
var PERMALINK = Symbol("PERMALINK");

// node_modules/hono/dist/jsx/dom/utils.js
var setInternalTagFlag = (fn) => {
  ;
  fn[DOM_INTERNAL_TAG] = true;
  return fn;
};

// node_modules/hono/dist/jsx/dom/context.js
var createContextProviderFunction = (values) => ({ value, children }) => {
  if (!children) {
    return void 0;
  }
  const props = {
    children: [
      {
        tag: setInternalTagFlag(() => {
          values.push(value);
        }),
        props: {}
      }
    ]
  };
  if (Array.isArray(children)) {
    props.children.push(...children.flat());
  } else {
    props.children.push(children);
  }
  props.children.push({
    tag: setInternalTagFlag(() => {
      values.pop();
    }),
    props: {}
  });
  const res = { tag: "", props, type: "" };
  res[DOM_ERROR_HANDLER] = (err) => {
    values.pop();
    throw err;
  };
  return res;
};

// node_modules/hono/dist/jsx/context.js
var globalContexts = [];
var createContext = (defaultValue) => {
  const values = [defaultValue];
  const context = (props) => {
    values.push(props.value);
    let string;
    try {
      string = props.children ? (Array.isArray(props.children) ? new JSXFragmentNode("", {}, props.children) : props.children).toString() : "";
    } finally {
      values.pop();
    }
    if (string instanceof Promise) {
      return string.then((resString) => raw(resString, resString.callbacks));
    } else {
      return raw(string);
    }
  };
  context.values = values;
  context.Provider = context;
  context[DOM_RENDERER] = createContextProviderFunction(values);
  globalContexts.push(context);
  return context;
};
var useContext = (context) => {
  return context.values.at(-1);
};

// node_modules/hono/dist/jsx/intrinsic-element/common.js
var deDupeKeyMap = {
  title: [],
  script: ["src"],
  style: ["data-href"],
  link: ["href"],
  meta: ["name", "httpEquiv", "charset", "itemProp"]
};
var domRenderers = {};
var dataPrecedenceAttr = "data-precedence";

// node_modules/hono/dist/jsx/intrinsic-element/components.js
var components_exports = {};
__export(components_exports, {
  button: () => button,
  form: () => form,
  input: () => input,
  link: () => link,
  meta: () => meta,
  script: () => script,
  style: () => style,
  title: () => title
});

// node_modules/hono/dist/jsx/children.js
var toArray = (children) => Array.isArray(children) ? children : [children];

// node_modules/hono/dist/jsx/intrinsic-element/components.js
var metaTagMap = /* @__PURE__ */ new WeakMap();
var insertIntoHead = (tagName, tag, props, precedence) => ({ buffer, context }) => {
  if (!buffer) {
    return;
  }
  const map = metaTagMap.get(context) || {};
  metaTagMap.set(context, map);
  const tags = map[tagName] ||= [];
  let duped = false;
  const deDupeKeys = deDupeKeyMap[tagName];
  if (deDupeKeys.length > 0) {
    LOOP:
      for (const [, tagProps] of tags) {
        for (const key of deDupeKeys) {
          if ((tagProps?.[key] ?? null) === props?.[key]) {
            duped = true;
            break LOOP;
          }
        }
      }
  }
  if (duped) {
    buffer[0] = buffer[0].replaceAll(tag, "");
  } else if (deDupeKeys.length > 0) {
    tags.push([tag, props, precedence]);
  } else {
    tags.unshift([tag, props, precedence]);
  }
  if (buffer[0].indexOf("</head>") !== -1) {
    let insertTags;
    if (precedence === void 0) {
      insertTags = tags.map(([tag2]) => tag2);
    } else {
      const precedences = [];
      insertTags = tags.map(([tag2, , precedence2]) => {
        let order = precedences.indexOf(precedence2);
        if (order === -1) {
          precedences.push(precedence2);
          order = precedences.length - 1;
        }
        return [tag2, order];
      }).sort((a, b) => a[1] - b[1]).map(([tag2]) => tag2);
    }
    insertTags.forEach((tag2) => {
      buffer[0] = buffer[0].replaceAll(tag2, "");
    });
    buffer[0] = buffer[0].replace(/(?=<\/head>)/, insertTags.join(""));
  }
};
var returnWithoutSpecialBehavior = (tag, children, props) => raw(new JSXNode(tag, props, toArray(children ?? [])).toString());
var documentMetadataTag = (tag, children, props, sort) => {
  if ("itemProp" in props) {
    return returnWithoutSpecialBehavior(tag, children, props);
  }
  let { precedence, blocking, ...restProps } = props;
  precedence = sort ? precedence ?? "" : void 0;
  if (sort) {
    restProps[dataPrecedenceAttr] = precedence;
  }
  const string = new JSXNode(tag, restProps, toArray(children || [])).toString();
  if (string instanceof Promise) {
    return string.then(
      (resString) => raw(string, [
        ...resString.callbacks || [],
        insertIntoHead(tag, resString, restProps, precedence)
      ])
    );
  } else {
    return raw(string, [insertIntoHead(tag, string, restProps, precedence)]);
  }
};
var title = ({ children, ...props }) => {
  const nameSpaceContext2 = getNameSpaceContext();
  if (nameSpaceContext2) {
    const context = useContext(nameSpaceContext2);
    if (context === "svg" || context === "head") {
      return new JSXNode(
        "title",
        props,
        toArray(children ?? [])
      );
    }
  }
  return documentMetadataTag("title", children, props, false);
};
var script = ({
  children,
  ...props
}) => {
  const nameSpaceContext2 = getNameSpaceContext();
  if (["src", "async"].some((k) => !props[k]) || nameSpaceContext2 && useContext(nameSpaceContext2) === "head") {
    return returnWithoutSpecialBehavior("script", children, props);
  }
  return documentMetadataTag("script", children, props, false);
};
var style = ({
  children,
  ...props
}) => {
  if (!["href", "precedence"].every((k) => k in props)) {
    return returnWithoutSpecialBehavior("style", children, props);
  }
  props["data-href"] = props.href;
  delete props.href;
  return documentMetadataTag("style", children, props, true);
};
var link = ({ children, ...props }) => {
  if (["onLoad", "onError"].some((k) => k in props) || props.rel === "stylesheet" && (!("precedence" in props) || "disabled" in props)) {
    return returnWithoutSpecialBehavior("link", children, props);
  }
  return documentMetadataTag("link", children, props, "precedence" in props);
};
var meta = ({ children, ...props }) => {
  const nameSpaceContext2 = getNameSpaceContext();
  if (nameSpaceContext2 && useContext(nameSpaceContext2) === "head") {
    return returnWithoutSpecialBehavior("meta", children, props);
  }
  return documentMetadataTag("meta", children, props, false);
};
var newJSXNode = (tag, { children, ...props }) => new JSXNode(tag, props, toArray(children ?? []));
var form = (props) => {
  if (typeof props.action === "function") {
    props.action = PERMALINK in props.action ? props.action[PERMALINK] : void 0;
  }
  return newJSXNode("form", props);
};
var formActionableElement = (tag, props) => {
  if (typeof props.formAction === "function") {
    props.formAction = PERMALINK in props.formAction ? props.formAction[PERMALINK] : void 0;
  }
  return newJSXNode(tag, props);
};
var input = (props) => formActionableElement("input", props);
var button = (props) => formActionableElement("button", props);

// node_modules/hono/dist/jsx/utils.js
var normalizeElementKeyMap = /* @__PURE__ */ new Map([
  ["className", "class"],
  ["htmlFor", "for"],
  ["crossOrigin", "crossorigin"],
  ["httpEquiv", "http-equiv"],
  ["itemProp", "itemprop"],
  ["fetchPriority", "fetchpriority"],
  ["noModule", "nomodule"],
  ["formAction", "formaction"]
]);
var normalizeIntrinsicElementKey = (key) => normalizeElementKeyMap.get(key) || key;
var styleObjectForEach = (style2, fn) => {
  for (const [k, v] of Object.entries(style2)) {
    const key = k[0] === "-" || !/[A-Z]/.test(k) ? k : k.replace(/[A-Z]/g, (m) => `-${m.toLowerCase()}`);
    fn(
      key,
      v == null ? null : typeof v === "number" ? !key.match(
        /^(?:a|border-im|column(?:-c|s)|flex(?:$|-[^b])|grid-(?:ar|[^a])|font-w|li|or|sca|st|ta|wido|z)|ty$/
      ) ? `${v}px` : `${v}` : v
    );
  }
};

// node_modules/hono/dist/jsx/base.js
var nameSpaceContext = void 0;
var getNameSpaceContext = () => nameSpaceContext;
var toSVGAttributeName = (key) => /[A-Z]/.test(key) && key.match(
  /^(?:al|basel|clip(?:Path|Rule)$|co|do|fill|fl|fo|gl|let|lig|i|marker[EMS]|o|pai|pointe|sh|st[or]|text[^L]|tr|u|ve|w)/
) ? key.replace(/([A-Z])/g, "-$1").toLowerCase() : key;
var emptyTags = [
  "area",
  "base",
  "br",
  "col",
  "embed",
  "hr",
  "img",
  "input",
  "keygen",
  "link",
  "meta",
  "param",
  "source",
  "track",
  "wbr"
];
var booleanAttributes = [
  "allowfullscreen",
  "async",
  "autofocus",
  "autoplay",
  "checked",
  "controls",
  "default",
  "defer",
  "disabled",
  "download",
  "formnovalidate",
  "hidden",
  "inert",
  "ismap",
  "itemscope",
  "loop",
  "multiple",
  "muted",
  "nomodule",
  "novalidate",
  "open",
  "playsinline",
  "readonly",
  "required",
  "reversed",
  "selected"
];
var childrenToStringToBuffer = (children, buffer) => {
  for (let i = 0, len = children.length; i < len; i++) {
    const child = children[i];
    if (typeof child === "string") {
      escapeToBuffer(child, buffer);
    } else if (typeof child === "boolean" || child === null || child === void 0) {
      continue;
    } else if (child instanceof JSXNode) {
      child.toStringToBuffer(buffer);
    } else if (typeof child === "number" || child.isEscaped) {
      ;
      buffer[0] += child;
    } else if (child instanceof Promise) {
      buffer.unshift("", child);
    } else {
      childrenToStringToBuffer(child, buffer);
    }
  }
};
var JSXNode = class {
  tag;
  props;
  key;
  children;
  isEscaped = true;
  localContexts;
  constructor(tag, props, children) {
    this.tag = tag;
    this.props = props;
    this.children = children;
  }
  get type() {
    return this.tag;
  }
  get ref() {
    return this.props.ref || null;
  }
  toString() {
    const buffer = [""];
    this.localContexts?.forEach(([context, value]) => {
      context.values.push(value);
    });
    try {
      this.toStringToBuffer(buffer);
    } finally {
      this.localContexts?.forEach(([context]) => {
        context.values.pop();
      });
    }
    return buffer.length === 1 ? "callbacks" in buffer ? resolveCallbackSync(raw(buffer[0], buffer.callbacks)).toString() : buffer[0] : stringBufferToString(buffer, buffer.callbacks);
  }
  toStringToBuffer(buffer) {
    const tag = this.tag;
    const props = this.props;
    let { children } = this;
    buffer[0] += `<${tag}`;
    const normalizeKey = nameSpaceContext && useContext(nameSpaceContext) === "svg" ? (key) => toSVGAttributeName(normalizeIntrinsicElementKey(key)) : (key) => normalizeIntrinsicElementKey(key);
    for (let [key, v] of Object.entries(props)) {
      key = normalizeKey(key);
      if (key === "children") {
      } else if (key === "style" && typeof v === "object") {
        let styleStr = "";
        styleObjectForEach(v, (property, value) => {
          if (value != null) {
            styleStr += `${styleStr ? ";" : ""}${property}:${value}`;
          }
        });
        buffer[0] += ' style="';
        escapeToBuffer(styleStr, buffer);
        buffer[0] += '"';
      } else if (typeof v === "string") {
        buffer[0] += ` ${key}="`;
        escapeToBuffer(v, buffer);
        buffer[0] += '"';
      } else if (v === null || v === void 0) {
      } else if (typeof v === "number" || v.isEscaped) {
        buffer[0] += ` ${key}="${v}"`;
      } else if (typeof v === "boolean" && booleanAttributes.includes(key)) {
        if (v) {
          buffer[0] += ` ${key}=""`;
        }
      } else if (key === "dangerouslySetInnerHTML") {
        if (children.length > 0) {
          throw "Can only set one of `children` or `props.dangerouslySetInnerHTML`.";
        }
        children = [raw(v.__html)];
      } else if (v instanceof Promise) {
        buffer[0] += ` ${key}="`;
        buffer.unshift('"', v);
      } else if (typeof v === "function") {
        if (!key.startsWith("on")) {
          throw `Invalid prop '${key}' of type 'function' supplied to '${tag}'.`;
        }
      } else {
        buffer[0] += ` ${key}="`;
        escapeToBuffer(v.toString(), buffer);
        buffer[0] += '"';
      }
    }
    if (emptyTags.includes(tag) && children.length === 0) {
      buffer[0] += "/>";
      return;
    }
    buffer[0] += ">";
    childrenToStringToBuffer(children, buffer);
    buffer[0] += `</${tag}>`;
  }
};
var JSXFunctionNode = class extends JSXNode {
  toStringToBuffer(buffer) {
    const { children } = this;
    const res = this.tag.call(null, {
      ...this.props,
      children: children.length <= 1 ? children[0] : children
    });
    if (typeof res === "boolean" || res == null) {
      return;
    } else if (res instanceof Promise) {
      if (globalContexts.length === 0) {
        buffer.unshift("", res);
      } else {
        const currentContexts = globalContexts.map((c) => [c, c.values.at(-1)]);
        buffer.unshift(
          "",
          res.then((childRes) => {
            if (childRes instanceof JSXNode) {
              childRes.localContexts = currentContexts;
            }
            return childRes;
          })
        );
      }
    } else if (res instanceof JSXNode) {
      res.toStringToBuffer(buffer);
    } else if (typeof res === "number" || res.isEscaped) {
      buffer[0] += res;
      if (res.callbacks) {
        buffer.callbacks ||= [];
        buffer.callbacks.push(...res.callbacks);
      }
    } else {
      escapeToBuffer(res, buffer);
    }
  }
};
var JSXFragmentNode = class extends JSXNode {
  toStringToBuffer(buffer) {
    childrenToStringToBuffer(this.children, buffer);
  }
};
var initDomRenderer = false;
var jsxFn = (tag, props, children) => {
  if (!initDomRenderer) {
    for (const k in domRenderers) {
      ;
      components_exports[k][DOM_RENDERER] = domRenderers[k];
    }
    initDomRenderer = true;
  }
  if (typeof tag === "function") {
    return new JSXFunctionNode(tag, props, children);
  } else if (components_exports[tag]) {
    return new JSXFunctionNode(
      components_exports[tag],
      props,
      children
    );
  } else if (tag === "svg" || tag === "head") {
    nameSpaceContext ||= createContext("");
    return new JSXNode(tag, props, [
      new JSXFunctionNode(
        nameSpaceContext,
        {
          value: tag
        },
        children
      )
    ]);
  } else {
    return new JSXNode(tag, props, children);
  }
};

// node_modules/hono/dist/jsx/jsx-dev-runtime.js
function jsxDEV(tag, props, key) {
  let node;
  if (!props || !("children" in props)) {
    node = jsxFn(tag, props, []);
  } else {
    const children = props.children;
    node = Array.isArray(children) ? jsxFn(tag, props, children) : jsxFn(tag, props, [children]);
  }
  node.key = key;
  return node;
}

// node_modules/@fiberplane/hono/dist/routes/playground.js
function createPlayground(sanitizedOptions) {
  const app = new Hono();
  const { cdn, mountedPath, openapi } = sanitizedOptions;
  const cssBundleUrl = new URL("index.css", cdn).href;
  const jsBundleUrl = new URL("index.js", cdn).href;
  app.get("/*", (c) => {
    return c.html(jsxDEV("html", { lang: "en", children: [jsxDEV("head", { children: [jsxDEV("title", { children: "API Playground" }), jsxDEV("meta", { charSet: "utf-8" }), jsxDEV("meta", { name: "viewport", content: "width=device-width, initial-scale=1" }), jsxDEV("link", { rel: "stylesheet", href: cssBundleUrl })] }), jsxDEV("body", { children: [jsxDEV("div", { id: "root", "data-options": JSON.stringify({
      mountedPath,
      openapi
    }) }), jsxDEV("script", { type: "module", src: jsBundleUrl })] })] }));
  });
  return app;
}

// node_modules/hono/dist/utils/cookie.js
var validCookieNameRegEx = /^[\w!#$%&'*.^`|~+-]+$/;
var validCookieValueRegEx = /^[ !#-:<-[\]-~]*$/;
var parse = (cookie, name) => {
  if (name && cookie.indexOf(name) === -1) {
    return {};
  }
  const pairs = cookie.trim().split(";");
  const parsedCookie = {};
  for (let pairStr of pairs) {
    pairStr = pairStr.trim();
    const valueStartPos = pairStr.indexOf("=");
    if (valueStartPos === -1) {
      continue;
    }
    const cookieName = pairStr.substring(0, valueStartPos).trim();
    if (name && name !== cookieName || !validCookieNameRegEx.test(cookieName)) {
      continue;
    }
    let cookieValue = pairStr.substring(valueStartPos + 1).trim();
    if (cookieValue.startsWith('"') && cookieValue.endsWith('"')) {
      cookieValue = cookieValue.slice(1, -1);
    }
    if (validCookieValueRegEx.test(cookieValue)) {
      parsedCookie[cookieName] = decodeURIComponent_(cookieValue);
      if (name) {
        break;
      }
    }
  }
  return parsedCookie;
};

// node_modules/hono/dist/helper/cookie/index.js
var getCookie = (c, key, prefix) => {
  const cookie = c.req.raw.headers.get("Cookie");
  if (typeof key === "string") {
    if (!cookie) {
      return void 0;
    }
    let finalKey = key;
    if (prefix === "secure") {
      finalKey = "__Secure-" + key;
    } else if (prefix === "host") {
      finalKey = "__Host-" + key;
    }
    const obj2 = parse(cookie, finalKey);
    return obj2[finalKey];
  }
  if (!cookie) {
    return {};
  }
  const obj = parse(cookie);
  return obj;
};

// node_modules/hono/dist/http-exception.js
var HTTPException = class extends Error {
  res;
  status;
  constructor(status = 500, options) {
    super(options?.message, { cause: options?.cause });
    this.res = options?.res;
    this.status = status;
  }
  getResponse() {
    if (this.res) {
      const newResponse = new Response(this.res.body, {
        status: this.status,
        headers: this.res.headers
      });
      return newResponse;
    }
    return new Response(this.message, {
      status: this.status
    });
  }
};

// node_modules/hono/dist/utils/buffer.js
var bufferToFormData = (arrayBuffer, contentType) => {
  const response = new Response(arrayBuffer, {
    headers: {
      "Content-Type": contentType
    }
  });
  return response.formData();
};

// node_modules/hono/dist/validator/validator.js
var jsonRegex = /^application\/([a-z-\.]+\+)?json(;\s*[a-zA-Z0-9\-]+\=([^;]+))*$/;
var multipartRegex = /^multipart\/form-data(;\s?boundary=[a-zA-Z0-9'"()+_,\-./:=?]+)?$/;
var urlencodedRegex = /^application\/x-www-form-urlencoded(;\s*[a-zA-Z0-9\-]+\=([^;]+))*$/;
var validator = (target, validationFunc) => {
  return async (c, next2) => {
    let value = {};
    const contentType = c.req.header("Content-Type");
    switch (target) {
      case "json":
        if (!contentType || !jsonRegex.test(contentType)) {
          break;
        }
        try {
          value = await c.req.json();
        } catch {
          const message = "Malformed JSON in request body";
          throw new HTTPException(400, { message });
        }
        break;
      case "form": {
        if (!contentType || !(multipartRegex.test(contentType) || urlencodedRegex.test(contentType))) {
          break;
        }
        let formData;
        if (c.req.bodyCache.formData) {
          formData = await c.req.bodyCache.formData;
        } else {
          try {
            const arrayBuffer = await c.req.arrayBuffer();
            formData = await bufferToFormData(arrayBuffer, contentType);
            c.req.bodyCache.formData = formData;
          } catch (e) {
            let message = "Malformed FormData request.";
            message += e instanceof Error ? ` ${e.message}` : ` ${String(e)}`;
            throw new HTTPException(400, { message });
          }
        }
        const form2 = {};
        formData.forEach((value2, key) => {
          if (key.endsWith("[]")) {
            ;
            (form2[key] ??= []).push(value2);
          } else if (Array.isArray(form2[key])) {
            ;
            form2[key].push(value2);
          } else if (key in form2) {
            form2[key] = [form2[key], value2];
          } else {
            form2[key] = value2;
          }
        });
        value = form2;
        break;
      }
      case "query":
        value = Object.fromEntries(
          Object.entries(c.req.queries()).map(([k, v]) => {
            return v.length === 1 ? [k, v[0]] : [k, v];
          })
        );
        break;
      case "param":
        value = c.req.param();
        break;
      case "header":
        value = c.req.header();
        break;
      case "cookie":
        value = getCookie(c);
        break;
    }
    const res = await validationFunc(value, c);
    if (res instanceof Response) {
      return res;
    }
    c.req.addValidatedData(target, res);
    await next2();
  };
};

// node_modules/@hono/standard-validator/dist/index.js
var sValidator = (target, schema, hook) => (
  // @ts-expect-error not typed well
  validator(target, async (value, c) => {
    const result = await schema["~standard"].validate(value);
    if (hook) {
      const hookResult = await hook(
        result.issues ? { data: value, error: result.issues, success: false, target } : { data: value, success: true, target },
        c
      );
      if (hookResult) {
        if (hookResult instanceof Response) {
          return hookResult;
        }
        if ("response" in hookResult) {
          return hookResult.response;
        }
      }
    }
    if (result.issues) {
      return c.json({ data: value, error: result.issues, success: false }, 400);
    }
    return result.value;
  })
);

// node_modules/json-schema-library/dist/module/lib/config/strings.js
var strings_default = {
  // validation errors
  AdditionalItemsError: "Array at `{{pointer}}` may not have an additional item `{{key}}`",
  AdditionalPropertiesError: "Additional property `{{property}}` on `{{pointer}}` does not match schema `{{schema}}`",
  AllOfError: "Value `{{value}}` at `{{pointer}}` does not match schema of `{{allOf}}`",
  AnyOfError: "Value `{{value}}` at `{{pointer}}` does not match any schema of `{{anyOf}}`",
  ConstError: "Expected value at `{{pointer}}` to be `{{expected}}`, but value given is `{{value}}`",
  containsAnyError: "The array at `{{pointer}}` must contain at least one item",
  ContainsArrayError: "The property at `{{pointer}}` must not be an array",
  ContainsError: "The array at `{{pointer}}` must contain an element that matches `{{schema}}`",
  ContainsMinError: "The array at `{{pointer}}` contains {{delta}} too few items matching `{{schema}}`",
  ContainsMaxError: "The array at `{{pointer}}` contains {{delta}} too many items matching `{{schema}}`",
  EnumError: "Expected given value `{{value}}` in `{{pointer}}` to be one of `{{values}}`",
  ForbiddenPropertyError: "Property name `{{property}}` at `{{pointer}}` is not allowed",
  FormatDateError: "Value `{{value}}` at `{{pointer}}` is not a valid date",
  FormatDateTimeError: "Value `{{value}}` at `{{pointer}}` is not a valid date-time",
  FormatDurationError: "Value `{{value}}` at `{{pointer}}` is not a valid duration",
  FormatEmailError: "Value `{{value}}` at `{{pointer}}` is not a valid email",
  FormatHostnameError: "Value `{{value}}` at `{{pointer}}` is not a valid hostname",
  FormatIPV4Error: "Value `{{value}}` at `{{pointer}}` is not a valid IPv4 address",
  FormatIPV4LeadingZeroError: "IPv4 addresses starting with zero are invalid, since they are interpreted as octals",
  FormatIPV6Error: "Value `{{value}}` at `{{pointer}}` is not a valid IPv6 address",
  FormatIPV6LeadingZeroError: "IPv6 addresses starting with zero are invalid, since they are interpreted as octals",
  FormatJsonPointerError: "Value `{{value}}` at `{{pointer}}` is not a valid json-pointer",
  FormatRegExError: "Value `{{value}}` at `{{pointer}}` is not a valid regular expression",
  FormatTimeError: "Value `{{value}}` at `{{pointer}}` is not a valid time",
  FormatURIError: "Value `{{value}}` at `{{pointer}}` is not a valid uri",
  FormatURIReferenceError: "Value `{{value}}` at `{{pointer}}` is not a valid uri-reference",
  FormatURITemplateError: "Value `{{value}}` at `{{pointer}}` is not a valid uri-template",
  FormatURLError: "Value `{{value}}` at `{{pointer}}` is not a valid url",
  FormatUUIDError: "Value `{{value}}` at `{{pointer}}` is not a valid uuid",
  InvalidDataError: "No value may be specified in `{{pointer}}`",
  InvalidPropertyNameError: "Invalid property name `{{property}}` at `{{pointer}}`",
  MaximumError: "Value in `{{pointer}}` is `{{length}}`, but should be `{{maximum}}` at maximum",
  MaxItemsError: "Too many items in `{{pointer}}`, should be `{{maximum}}` at most, but got `{{length}}`",
  MaxLengthError: "Value `{{pointer}}` should have a maximum length of `{{maxLength}}`, but got `{{length}}`.",
  MaxPropertiesError: "Too many properties in `{{pointer}}`, should be `{{maxProperties}}` at most, but got `{{length}}`",
  MinimumError: "Value in `{{pointer}}` is `{{length}}`, but should be `{{minimum}}` at minimum",
  MinItemsError: "Too few items in `{{pointer}}`, should be at least `{{minItems}}`, but got `{{length}}`",
  MinItemsOneError: "At least one item is required in `{{pointer}}`",
  MinLengthError: "Value `{{pointer}}` should have a minimum length of `{{minLength}}`, but got `{{length}}`.",
  MinLengthOneError: "A value is required in `{{pointer}}`",
  MinPropertiesError: "Too few properties in `{{pointer}}`, should be at least `{{minProperties}}`, but got `{{length}}`",
  MissingDependencyError: "The required propery '{{missingProperty}}' in `{{pointer}}` is missing",
  MissingOneOfPropertyError: "Value at `{{pointer}}` property: `{{property}}`",
  MultipleOfError: "Expected `{{value}}` in `{{pointer}}` to be multiple of `{{multipleOf}}`",
  MultipleOneOfError: "Value `{{value}}` should not match multiple schemas in oneOf `{{matches}}`",
  NoAdditionalPropertiesError: "Additional property `{{property}}` in `{{pointer}}` is not allowed",
  NotError: "Value `{{value}}` at pointer should not match schema `{{not}}`",
  OneOfError: "Value `{{value}}` in `{{pointer}}` does not match any given oneof schema",
  OneOfPropertyError: "Failed finding a matching oneOfProperty schema in `{{pointer}}` where `{{property}}` matches `{{value}}`",
  PatternError: "Value in `{{pointer}}` should match `{{description}}`, but received `{{received}}`",
  PatternPropertiesError: "Property `{{key}}` does not match any patterns in `{{pointer}}`. Valid patterns are: {{patterns}}",
  RequiredPropertyError: "The required property `{{key}}` is missing at `{{pointer}}`",
  SchemaWarning: "Failed retrieving a schema from '{{pointer}}' to key '{{key}}'",
  TypeError: "Expected `{{value}}` ({{received}}) in `{{pointer}}` to be of type `{{expected}}`",
  UndefinedValueError: "Value must not be undefined in `{{pointer}}`",
  UnevaluatedPropertyError: "Invalid unevaluated property `{{pointer}}`",
  UnevaluatedItemsError: "Invalid unevaluated item `{{pointer}}`",
  UniqueItemsError: "Items in array must be unique. Value `{{value}}` in `{{pointer}}` is a duplicate of {{duplicatePointer}}.",
  UnknownPropertyError: "Could not find a valid schema for property `{{pointer}}` within object",
  ValueNotEmptyError: "A value for `{{property}}` is required at `{{pointer}}`"
};

// node_modules/json-schema-library/dist/module/lib/getTypeOf.js
var toString = Object.prototype.toString;
function getTypeOf(value) {
  const type = toString.call(value).match(/\s([^\]]+)\]/).pop().toLowerCase();
  if (type === "file") {
    return "object";
  }
  return type;
}

// node_modules/json-schema-library/dist/module/lib/utils/render.js
var OBJECT_TYPE = "object";
var ARRAY_TYPE = "array";
function render(template, data = {}) {
  return template.replace(/\{\{\w+\}\}/g, (match) => {
    const key = match.replace(/[{}]/g, "");
    const variable = data[key];
    const variableType = getTypeOf(variable);
    if (variableType === OBJECT_TYPE || variableType === ARRAY_TYPE) {
      return JSON.stringify(variable);
    }
    return variable;
  });
}

// node_modules/json-schema-library/dist/module/lib/utils/__.js
function __(keyword, data, fallback = keyword) {
  var _a2;
  const template = (_a2 = strings_default[keyword]) !== null && _a2 !== void 0 ? _a2 : fallback;
  return render(template, data);
}

// node_modules/json-schema-library/dist/module/lib/utils/createCustomError.js
function dashCase(text) {
  return text.replace(/([a-z])([A-Z])/g, "$1-$2").toLowerCase();
}
function createError(name, data) {
  return {
    type: "error",
    name,
    code: dashCase(name),
    message: __(name, data),
    data
  };
}
function createCustomError(name) {
  return createError.bind(null, name);
}

// node_modules/json-schema-library/dist/module/lib/utils/flattenArray.js
function flattenArray(list, result = []) {
  for (let i = 0; i < list.length; i += 1) {
    const item = list[i];
    if (Array.isArray(item)) {
      flattenArray(item, result);
    } else {
      result.push(item);
    }
  }
  return result;
}

// node_modules/json-schema-library/dist/module/lib/config/settings.js
var settings_default = {
  DECLARATOR_ONEOF: "oneOfProperty",
  /** set to false to not set __oneOfIndex on returned schema */
  EXPOSE_ONE_OF_INDEX: true,
  GET_TEMPLATE_RECURSION_LIMIT: 1,
  propertyBlacklist: ["_id"],
  templateDefaultOptions: {
    addOptionalProps: false,
    removeInvalidData: false,
    extendDefaults: true
  }
};

// node_modules/json-schema-library/dist/module/lib/types.js
function isJsonError(error) {
  return (error === null || error === void 0 ? void 0 : error.type) === "error";
}

// node_modules/json-schema-library/dist/module/lib/utils/filter.js
function isPromise(obj) {
  return obj instanceof Promise;
}
function errorOrPromise(error) {
  return isJsonError(error) || isPromise(error);
}

// node_modules/json-schema-library/dist/module/lib/utils/isObject.js
function isObject(v) {
  return getTypeOf(v) === "object";
}

// node_modules/json-schema-library/dist/module/lib/features/oneOf.js
var { DECLARATOR_ONEOF, EXPOSE_ONE_OF_INDEX } = settings_default;
function setOneOfOrigin(schema, index3) {
  if (EXPOSE_ONE_OF_INDEX && isObject(schema)) {
    schema.__oneOfIndex = index3;
  }
}
function resolveOneOf(node, data) {
  const { schema, draft, pointer } = node;
  if (data != null && schema[DECLARATOR_ONEOF]) {
    const errors3 = [];
    const oneOfProperty = schema[DECLARATOR_ONEOF];
    const oneOfValue = data[schema[DECLARATOR_ONEOF]];
    if (oneOfValue === void 0) {
      return draft.errors.missingOneOfPropertyError({
        property: oneOfProperty,
        pointer,
        schema,
        value: data
      });
    }
    for (let i = 0; i < schema.oneOf.length; i += 1) {
      const oneNode = node.next(schema.oneOf[i]).resolveRef();
      const resultNode = draft.step(oneNode, oneOfProperty, data);
      if (isJsonError(resultNode)) {
        return resultNode;
      }
      let result = flattenArray(draft.validate(resultNode, oneOfValue));
      result = result.filter(errorOrPromise);
      if (result.length > 0) {
        errors3.push(...result);
      } else {
        setOneOfOrigin(oneNode.schema, i);
        return resultNode.next(oneNode.schema);
      }
    }
    return draft.errors.oneOfPropertyError({
      property: oneOfProperty,
      value: oneOfValue,
      pointer,
      schema,
      errors: errors3
    });
  }
  const matches = [];
  const errors2 = [];
  for (let i = 0; i < schema.oneOf.length; i += 1) {
    const oneNode = draft.resolveRef(node.next(schema.oneOf[i]));
    let result = flattenArray(draft.validate(oneNode, data));
    result = result.filter(errorOrPromise);
    if (result.length > 0) {
      errors2.push(...result);
    } else {
      matches.push({ index: i, schema: oneNode.schema });
    }
  }
  if (matches.length === 1) {
    setOneOfOrigin(matches[0].schema, matches[0].index);
    return node.next(matches[0].schema);
  }
  if (matches.length > 1) {
    return draft.errors.multipleOneOfError({
      value: data,
      pointer,
      schema,
      matches
    });
  }
  return draft.errors.oneOfError({
    value: JSON.stringify(data),
    pointer,
    schema,
    oneOf: schema.oneOf,
    errors: errors2
  });
}
function fuzzyObjectValue(node, data) {
  const { draft, schema, pointer } = node;
  if (data == null || schema.properties == null) {
    return -1;
  }
  let value = 0;
  const keys = Object.keys(schema.properties);
  for (let i = 0; i < keys.length; i += 1) {
    const key = keys[i];
    if (data[key]) {
      if (draft.isValid(data[key], schema.properties[key], pointer)) {
        value += 1;
      }
    }
  }
  return value;
}
function resolveOneOfFuzzy(node, data) {
  const { schema, pointer, draft } = node;
  if (!Array.isArray(schema.oneOf)) {
    throw new Error("not a oneof schema");
    return node;
  }
  if (data != null && schema[DECLARATOR_ONEOF]) {
    const errors2 = [];
    const oneOfProperty = schema[DECLARATOR_ONEOF];
    const oneOfValue = data[schema[DECLARATOR_ONEOF]];
    if (oneOfValue === void 0) {
      return draft.errors.missingOneOfPropertyError({
        property: oneOfProperty,
        pointer,
        schema,
        value: data
      });
    }
    for (let i = 0; i < schema.oneOf.length; i += 1) {
      const oneNode = draft.resolveRef(node.next(schema.oneOf[i]));
      const resultNode = draft.step(oneNode, oneOfProperty, data);
      if (isJsonError(resultNode)) {
        return resultNode;
      }
      let result = flattenArray(draft.validate(resultNode, oneOfValue));
      result = result.filter(errorOrPromise);
      if (result.length > 0) {
        errors2.push(...result);
      } else {
        setOneOfOrigin(oneNode.schema, i);
        return resultNode.next(oneNode.schema);
      }
    }
    return draft.errors.oneOfPropertyError({
      property: oneOfProperty,
      value: oneOfValue,
      pointer,
      schema,
      errors: errors2
    });
  }
  const matches = [];
  for (let i = 0; i < schema.oneOf.length; i += 1) {
    const oneNode = draft.resolveRef(node.next(schema.oneOf[i]));
    const one = oneNode.schema;
    if (draft.isValid(data, one, pointer)) {
      matches.push({ schema: one, index: i });
    }
  }
  if (matches.length === 1) {
    setOneOfOrigin(matches[0].schema, matches[0].index);
    return node.next(matches[0].schema);
  }
  if (isObject(data)) {
    let schemaOfItem;
    let schemaOfIndex = -1;
    let fuzzyGreatest = 0;
    for (let i = 0; i < schema.oneOf.length; i += 1) {
      const oneNode = draft.resolveRef(node.next(schema.oneOf[i]));
      const fuzzyValue = fuzzyObjectValue(oneNode, data);
      if (fuzzyGreatest < fuzzyValue) {
        fuzzyGreatest = fuzzyValue;
        schemaOfItem = oneNode.schema;
        schemaOfIndex = i;
      }
    }
    if (schemaOfItem === void 0) {
      return draft.errors.oneOfError({
        value: JSON.stringify(data),
        pointer,
        schema,
        oneOf: schema.oneOf
      });
    }
    setOneOfOrigin(schemaOfItem, schemaOfIndex);
    return node.next(schemaOfItem);
  }
  if (matches.length > 1) {
    return draft.errors.multipleOneOfError({ matches, pointer, schema, value: data });
  }
  return draft.errors.oneOfError({
    value: JSON.stringify(data),
    pointer,
    schema,
    oneOf: schema.oneOf
  });
}
var validateOneOf = (node, value) => {
  if (Array.isArray(node.schema.oneOf)) {
    const nodeOrError = node.draft.resolveOneOf(node, value);
    if (isJsonError(nodeOrError)) {
      return nodeOrError;
    }
  }
};

// node_modules/json-schema-library/dist/module/lib/mergeSchema.js
function mergeSchema(a, b, ...omit2) {
  if ((b === null || b === void 0 ? void 0 : b.type) === "error") {
    return b;
  } else if ((a === null || a === void 0 ? void 0 : a.type) === "error") {
    return a;
  }
  const aType = getTypeOf(a);
  const bType = getTypeOf(b);
  if (aType !== bType) {
    return a;
  }
  const schema = mergeSchema2(a, b);
  for (let i = 0; i < omit2.length; i += 1) {
    delete schema[omit2[i]];
  }
  return schema;
}
function mergeSchema2(a, b, property) {
  var _a2;
  if (isObject(a) && isObject(b)) {
    const newObject = {};
    [...Object.keys(a), ...Object.keys(b)].filter((item, index3, array) => array.indexOf(item) === index3).forEach((key) => newObject[key] = mergeSchema2(a[key], b[key], key));
    return newObject;
  }
  if (Array.isArray(a) && Array.isArray(b)) {
    if (property === "required") {
      return a.concat(b).filter((item, index3, array) => array.indexOf(item) === index3);
    }
    if (property === "items") {
      const result2 = [];
      for (let i = 0; i < b.length; i += 1) {
        if (isObject(a[i]) && isObject(b[i]) && a[i].type === b[i].type) {
          result2[i] = mergeSchema2(a[i], b[i]);
        } else {
          result2.push((_a2 = b[i]) !== null && _a2 !== void 0 ? _a2 : a[i]);
        }
      }
      return result2;
    }
    const result = [];
    const append = [];
    for (let i = 0; i < Math.max(a.length, b.length); i += 1) {
      if (isObject(a[i]) && isObject(b[i])) {
        result[i] = mergeSchema2(a[i], b[i]);
      } else {
        if (a[i] !== void 0 && b[i] !== void 0) {
          result[i] = a[i];
          append.push(b[i]);
        } else if (a[i] !== void 0) {
          result[i] = a[i];
        } else if (b[i] !== void 0) {
          append.push(b[i]);
        }
      }
    }
    return [...result, ...append].filter((item, index3, array) => array.indexOf(item) === index3);
  }
  if (Array.isArray(b)) {
    return b;
  }
  if (Array.isArray(a)) {
    return a;
  }
  if (b !== void 0) {
    return b;
  }
  return a;
}

// node_modules/json-schema-library/dist/module/lib/utils/omit.js
function omit(object, ...keysToOmit) {
  const result = {};
  Object.keys(object).forEach((key) => {
    if (!keysToOmit.includes(key)) {
      result[key] = object[key];
    }
  });
  return result;
}

// node_modules/json-schema-library/dist/module/lib/features/if.js
function resolveIfSchema(node, data) {
  if (node.schema.if == null) {
    return void 0;
  }
  if (node.schema.if === false) {
    return node.next(node.schema.else);
  }
  if (node.schema.if && (node.schema.then || node.schema.else)) {
    const ifNode = node.draft.resolveRef(node.next(node.schema.if));
    const ifErrors = node.draft.validate(ifNode, data);
    if (ifErrors.length === 0 && node.schema.then) {
      const thenNode = node.next(node.schema.then);
      return node.draft.resolveRef(thenNode);
    }
    if (ifErrors.length !== 0 && node.schema.else) {
      const elseNode = node.next(node.schema.else);
      return node.draft.resolveRef(elseNode);
    }
  }
  return void 0;
}
var validateIf = (node, value) => {
  const resolvedNode = resolveIfSchema(node, value);
  if (resolvedNode) {
    return node.draft.validate(resolvedNode, value);
  }
};

// node_modules/json-schema-library/dist/module/lib/utils/shallowCloneSchema.js
function shallowCloneSchemaNode(node) {
  return { ...node };
}

// node_modules/json-schema-library/dist/module/lib/features/allOf.js
function resolveSchema(node, data) {
  const ifSchema = resolveIfSchema(node, data);
  if (ifSchema) {
    return ifSchema;
  }
  const schema = shallowCloneSchemaNode(node.schema);
  return node.next(omit(schema, "if", "then", "else"));
}
function resolveAllOf(node, data) {
  const { schema } = node;
  let mergedSchema = shallowCloneSchemaNode(schema);
  for (let i = 0; i < schema.allOf.length; i += 1) {
    const allOfNode = node.next(schema.allOf[i]).resolveRef();
    const allOfSchema = resolveSchema(allOfNode, data).schema;
    mergedSchema = mergeSchema(mergedSchema, allOfSchema);
  }
  delete mergedSchema.allOf;
  return node.next(mergedSchema);
}
function mergeAllOfSchema(draft, schema) {
  const { allOf } = schema;
  if (!Array.isArray(allOf) || allOf.length === 0) {
    return;
  }
  let resolvedSchema = {};
  allOf.forEach((subschema) => {
    if (subschema == null) {
      return;
    }
    const subSchemaNode = draft.createNode(subschema).resolveRef();
    resolvedSchema = mergeSchema(resolvedSchema, subSchemaNode.schema);
  });
  return resolvedSchema;
}
var validateAllOf = (node, value) => {
  const { draft, schema } = node;
  const { allOf } = schema;
  if (!Array.isArray(allOf) || allOf.length === 0) {
    return;
  }
  const errors2 = [];
  schema.allOf.forEach((subSchema) => {
    errors2.push(...draft.validate(node.next(subSchema), value));
  });
  return errors2;
};

// node_modules/json-schema-library/dist/module/lib/schemaNode.js
function merge(schema, ...omit2) {
  if (schema == null) {
    throw new Error(`undefined schema`);
  }
  const node = this;
  const mergedSchema = mergeSchema(node.schema, schema, ...omit2);
  return { ...node, schema: mergedSchema, path: [...node.path, [node.pointer, node.schema]] };
}
function resolveRef() {
  const node = this;
  return node.draft.resolveRef(node);
}
function next(schema, key) {
  if (isJsonError(schema)) {
    return schema;
  }
  if (schema == null) {
    throw new Error(`undefined schema`);
  }
  if (!isObject(schema) && getTypeOf(schema) !== "boolean") {
    throw new Error(`bad schema type ${getTypeOf(schema)}`);
  }
  const node = this;
  return {
    ...node,
    pointer: key ? `${node.pointer}/${key}` : node.pointer,
    schema,
    path: [...node.path, [node.pointer, node.schema]]
  };
}
function isSchemaNode(value) {
  return isObject(value) && value.next && value.path && value.draft;
}
function createNode(draft, schema, pointer = "#") {
  return { draft, pointer, schema, path: [], next, merge, resolveRef };
}

// node_modules/json-schema-library/dist/module/lib/resolveRef.strict.js
function resolveRef2(node) {
  if (!isSchemaNode(node)) {
    throw new Error("schema node expected");
  }
  if (node.schema == null || node.schema.$ref == null) {
    return node;
  }
  if (node.schema.getRoot) {
    const resolvedSchema2 = node.schema.getRoot().getRef(node.schema);
    return node.next(resolvedSchema2);
  }
  const resolvedSchema = node.draft.rootSchema.getRef(node.schema);
  return node.next(resolvedSchema);
}

// node_modules/json-schema-library/dist/module/lib/resolveRef.js
function resolveRecursiveRef(node) {
  const history = node.path;
  let startIndex = 0;
  for (let i = history.length - 1; i >= 0; i--) {
    const step2 = history[i][1];
    if (step2.$id && /^https?:\/\//.test(step2.$id) && step2.$recursiveAnchor !== true) {
      startIndex = i;
      break;
    }
  }
  const firstAnchor = history.find((s, index3) => index3 >= startIndex && s[1].$recursiveAnchor === true);
  if (firstAnchor) {
    return node.next(firstAnchor[1]);
  }
  for (let i = history.length - 1; i >= 0; i--) {
    const step2 = history[i][1];
    if (step2.$id) {
      return node.next(step2);
    }
  }
  return node.next(node.draft.rootSchema);
}
function resolveRef3(node) {
  if (!isSchemaNode(node)) {
    throw new Error("expected node");
  }
  if (node.schema == null) {
    return node;
  }
  if (node.schema.$recursiveRef) {
    return resolveRef3(resolveRecursiveRef(node));
  }
  if (node.schema.$ref == null) {
    return node;
  }
  const resolvedSchema = node.draft.rootSchema.getRef(node.schema);
  if (resolvedSchema === false) {
    return node.next(resolvedSchema);
  }
  return node.merge(resolvedSchema, "$ref");
}

// node_modules/json-schema-library/dist/module/lib/utils/uniqueItems.js
function uniqueItems(list) {
  return list.filter((item, index3) => list.indexOf(item) === index3);
}

// node_modules/json-schema-library/dist/module/lib/features/dependencies.js
function resolveDependencies(node, data) {
  var _a2;
  const { schema } = node;
  const dependencies = (_a2 = schema.dependencies) !== null && _a2 !== void 0 ? _a2 : schema.dependentSchemas;
  if (!isObject(dependencies) || !isObject(data)) {
    return;
  }
  let updated = false;
  let resolvedSchema = { required: [] };
  Object.keys(dependencies).forEach((prop) => {
    var _a3, _b;
    if (data[prop] == null && !(((_a3 = schema.required) === null || _a3 === void 0 ? void 0 : _a3.includes(prop)) || ((_b = resolvedSchema.required) === null || _b === void 0 ? void 0 : _b.includes(prop)))) {
      return;
    }
    const dependency = dependencies[prop];
    if (Array.isArray(dependency)) {
      updated = true;
      resolvedSchema.required.push(...dependency);
      return;
    }
    if (isObject(dependency)) {
      updated = true;
      const dNode = node.next(dependency).resolveRef();
      resolvedSchema = mergeSchema(resolvedSchema, dNode.schema);
      return;
    }
  });
  if (updated) {
    resolvedSchema.required = uniqueItems(resolvedSchema.required);
    return resolvedSchema;
  }
}
var validateDependentRequired = (node, value) => {
  const { draft, schema, pointer } = node;
  const dependentRequired = schema.dependentRequired;
  if (!isObject(dependentRequired)) {
    return void 0;
  }
  const errors2 = [];
  Object.keys(value).forEach((property) => {
    const dependencies = dependentRequired[property];
    if (dependencies === true) {
      return;
    }
    if (dependencies === false) {
      errors2.push(draft.errors.missingDependencyError({ pointer, schema, value }));
      return;
    }
    if (!Array.isArray(dependencies)) {
      return;
    }
    for (let i = 0, l = dependencies.length; i < l; i += 1) {
      if (value[dependencies[i]] === void 0) {
        errors2.push(draft.errors.missingDependencyError({ missingProperty: dependencies[i], pointer, schema, value }));
      }
    }
  });
  return errors2;
};
var validateDependentSchemas = (node, value) => {
  const { draft, schema, pointer } = node;
  const dependentSchemas = schema.dependentSchemas;
  if (!isObject(dependentSchemas)) {
    return void 0;
  }
  const errors2 = [];
  Object.keys(value).forEach((property) => {
    const dependencies = dependentSchemas[property];
    if (dependencies === true) {
      return;
    }
    if (dependencies === false) {
      errors2.push(draft.errors.missingDependencyError({ pointer, schema, value }));
      return;
    }
    if (!isObject(dependencies)) {
      return;
    }
    draft.validate(node.next(dependencies), value).map((error) => errors2.push(error));
  });
  return errors2;
};
var validateDependencies = (node, value) => {
  const { draft, schema, pointer } = node;
  const dependencies = schema.dependencies;
  if (!isObject(dependencies)) {
    return void 0;
  }
  const errors2 = [];
  Object.keys(value).forEach((property) => {
    if (dependencies[property] === void 0) {
      return;
    }
    if (dependencies[property] === true) {
      return;
    }
    if (dependencies[property] === false) {
      errors2.push(draft.errors.missingDependencyError({ pointer, schema, value }));
      return;
    }
    let dependencyErrors;
    const type = getTypeOf(dependencies[property]);
    const propertyValue = dependencies[property];
    if (Array.isArray(propertyValue)) {
      dependencyErrors = propertyValue.filter((dependency) => value[dependency] === void 0).map((missingProperty) => draft.errors.missingDependencyError({ missingProperty, pointer, schema, value }));
    } else if (type === "object") {
      dependencyErrors = draft.validate(node.next(dependencies[property]), value);
    } else {
      throw new Error(`Invalid dependency definition for ${pointer}/${property}. Must be string[] or schema`);
    }
    errors2.push(...dependencyErrors);
  });
  return errors2.length > 0 ? errors2 : void 0;
};

// node_modules/json-schema-library/dist/module/lib/features/anyOf.js
function mergeValidAnyOfSchema(node, data) {
  const { draft, schema } = node;
  if (!Array.isArray(schema.anyOf) || schema.anyOf.length === 0) {
    return;
  }
  let resolvedSchema;
  schema.anyOf.forEach((anySchema) => {
    const anyNode = draft.resolveRef(node.next(anySchema));
    if (draft.validate(anyNode, data).length === 0) {
      resolvedSchema = resolvedSchema ? mergeSchema(resolvedSchema, anyNode.schema) : anyNode.schema;
    }
  });
  if (resolvedSchema) {
    return node.next(resolvedSchema);
  }
}
function resolveAnyOf(node, data) {
  const { anyOf } = node.schema;
  if (!Array.isArray(anyOf) || anyOf.length === 0) {
    return node;
  }
  const resolvedNode = mergeValidAnyOfSchema(node, data);
  if (resolvedNode) {
    const { pointer, schema } = node;
    return node.draft.errors.anyOfError({ pointer, schema, value: data, anyOf: JSON.stringify(anyOf) });
  }
  return node.merge(resolvedNode.schema, "anyOf");
}
var validateAnyOf = (node, value) => {
  const { draft, schema, pointer } = node;
  if (!Array.isArray(schema.anyOf) || schema.anyOf.length === 0) {
    return void 0;
  }
  for (let i = 0; i < schema.anyOf.length; i += 1) {
    const nextNode = draft.resolveRef(node.next(schema.anyOf[i]));
    if (draft.validate(nextNode, value).length === 0) {
      return void 0;
    }
  }
  return draft.errors.anyOfError({ pointer, schema, value, anyOf: schema.anyOf });
};

// node_modules/json-schema-library/dist/module/lib/resolveDynamicSchema.js
var toOmit = ["allOf", "anyOf", "oneOf", "dependencies", "if", "then", "else"];
var dynamicProperties = ["allOf", "anyOf", "oneOf", "dependencies", "if"];
function isDynamicSchema(schema) {
  const givenProps = Object.keys(schema);
  return dynamicProperties.findIndex((prop) => givenProps.includes(prop)) !== -1;
}
function resolveDynamicSchema(schemaNode, data) {
  let resolvedSchema;
  let error;
  const node = schemaNode.draft.resolveRef(schemaNode);
  const { draft } = node;
  const schema = isSchemaNode(node) ? node.schema : node;
  if (schema.oneOf) {
    const oneOfSchema = resolveOneOfFuzzy(node, data);
    if (isJsonError(oneOfSchema)) {
      error = oneOfSchema;
    } else if (oneOfSchema) {
      resolvedSchema = mergeSchema(resolvedSchema !== null && resolvedSchema !== void 0 ? resolvedSchema : {}, oneOfSchema.schema);
    }
  }
  if (Array.isArray(schema.allOf)) {
    const allOf = schema.allOf.map((s) => {
      if (isDynamicSchema(s)) {
        const result = resolveDynamicSchema(node.next(s), data);
        if (result == null || isJsonError(result)) {
          return result;
        }
        const finalSchema2 = mergeSchema(s, result.schema);
        return omit(finalSchema2, ...toOmit);
      }
      return s;
    });
    if (allOf.length > 0) {
      const allOfSchema = mergeAllOfSchema(draft, { allOf });
      resolvedSchema = mergeSchema(resolvedSchema !== null && resolvedSchema !== void 0 ? resolvedSchema : {}, allOfSchema);
    }
  }
  const anyNode = mergeValidAnyOfSchema(node, data);
  if (anyNode && anyNode.schema) {
    resolvedSchema = mergeSchema(resolvedSchema !== null && resolvedSchema !== void 0 ? resolvedSchema : {}, anyNode.schema);
  }
  const dependenciesSchema = resolveDependencies(node, data);
  if (dependenciesSchema) {
    resolvedSchema = mergeSchema(resolvedSchema !== null && resolvedSchema !== void 0 ? resolvedSchema : {}, dependenciesSchema);
  }
  const ifNodeResolved = resolveIfSchema(node, data);
  if (isSchemaNode(ifNodeResolved)) {
    resolvedSchema = mergeSchema(resolvedSchema !== null && resolvedSchema !== void 0 ? resolvedSchema : {}, ifNodeResolved.schema);
  }
  if (resolvedSchema == null) {
    return error;
  }
  if (isJsonError(resolvedSchema)) {
    return resolvedSchema;
  }
  const nestedSchema = resolveDynamicSchema(node.next(resolvedSchema), data);
  if (isSchemaNode(nestedSchema)) {
    resolvedSchema = mergeSchema(resolvedSchema, nestedSchema.schema);
  }
  const finalSchema = omit(resolvedSchema, ...toOmit);
  return node.next(finalSchema);
}

// node_modules/json-schema-library/dist/module/lib/reduceSchema.js
var toOmit2 = ["allOf", "anyOf", "oneOf", "dependencies", "if", "then", "else"];
function reduceSchema(node, data) {
  const resolvedSchema = resolveDynamicSchema(node, data);
  if (isSchemaNode(resolvedSchema)) {
    return node.merge(resolvedSchema.schema, ...toOmit2);
  }
  if (resolvedSchema) {
    return resolvedSchema;
  }
  return node;
}

// node_modules/fast-copy/dist/esm/index.mjs
var toStringFunction = Function.prototype.toString;
var create = Object.create;
var toStringObject = Object.prototype.toString;
var LegacyCache = (
  /** @class */
  function() {
    function LegacyCache2() {
      this._keys = [];
      this._values = [];
    }
    LegacyCache2.prototype.has = function(key) {
      return !!~this._keys.indexOf(key);
    };
    LegacyCache2.prototype.get = function(key) {
      return this._values[this._keys.indexOf(key)];
    };
    LegacyCache2.prototype.set = function(key, value) {
      this._keys.push(key);
      this._values.push(value);
    };
    return LegacyCache2;
  }()
);
function createCacheLegacy() {
  return new LegacyCache();
}
function createCacheModern() {
  return /* @__PURE__ */ new WeakMap();
}
var createCache = typeof WeakMap !== "undefined" ? createCacheModern : createCacheLegacy;
function getCleanClone(prototype) {
  if (!prototype) {
    return create(null);
  }
  var Constructor = prototype.constructor;
  if (Constructor === Object) {
    return prototype === Object.prototype ? {} : create(prototype);
  }
  if (Constructor && ~toStringFunction.call(Constructor).indexOf("[native code]")) {
    try {
      return new Constructor();
    } catch (_a2) {
    }
  }
  return create(prototype);
}
function getRegExpFlagsLegacy(regExp) {
  var flags = "";
  if (regExp.global) {
    flags += "g";
  }
  if (regExp.ignoreCase) {
    flags += "i";
  }
  if (regExp.multiline) {
    flags += "m";
  }
  if (regExp.unicode) {
    flags += "u";
  }
  if (regExp.sticky) {
    flags += "y";
  }
  return flags;
}
function getRegExpFlagsModern(regExp) {
  return regExp.flags;
}
var getRegExpFlags = /test/g.flags === "g" ? getRegExpFlagsModern : getRegExpFlagsLegacy;
function getTagLegacy(value) {
  var type = toStringObject.call(value);
  return type.substring(8, type.length - 1);
}
function getTagModern(value) {
  return value[Symbol.toStringTag] || getTagLegacy(value);
}
var getTag = typeof Symbol !== "undefined" ? getTagModern : getTagLegacy;
var defineProperty = Object.defineProperty;
var getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
var getOwnPropertyNames = Object.getOwnPropertyNames;
var getOwnPropertySymbols = Object.getOwnPropertySymbols;
var _a = Object.prototype;
var hasOwnProperty = _a.hasOwnProperty;
var propertyIsEnumerable = _a.propertyIsEnumerable;
var SUPPORTS_SYMBOL = typeof getOwnPropertySymbols === "function";
function getStrictPropertiesModern(object) {
  return getOwnPropertyNames(object).concat(getOwnPropertySymbols(object));
}
var getStrictProperties = SUPPORTS_SYMBOL ? getStrictPropertiesModern : getOwnPropertyNames;
function copyOwnPropertiesStrict(value, clone, state) {
  var properties = getStrictProperties(value);
  for (var index3 = 0, length_1 = properties.length, property = void 0, descriptor = void 0; index3 < length_1; ++index3) {
    property = properties[index3];
    if (property === "callee" || property === "caller") {
      continue;
    }
    descriptor = getOwnPropertyDescriptor(value, property);
    if (!descriptor) {
      clone[property] = state.copier(value[property], state);
      continue;
    }
    if (!descriptor.get && !descriptor.set) {
      descriptor.value = state.copier(descriptor.value, state);
    }
    try {
      defineProperty(clone, property, descriptor);
    } catch (error) {
      clone[property] = descriptor.value;
    }
  }
  return clone;
}
function copyArrayLoose(array, state) {
  var clone = new state.Constructor();
  state.cache.set(array, clone);
  for (var index3 = 0, length_2 = array.length; index3 < length_2; ++index3) {
    clone[index3] = state.copier(array[index3], state);
  }
  return clone;
}
function copyArrayStrict(array, state) {
  var clone = new state.Constructor();
  state.cache.set(array, clone);
  return copyOwnPropertiesStrict(array, clone, state);
}
function copyArrayBuffer(arrayBuffer, _state) {
  return arrayBuffer.slice(0);
}
function copyBlob(blob, _state) {
  return blob.slice(0, blob.size, blob.type);
}
function copyDataView(dataView, state) {
  return new state.Constructor(copyArrayBuffer(dataView.buffer));
}
function copyDate(date, state) {
  return new state.Constructor(date.getTime());
}
function copyMapLoose(map, state) {
  var clone = new state.Constructor();
  state.cache.set(map, clone);
  map.forEach(function(value, key) {
    clone.set(key, state.copier(value, state));
  });
  return clone;
}
function copyMapStrict(map, state) {
  return copyOwnPropertiesStrict(map, copyMapLoose(map, state), state);
}
function copyObjectLooseLegacy(object, state) {
  var clone = getCleanClone(state.prototype);
  state.cache.set(object, clone);
  for (var key in object) {
    if (hasOwnProperty.call(object, key)) {
      clone[key] = state.copier(object[key], state);
    }
  }
  return clone;
}
function copyObjectLooseModern(object, state) {
  var clone = getCleanClone(state.prototype);
  state.cache.set(object, clone);
  for (var key in object) {
    if (hasOwnProperty.call(object, key)) {
      clone[key] = state.copier(object[key], state);
    }
  }
  var symbols = getOwnPropertySymbols(object);
  for (var index3 = 0, length_3 = symbols.length, symbol = void 0; index3 < length_3; ++index3) {
    symbol = symbols[index3];
    if (propertyIsEnumerable.call(object, symbol)) {
      clone[symbol] = state.copier(object[symbol], state);
    }
  }
  return clone;
}
var copyObjectLoose = SUPPORTS_SYMBOL ? copyObjectLooseModern : copyObjectLooseLegacy;
function copyObjectStrict(object, state) {
  var clone = getCleanClone(state.prototype);
  state.cache.set(object, clone);
  return copyOwnPropertiesStrict(object, clone, state);
}
function copyPrimitiveWrapper(primitiveObject, state) {
  return new state.Constructor(primitiveObject.valueOf());
}
function copyRegExp(regExp, state) {
  var clone = new state.Constructor(regExp.source, getRegExpFlags(regExp));
  clone.lastIndex = regExp.lastIndex;
  return clone;
}
function copySelf(value, _state) {
  return value;
}
function copySetLoose(set, state) {
  var clone = new state.Constructor();
  state.cache.set(set, clone);
  set.forEach(function(value) {
    clone.add(state.copier(value, state));
  });
  return clone;
}
function copySetStrict(set, state) {
  return copyOwnPropertiesStrict(set, copySetLoose(set, state), state);
}
var isArray = Array.isArray;
var assign = Object.assign;
var getPrototypeOf = Object.getPrototypeOf || function(obj) {
  return obj.__proto__;
};
var DEFAULT_LOOSE_OPTIONS = {
  array: copyArrayLoose,
  arrayBuffer: copyArrayBuffer,
  blob: copyBlob,
  dataView: copyDataView,
  date: copyDate,
  error: copySelf,
  map: copyMapLoose,
  object: copyObjectLoose,
  regExp: copyRegExp,
  set: copySetLoose
};
var DEFAULT_STRICT_OPTIONS = assign({}, DEFAULT_LOOSE_OPTIONS, {
  array: copyArrayStrict,
  map: copyMapStrict,
  object: copyObjectStrict,
  set: copySetStrict
});
function getTagSpecificCopiers(options) {
  return {
    Arguments: options.object,
    Array: options.array,
    ArrayBuffer: options.arrayBuffer,
    Blob: options.blob,
    Boolean: copyPrimitiveWrapper,
    DataView: options.dataView,
    Date: options.date,
    Error: options.error,
    Float32Array: options.arrayBuffer,
    Float64Array: options.arrayBuffer,
    Int8Array: options.arrayBuffer,
    Int16Array: options.arrayBuffer,
    Int32Array: options.arrayBuffer,
    Map: options.map,
    Number: copyPrimitiveWrapper,
    Object: options.object,
    Promise: copySelf,
    RegExp: options.regExp,
    Set: options.set,
    String: copyPrimitiveWrapper,
    WeakMap: copySelf,
    WeakSet: copySelf,
    Uint8Array: options.arrayBuffer,
    Uint8ClampedArray: options.arrayBuffer,
    Uint16Array: options.arrayBuffer,
    Uint32Array: options.arrayBuffer,
    Uint64Array: options.arrayBuffer
  };
}
function createCopier(options) {
  var normalizedOptions = assign({}, DEFAULT_LOOSE_OPTIONS, options);
  var tagSpecificCopiers = getTagSpecificCopiers(normalizedOptions);
  var array = tagSpecificCopiers.Array, object = tagSpecificCopiers.Object;
  function copier(value, state) {
    state.prototype = state.Constructor = void 0;
    if (!value || typeof value !== "object") {
      return value;
    }
    if (state.cache.has(value)) {
      return state.cache.get(value);
    }
    state.prototype = getPrototypeOf(value);
    state.Constructor = state.prototype && state.prototype.constructor;
    if (!state.Constructor || state.Constructor === Object) {
      return object(value, state);
    }
    if (isArray(value)) {
      return array(value, state);
    }
    var tagSpecificCopier = tagSpecificCopiers[getTag(value)];
    if (tagSpecificCopier) {
      return tagSpecificCopier(value, state);
    }
    return typeof value.then === "function" ? value : object(value, state);
  }
  return function copy(value) {
    return copier(value, {
      Constructor: void 0,
      cache: createCache(),
      copier,
      prototype: void 0
    });
  };
}
function createStrictCopier(options) {
  return createCopier(assign({}, DEFAULT_STRICT_OPTIONS, options));
}
var copyStrict = createStrictCopier({});
var index = createCopier({});

// node_modules/json-schema-library/dist/module/lib/utils/copy.js
var copy_default = index;

// node_modules/json-schema-library/dist/module/lib/draft/index.js
var Draft = class {
  constructor(config, schema) {
    this.remotes = {};
    this.errors = {};
    this.typeKeywords = {};
    this.validateKeyword = {};
    this.validateType = {};
    this.validateFormat = {};
    this.config = config;
    this.typeKeywords = copy_default(config.typeKeywords);
    this.validateKeyword = Object.assign({}, config.validateKeyword);
    this.validateType = Object.assign({}, config.validateType);
    this.validateFormat = Object.assign({}, config.validateFormat);
    this.errors = Object.assign({}, config.errors);
    this.setSchema(schema);
  }
  get rootSchema() {
    return this.__rootSchema;
  }
  set rootSchema(rootSchema) {
    if (rootSchema == null) {
      return;
    }
    this.__rootSchema = this.config.compileSchema(this, rootSchema);
  }
  /**
   * register a json-schema to be referenced from another json-schema
   * @param url - base-url of json-schema (aka id)
   * @param schema - json-schema root
   */
  addRemoteSchema(url, schema) {
    this.config.addRemoteSchema(this, url, schema);
  }
  compileSchema(schema) {
    var _a2;
    return this.config.compileSchema(this, schema, (_a2 = this.rootSchema) !== null && _a2 !== void 0 ? _a2 : schema);
  }
  createSchemaOf(data) {
    return this.config.createSchemaOf(data);
  }
  /**
   * Iterates over data, retrieving its schema
   *
   * @param data - the data to iterate
   * @param callback - will be called with (schema, data, pointer) on each item
   * @param [schema] - the schema matching the data. Defaults to rootSchema
   * @param [pointer] - pointer to current data. Default to rootPointer
   */
  each(data, callback, schema, pointer) {
    const node = this.createNode(schema !== null && schema !== void 0 ? schema : this.rootSchema, pointer);
    return this.config.each(node, data, callback);
  }
  eachSchema(callback, schema = this.rootSchema) {
    return this.config.eachSchema(schema, callback);
  }
  getChildSchemaSelection(property, schema) {
    return this.config.getChildSchemaSelection(this, property, schema);
  }
  /**
   * Returns the json-schema of a data-json-pointer.
   *
   * To resolve dynamic schema where the type of json-schema is evaluated by
   * its value, a data object has to be passed in options.
   *
   * Per default this function will return `undefined` for valid properties that
   * do not have a defined schema. Use the option `withSchemaWarning: true` to
   * receive an error with `code: schema-warning` containing the location of its
   * last evaluated json-schema.
   *
   * Notes
   *      - uses draft.step to walk through data and schema
   *
   * @param draft
   * @param pointer - json pointer in data to get the json schema for
   * @param [options.data] - the data object, which includes the json pointers value. This is optional, as
   *    long as no oneOf, anyOf, etc statement is part of the pointers schema
   * @param [options.schema] - the json schema to iterate. Defaults to draft.rootSchema
   * @param [options.withSchemaWarning] - if true returns an error instead of `undefined` for valid properties missing a schema definition
   * @return resolved json-schema object of requested json-pointer location
   */
  getSchema(options) {
    const result = this.getSchemaNode(options);
    if (isSchemaNode(result)) {
      return result.schema;
    }
    return result;
  }
  getSchemaNode(options) {
    return this.config.getSchema(this, options);
  }
  /**
   * Create data object matching the given schema
   *
   * @param [data] - optional template data
   * @param [schema] - json schema, defaults to rootSchema
   * @return created template data
   */
  getTemplate(data, schema, opts = this.config.templateDefaultOptions) {
    return this.config.getTemplate(this, data, schema, opts);
  }
  isValid(data, schema, pointer) {
    return this.config.isValid(this, data, schema, pointer);
  }
  createNode(schema, pointer = "#") {
    return this.config.createNode(this, schema, pointer);
  }
  resolveAnyOf(node, data) {
    return this.config.resolveAnyOf(node, data);
  }
  resolveAllOf(node, data) {
    return this.config.resolveAllOf(node, data);
  }
  resolveRef(node) {
    return this.config.resolveRef(node);
  }
  resolveOneOf(node, data) {
    return this.config.resolveOneOf(node, data);
  }
  setSchema(schema) {
    this.rootSchema = schema;
  }
  /**
   * Returns the json-schema of the given object property or array item.
   * e.g. it steps by one key into the data
   *
   * This helper determines the location of the property within the schema (additional properties, oneOf, ...) and
   * returns the correct schema.
   *
   * @param  node
   * @param  key       - property-name or array-index
   * @param  data      - parent of key
   * @return schema-node containing child schema or error if failed resolving key
   */
  step(node, key, data) {
    return this.config.step(node, key, data);
  }
  validate(data, schema = this.rootSchema, pointer) {
    if (isSchemaNode(data)) {
      const inputData = schema;
      const inuptNode = data;
      return this.config.validate(inuptNode, inputData);
    }
    if (isJsonError(data)) {
      return [data];
    }
    const node = this.createNode(schema, pointer);
    return this.config.validate(node, data);
  }
};

// node_modules/json-schema-library/dist/module/lib/draft04/addRemoteSchema.js
function addRemoteSchema(draft, url, schema) {
  schema.id = schema.id || url;
  draft.remotes[url] = draft.compileSchema(schema);
}

// node_modules/json-schema-library/dist/module/lib/eachSchema.js
function eachProperty(property, schema, callback, pointer) {
  const target = schema[property];
  if (!isObject(target)) {
    return;
  }
  Object.keys(target).forEach((key) => {
    if (Array.isArray(target[key])) {
      return;
    }
    if (key === "$defs") {
      eachProperty("$defs", target[key], callback, `${pointer}/${property}/$defs`);
    } else {
      eachSchema(target[key], callback, `${pointer}/${property}/${key}`);
    }
  });
}
function eachItem(property, schema, callback, pointer) {
  const target = schema[property];
  if (!Array.isArray(target)) {
    return;
  }
  target.forEach((s, key) => eachSchema(s, callback, `${pointer}/${property}/${key}`));
}
function eachSchema(schema, callback, pointer = "") {
  if (schema === void 0) {
    return;
  }
  if (callback(schema, pointer) === true) {
    return;
  }
  if (!isObject(schema)) {
    return;
  }
  eachProperty("properties", schema, callback, pointer);
  eachProperty("patternProperties", schema, callback, pointer);
  eachSchema(schema.not, callback, `${pointer}/not`);
  eachSchema(schema.additionalProperties, callback, `${pointer}/additionalProperties`);
  eachProperty("dependencies", schema, callback, pointer);
  isObject(schema.items) && eachSchema(schema.items, callback, `${pointer}/items`);
  eachItem("items", schema, callback, pointer);
  eachSchema(schema.additionalItems, callback, `${pointer}/additionalItems`);
  eachItem("allOf", schema, callback, pointer);
  eachItem("anyOf", schema, callback, pointer);
  eachItem("oneOf", schema, callback, pointer);
  eachSchema(schema.if, callback, `${pointer}/if`);
  eachSchema(schema.then, callback, `${pointer}/then`);
  eachSchema(schema.else, callback, `${pointer}/else`);
  eachProperty("definitions", schema, callback, pointer);
  eachProperty("$defs", schema, callback, pointer);
}

// node_modules/json-schema-library/dist/module/lib/compile/joinScope.js
var suffixes = /(#)+$/;
var trailingHash = /#$/;
var startingHashAndSlash = /^[#/]+/;
var isDomain = /^[^:]+:\/\/[^/]+\//;
var trailingFragments = /\/[^/]*$/;
var idAndPointer = /#.*$/;
var isURN = /^urn:uuid:[0-9A-Fa-f]/;
function joinScope(previous, id) {
  if (previous == null && id == null) {
    return "#";
  }
  if (id == null) {
    return previous.replace(trailingHash, "");
  }
  if (isURN.test(id)) {
    return id;
  }
  if (previous == null || previous === "" || previous === "#") {
    return id.replace(trailingHash, "");
  }
  if (id[0] === "#") {
    return `${previous.replace(idAndPointer, "")}${id.replace(suffixes, "")}`;
  }
  if (isDomain.test(id)) {
    return id.replace(trailingHash, "");
  }
  if (isDomain.test(previous) && id.startsWith("/")) {
    return `${previous.replace(/(^[^:]+:\/\/[^/]+)(.*)/, "$1")}/${id.replace(startingHashAndSlash, "")}`;
  }
  return `${previous.replace(trailingFragments, "")}/${id.replace(startingHashAndSlash, "")}`;
}

// node_modules/json-schema-library/dist/module/lib/compile/getRef.js
var import_json_pointer = __toESM(require_jsonPointer());

// node_modules/json-schema-library/dist/module/lib/compile/splitRef.js
var suffixes2 = /(#)+$/g;
var emptyValues = ["", null, "#"];
function splitRef($ref) {
  if (emptyValues.includes($ref)) {
    return [];
  }
  $ref = $ref.replace(suffixes2, "");
  if ($ref.indexOf("#") === -1) {
    return [$ref.replace(/(#|\/)+$/g, "")];
  }
  if ($ref.indexOf("#") === 0) {
    return [$ref.replace(suffixes2, "")];
  }
  const result = $ref.split("#");
  result[0] = result[0].replace(/(#|\/)+$/g, "");
  result[1] = `#${result[1].replace(suffixes2, "")}`;
  return result;
}

// node_modules/json-schema-library/dist/module/lib/compile/getRef.js
var suffixes3 = /(#)+$/g;
var isObject2 = (val) => getTypeOf(val) === "object";
function getRef(context, rootSchema, $search) {
  var _a2, _b, _c, _d, _e;
  let $ref;
  if (isObject2($search)) {
    $ref = $search.__ref || $search.$ref;
  } else {
    $ref = $search;
  }
  if ($ref == null) {
    return rootSchema;
  }
  let schema;
  const $remote = $ref.replace(suffixes3, "");
  if (context.remotes[$remote] != null) {
    schema = context.remotes[$remote];
    if (schema && schema.$ref) {
      return getRef(context, schema, schema);
    }
    return schema;
  }
  const $anchor = (_a2 = context.anchors) === null || _a2 === void 0 ? void 0 : _a2[$ref];
  if ($anchor) {
    return (0, import_json_pointer.get)(rootSchema, $anchor);
  }
  if (context.ids[$ref] != null) {
    schema = (0, import_json_pointer.get)(rootSchema, context.ids[$ref]);
    if (schema && schema.$ref) {
      return getRef(context, rootSchema, schema);
    }
    return schema;
  }
  const $inputRef = $ref;
  const fragments = splitRef($ref);
  if (fragments.length === 0) {
    return rootSchema;
  }
  if (fragments.length === 1) {
    $ref = fragments[0];
    if (context.remotes[$ref]) {
      schema = context.remotes[$ref];
      if (schema && schema.$ref) {
        return getRef(context, rootSchema, schema);
      }
    }
    if (context.ids[$ref]) {
      schema = (0, import_json_pointer.get)(rootSchema, context.ids[$ref]);
      if (schema && schema.$ref) {
        return getRef(context, rootSchema, schema);
      }
      return schema;
    }
    const rootContextRef = (_b = rootSchema.getContext) === null || _b === void 0 ? void 0 : _b.call(rootSchema).ids[$ref];
    if (rootContextRef) {
      return getRef(context, rootSchema, rootContextRef);
    }
  }
  if (fragments.length === 2) {
    const base = fragments[0];
    $ref = fragments[1];
    const fromRemote = (_c = context.remotes[base]) !== null && _c !== void 0 ? _c : context.remotes[`${base}/`];
    if (fromRemote) {
      if (fromRemote.getContext && fromRemote.getContext().anchors[$inputRef] != null) {
        return fromRemote.getRef($inputRef);
      }
      if (fromRemote.getRef) {
        return fromRemote.getRef($ref);
      }
      return getRef(context, fromRemote, $ref);
    }
    const fromId = (_d = context.ids[base]) !== null && _d !== void 0 ? _d : context.ids[`${base}/`];
    if (fromId) {
      return getRef(context, (0, import_json_pointer.get)(rootSchema, fromId), $ref);
    }
  }
  schema = (0, import_json_pointer.get)(rootSchema, (_e = context.ids[$ref]) !== null && _e !== void 0 ? _e : $ref);
  if (schema && schema.$ref) {
    return getRef(context, rootSchema, schema);
  }
  return schema;
}

// node_modules/json-schema-library/dist/module/lib/compile/index.js
var import_json_pointer2 = __toESM(require_jsonPointer());
var COMPILED = "__compiled";
var COMPILED_REF = "__ref";
var GET_REF = "getRef";
var GET_ROOT = "getRoot";
var suffixes4 = /(#|\/)+$/g;
function compileSchema(draft, schemaToCompile, rootSchema = schemaToCompile, force = false) {
  if (!schemaToCompile || schemaToCompile[COMPILED] !== void 0) {
    return schemaToCompile;
  }
  const context = { ids: {}, remotes: draft.remotes };
  const rootSchemaAsString = JSON.stringify(schemaToCompile);
  const compiledSchema = JSON.parse(rootSchemaAsString);
  Object.defineProperties(compiledSchema, {
    // flag this schema as compiled
    [COMPILED]: { enumerable: false, value: true },
    // add getRef-helper to this object
    [GET_REF]: {
      enumerable: false,
      value: getRef.bind(null, context, compiledSchema)
    }
  });
  if (force === false && rootSchemaAsString.includes("$ref") === false) {
    return compiledSchema;
  }
  if (schemaToCompile !== rootSchema) {
    Object.defineProperty(compiledSchema, "definitions", {
      enumerable: false,
      value: Object.assign({}, rootSchema.definitions, rootSchema.$defs, schemaToCompile.definitions, schemaToCompile.$defs)
    });
  }
  const scopes = {};
  const getRoot = () => compiledSchema;
  eachSchema(compiledSchema, (schema, pointer) => {
    var _a2;
    if (schema.id) {
      if (schema.id.startsWith("http") && /(allOf|anyOf|oneOf)\/\d+$/.test(pointer)) {
        const parentPointer2 = pointer.replace(/\/(allOf|anyOf|oneOf)\/\d+$/, "");
        const parentSchema = (0, import_json_pointer2.get)(compiledSchema, parentPointer2);
        schema.id = (_a2 = parentSchema.id) !== null && _a2 !== void 0 ? _a2 : schema.id;
      }
      context.ids[schema.id.replace(suffixes4, "")] = pointer;
    }
    pointer = `#${pointer}`.replace(/##+/, "#");
    const previousPointer = pointer.replace(/\/[^/]+$/, "");
    const parentPointer = pointer.replace(/\/[^/]+\/[^/]+$/, "");
    const previousScope = scopes[previousPointer] || scopes[parentPointer];
    const scope = joinScope(previousScope, schema.id);
    scopes[pointer] = scope;
    if (context.ids[scope] == null) {
      context.ids[scope] = pointer;
    }
    if (schema.$ref && !schema[COMPILED_REF]) {
      Object.defineProperty(schema, COMPILED_REF, {
        enumerable: false,
        value: joinScope(scope, schema.$ref)
      });
      Object.defineProperty(schema, GET_ROOT, { enumerable: false, value: getRoot });
    }
  });
  return compiledSchema;
}

// node_modules/json-schema-library/dist/module/lib/createSchemaOf.js
function createSchemaOf(data) {
  if (data === void 0) {
    return void 0;
  }
  const schema = {
    type: getTypeOf(data)
  };
  if (schema.type === "object" && isObject(data)) {
    schema.properties = {};
    Object.keys(data).forEach((key) => schema.properties[key] = createSchemaOf(data[key]));
  }
  if (schema.type === "array" && Array.isArray(data)) {
    if (data.length === 1) {
      schema.items = createSchemaOf(data[0]);
    } else {
      schema.items = data.map(createSchemaOf);
    }
  }
  return schema;
}

// node_modules/json-schema-library/dist/module/lib/validation/errors.js
var errors = {
  additionalItemsError: createCustomError("AdditionalItemsError"),
  additionalPropertiesError: createCustomError("AdditionalPropertiesError"),
  allOfError: createCustomError("AllOfError"),
  anyOfError: createCustomError("AnyOfError"),
  constError: createCustomError("ConstError"),
  containsAnyError: createCustomError("ContainsAnyError"),
  containsArrayError: createCustomError("ContainsArrayError"),
  containsError: createCustomError("ContainsError"),
  containsMaxError: createCustomError("ContainsMaxError"),
  containsMinError: createCustomError("ContainsMinError"),
  enumError: createCustomError("EnumError"),
  forbiddenPropertyError: createCustomError("ForbiddenPropertyError"),
  formatDateError: createCustomError("FormatDateError"),
  formatDateTimeError: createCustomError("FormatDateTimeError"),
  formatDurationError: createCustomError("FormatDurationError"),
  formatEmailError: createCustomError("FormatEmailError"),
  formatHostnameError: createCustomError("FormatHostnameError"),
  formatIPV4Error: createCustomError("FormatIPV4Error"),
  formatIPV4LeadingZeroError: createCustomError("FormatIPV4LeadingZeroError"),
  formatIPV6Error: createCustomError("FormatIPV6Error"),
  formatIPV6LeadingZeroError: createCustomError("FormatIPV6LeadingZeroError"),
  formatJsonPointerError: createCustomError("FormatJsonPointerError"),
  formatRegExError: createCustomError("FormatRegExError"),
  formatTimeError: createCustomError("FormatTimeError"),
  formatURIError: createCustomError("FormatURIError"),
  formatURIReferenceError: createCustomError("FormatURIReferenceError"),
  formatURITemplateError: createCustomError("FormatURITemplateError"),
  formatURLError: createCustomError("FormatURLError"),
  formatUUIDError: createCustomError("FormatUUIDError"),
  invalidDataError: createCustomError("InvalidDataError"),
  invalidPropertyNameError: createCustomError("InvalidPropertyNameError"),
  invalidSchemaError: createCustomError("InvalidSchemaError"),
  invalidTypeError: createCustomError("InvalidTypeError"),
  maximumError: createCustomError("MaximumError"),
  maxItemsError: createCustomError("MaxItemsError"),
  maxLengthError: createCustomError("MaxLengthError"),
  maxPropertiesError: createCustomError("MaxPropertiesError"),
  minimumError: createCustomError("MinimumError"),
  minItemsError: createCustomError("MinItemsError"),
  minItemsOneError: createCustomError("MinItemsOneError"),
  minLengthError: createCustomError("MinLengthError"),
  minLengthOneError: createCustomError("MinLengthOneError"),
  minPropertiesError: createCustomError("MinPropertiesError"),
  missingDependencyError: createCustomError("MissingDependencyError"),
  missingOneOfPropertyError: createCustomError("MissingOneOfPropertyError"),
  multipleOfError: createCustomError("MultipleOfError"),
  multipleOneOfError: createCustomError("MultipleOneOfError"),
  noAdditionalPropertiesError: createCustomError("NoAdditionalPropertiesError"),
  notError: createCustomError("NotError"),
  oneOfError: createCustomError("OneOfError"),
  oneOfPropertyError: createCustomError("OneOfPropertyError"),
  patternError: createCustomError("PatternError"),
  patternPropertiesError: createCustomError("PatternPropertiesError"),
  requiredPropertyError: createCustomError("RequiredPropertyError"),
  schemaWarning: createCustomError("SchemaWarning"),
  typeError: createCustomError("TypeError"),
  undefinedValueError: createCustomError("UndefinedValueError"),
  unevaluatedItemsError: createCustomError("UnevaluatedItemsError"),
  unevaluatedPropertyError: createCustomError("UnevaluatedPropertyError"),
  uniqueItemsError: createCustomError("UniqueItemsError"),
  unknownPropertyError: createCustomError("UnknownPropertyError"),
  valueNotEmptyError: createCustomError("ValueNotEmptyError")
};
var errors_default = errors;

// node_modules/json-schema-library/dist/module/lib/validation/format.js
var import_valid_url = __toESM(require_valid_url());
var import_smtp_address_parser = __toESM(require_lib());
var isValidIPV4 = /^(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)$/;
var isValidIPV6 = /^((([0-9a-f]{1,4}:){7}([0-9a-f]{1,4}|:))|(([0-9a-f]{1,4}:){6}(:[0-9a-f]{1,4}|((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(([0-9a-f]{1,4}:){5}(((:[0-9a-f]{1,4}){1,2})|:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(([0-9a-f]{1,4}:){4}(((:[0-9a-f]{1,4}){1,3})|((:[0-9a-f]{1,4})?:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9a-f]{1,4}:){3}(((:[0-9a-f]{1,4}){1,4})|((:[0-9a-f]{1,4}){0,2}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9a-f]{1,4}:){2}(((:[0-9a-f]{1,4}){1,5})|((:[0-9a-f]{1,4}){0,3}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9a-f]{1,4}:){1}(((:[0-9a-f]{1,4}){1,6})|((:[0-9a-f]{1,4}){0,4}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(:(((:[0-9a-f]{1,4}){1,7})|((:[0-9a-f]{1,4}){0,5}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:)))$/i;
var isValidHostname = /^(?=.{1,255}$)[0-9A-Za-z](?:(?:[0-9A-Za-z]|-){0,61}[0-9A-Za-z])?(?:\.[0-9A-Za-z](?:(?:[0-9A-Za-z]|-){0,61}[0-9A-Za-z])?)*\.?$/;
var matchDate = /^(\d\d\d\d)-(\d\d)-(\d\d)$/;
var matchTime = /^(?<time>(?:([0-1]\d|2[0-3]):[0-5]\d:(?<second>[0-5]\d|60)))(?:\.\d+)?(?<offset>(?:z|[+-]([0-1]\d|2[0-3])(?::?[0-5]\d)?))$/i;
var DAYS = [0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
var isValidJsonPointer = /^(?:\/(?:[^~/]|~0|~1)*)*$/;
var isValidRelativeJsonPointer = /^(?:0|[1-9][0-9]*)(?:#|(?:\/(?:[^~/]|~0|~1)*)*)$/;
var isValidURIRef = /^(?:[a-z][a-z0-9+\-.]*:)?(?:\/?\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:]|%[0-9a-f]{2})*@)?(?:\[(?:(?:(?:(?:[0-9a-f]{1,4}:){6}|::(?:[0-9a-f]{1,4}:){5}|(?:[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){4}|(?:(?:[0-9a-f]{1,4}:){0,1}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){3}|(?:(?:[0-9a-f]{1,4}:){0,2}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){2}|(?:(?:[0-9a-f]{1,4}:){0,3}[0-9a-f]{1,4})?::[0-9a-f]{1,4}:|(?:(?:[0-9a-f]{1,4}:){0,4}[0-9a-f]{1,4})?::)(?:[0-9a-f]{1,4}:[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?))|(?:(?:[0-9a-f]{1,4}:){0,5}[0-9a-f]{1,4})?::[0-9a-f]{1,4}|(?:(?:[0-9a-f]{1,4}:){0,6}[0-9a-f]{1,4})?::)|[Vv][0-9a-f]+\.[a-z0-9\-._~!$&'()*+,;=:]+)\]|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)|(?:[a-z0-9\-._~!$&'"()*+,;=]|%[0-9a-f]{2})*)(?::\d*)?(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*|\/(?:(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*)?|(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*)?(?:\?(?:[a-z0-9\-._~!$&'"()*+,;=:@/?]|%[0-9a-f]{2})*)?(?:#(?:[a-z0-9\-._~!$&'"()*+,;=:@/?]|%[0-9a-f]{2})*)?$/i;
var isValidURITemplate = /^(?:(?:[^\x00-\x20"'<>%\\^`{|}]|%[0-9a-f]{2})|\{[+#./;?&=,!@|]?(?:[a-z0-9_]|%[0-9a-f]{2})+(?::[1-9][0-9]{0,3}|\*)?(?:,(?:[a-z0-9_]|%[0-9a-f]{2})+(?::[1-9][0-9]{0,3}|\*)?)*\})*$/i;
var isValidDurationString = /^P(?!$)(\d+Y)?(\d+M)?(\d+W)?(\d+D)?(T(?=\d)(\d+H)?(\d+M)?(\d+S)?)?$/;
var formatValidators = {
  date: (node, value) => {
    const { draft, schema, pointer } = node;
    if (typeof value !== "string" || value === "") {
      return void 0;
    }
    const matches = value.match(matchDate);
    if (!matches) {
      return draft.errors.formatDateTimeError({ value, pointer, schema });
    }
    const year = +matches[1];
    const month = +matches[2];
    const day = +matches[3];
    const isLeapYear = year % 4 === 0 && (year % 100 !== 0 || year % 400 === 0);
    if (month >= 1 && month <= 12 && day >= 1 && day <= (month == 2 && isLeapYear ? 29 : DAYS[month])) {
      return void 0;
    }
    return draft.errors.formatDateError({ value, pointer, schema });
  },
  "date-time": (node, value) => {
    const { draft, schema, pointer } = node;
    if (typeof value !== "string" || value === "") {
      return void 0;
    }
    const dateAndTime = value.split(/t/i);
    if (dateAndTime.length === 2) {
      const dateIsValid = formatValidators.date(node, dateAndTime[0]) === void 0;
      const timeIsValid = formatValidators.time(node, dateAndTime[1]) === void 0;
      if (dateIsValid && timeIsValid) {
        return void 0;
      }
    }
    return draft.errors.formatDateTimeError({ value, pointer, schema });
  },
  duration: (node, value) => {
    const type = getTypeOf(value);
    if (type !== "string") {
      return void 0;
    }
    const isInvalidDurationString = /(\d+M)(\d+W)|(\d+Y)(\d+W)/;
    if (!isValidDurationString.test(value) || isInvalidDurationString.test(value)) {
      return node.draft.errors.formatDurationError({
        value,
        pointer: node.pointer,
        schema: node.schema
      });
    }
  },
  email: (node, value) => {
    const { draft, schema, pointer } = node;
    if (typeof value !== "string" || value === "") {
      return void 0;
    }
    if (value[0] === '"') {
      return draft.errors.formatEmailError({ value, pointer, schema });
    }
    const [name, host, ...rest] = value.split("@");
    if (!name || !host || rest.length !== 0 || name.length > 64 || host.length > 253) {
      return draft.errors.formatEmailError({ value, pointer, schema });
    }
    if (name[0] === "." || name.endsWith(".") || name.includes("..")) {
      return draft.errors.formatEmailError({ value, pointer, schema });
    }
    if (!/^[a-z0-9.-]+$/i.test(host) || !/^[a-z0-9.!#$%&'*+/=?^_`{|}~-]+$/i.test(name)) {
      return draft.errors.formatEmailError({ value, pointer, schema });
    }
    if (!host.split(".").every((part) => /^[a-z0-9]([a-z0-9-]{0,61}[a-z0-9])?$/i.test(part))) {
      return draft.errors.formatEmailError({ value, pointer, schema });
    }
    return void 0;
  },
  /**
   * @draft 7
   * [RFC6531] https://json-schema.org/draft-07/json-schema-validation.html#RFC6531
   */
  "idn-email": (node, value) => {
    const { draft, schema, pointer } = node;
    if (typeof value !== "string" || value === "") {
      return void 0;
    }
    try {
      (0, import_smtp_address_parser.parse)(value);
      return void 0;
    } catch (e) {
      return draft.errors.formatEmailError({ value, pointer, schema });
    }
  },
  hostname: (node, value) => {
    const { draft, schema, pointer } = node;
    if (typeof value !== "string") {
      return void 0;
    }
    if (value === "" || isValidHostname.test(value)) {
      return void 0;
    }
    return draft.errors.formatHostnameError({ value, pointer, schema });
  },
  ipv4: (node, value) => {
    const { draft, schema, pointer } = node;
    if (typeof value !== "string" || value === "") {
      return void 0;
    }
    if (value && value[0] === "0") {
      return draft.errors.formatIPV4LeadingZeroError({ value, pointer, schema });
    }
    if (value.length <= 15 && isValidIPV4.test(value)) {
      return void 0;
    }
    return draft.errors.formatIPV4Error({ value, pointer, schema });
  },
  ipv6: (node, value) => {
    const { draft, schema, pointer } = node;
    if (typeof value !== "string" || value === "") {
      return void 0;
    }
    if (value && value[0] === "0") {
      return draft.errors.formatIPV6LeadingZeroError({ value, pointer, schema });
    }
    if (value.length <= 45 && isValidIPV6.test(value)) {
      return void 0;
    }
    return draft.errors.formatIPV6Error({ value, pointer, schema });
  },
  "json-pointer": (node, value) => {
    const { draft, schema, pointer } = node;
    if (typeof value !== "string" || value === "") {
      return void 0;
    }
    if (isValidJsonPointer.test(value)) {
      return void 0;
    }
    return draft.errors.formatJsonPointerError({ value, pointer, schema });
  },
  "relative-json-pointer": (node, value) => {
    const { draft, schema, pointer } = node;
    if (typeof value !== "string") {
      return void 0;
    }
    if (isValidRelativeJsonPointer.test(value)) {
      return void 0;
    }
    return draft.errors.formatJsonPointerError({ value, pointer, schema });
  },
  regex: (node, value) => {
    const { draft, schema, pointer } = node;
    if (typeof value === "string" && /\\Z$/.test(value) === false) {
      try {
        new RegExp(value);
        return void 0;
      } catch (e) {
      }
      return draft.errors.formatRegExError({ value, pointer, schema });
    }
    if (typeof value === "object" || typeof value === "number" || Array.isArray(value)) {
      return void 0;
    }
    return draft.errors.formatRegExError({ value, pointer, schema });
  },
  // hh:mm:ss.sTZD
  // RFC 3339 https://datatracker.ietf.org/doc/html/rfc3339#section-4
  time: (node, value) => {
    const { draft, schema, pointer } = node;
    if (typeof value !== "string" || value === "") {
      return void 0;
    }
    const matches = value.match(matchTime);
    if (!matches) {
      return draft.errors.formatDateTimeError({ value, pointer, schema });
    }
    if (matches.groups.second === "60") {
      if (/23:59:60(z|\+00:00)/i.test(value)) {
        return void 0;
      }
      const minutes = matches.groups.time.match(/(\d+):(\d+):/);
      const offsetMinutes = matches.groups.offset.match(/(\d+):(\d+)/);
      if (offsetMinutes) {
        const hour = parseInt(minutes[1]);
        const offsetHour = parseInt(offsetMinutes[1]);
        const min = parseInt(minutes[2]);
        const offsetMin = parseInt(offsetMinutes[2]);
        let deltaTime;
        if (/^-/.test(matches.groups.offset)) {
          deltaTime = (hour + offsetHour) * 60 + (min + offsetMin);
        } else {
          deltaTime = (24 + hour - offsetHour) * 60 + (min - offsetMin);
        }
        const hours = Math.floor(deltaTime / 60);
        const actualHour = hours % 24;
        const actualMinutes = deltaTime - hours * 60;
        if (actualHour === 23 && actualMinutes === 59) {
          return void 0;
        }
      }
      return draft.errors.formatDateTimeError({ value, pointer, schema });
    }
    return void 0;
  },
  uri: (node, value) => {
    const { draft, schema, pointer } = node;
    if (typeof value !== "string" || value === "") {
      return void 0;
    }
    if (import_valid_url.default.isUri(value)) {
      return void 0;
    }
    return draft.errors.formatURIError({ value, pointer, schema });
  },
  "uri-reference": (node, value) => {
    const { draft, schema, pointer } = node;
    if (typeof value !== "string" || value === "") {
      return void 0;
    }
    if (isValidURIRef.test(value)) {
      return void 0;
    }
    return draft.errors.formatURIReferenceError({ value, pointer, schema });
  },
  "uri-template": (node, value) => {
    const { draft, schema, pointer } = node;
    if (typeof value !== "string" || value === "") {
      return void 0;
    }
    if (isValidURITemplate.test(value)) {
      return void 0;
    }
    return draft.errors.formatURITemplateError({ value, pointer, schema });
  },
  url: (node, value) => {
    const { draft, schema, pointer } = node;
    if (value === "" || import_valid_url.default.isWebUri(value)) {
      return void 0;
    }
    return draft.errors.formatURLError({ value, pointer, schema });
  },
  uuid: (node, value) => {
    const { draft, schema, pointer } = node;
    if (typeof value !== "string" || value === "") {
      return void 0;
    }
    if (/^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i.test(value)) {
      return void 0;
    }
    return draft.errors.formatUUIDError({ value, pointer, schema });
  }
};
var format_default = formatValidators;

// node_modules/json-schema-library/dist/module/lib/getChildSchemaSelection.js
function getChildSchemaSelection(draft, property, schema = draft.rootSchema) {
  var _a2;
  if (schema.oneOf) {
    return schema.oneOf.map((item) => draft.createNode(item).resolveRef().schema);
  }
  if ((_a2 = schema.items) === null || _a2 === void 0 ? void 0 : _a2.oneOf) {
    return schema.items.oneOf.map((item) => draft.createNode(item).resolveRef().schema);
  }
  if (Array.isArray(schema.items) && schema.items.length > +property) {
    return [draft.step(draft.createNode(schema), property, {}).schema];
  }
  if (schema.additionalItems && !isObject(schema.items)) {
    const additionalSchema = schema.additionalItems === true ? { type: "string" } : schema.additionalItems;
    return [draft.createNode(additionalSchema).resolveRef().schema];
  }
  if (Array.isArray(schema.items) && schema.items.length <= +property) {
    return [];
  }
  const node = draft.step(draft.createNode(schema), property, {});
  if (isJsonError(node)) {
    const error = node;
    return error;
  }
  return [node.schema];
}

// node_modules/json-schema-library/dist/module/lib/getSchema.js
var import_json_pointer3 = __toESM(require_jsonPointer());
var emptyObject = {};
function getSchema(draft, options = emptyObject) {
  const { pointer = "#", data, schema = draft.rootSchema, withSchemaWarning = false } = options;
  const path = import_json_pointer3.default.split(pointer);
  const node = draft.createNode(schema).resolveRef();
  const result = _getSchema(node, path, data);
  if (!withSchemaWarning && isJsonError(result) && result.code === "schema-warning") {
    return draft.createNode(void 0);
  }
  return result;
}
function _getSchema(node, path, data = emptyObject) {
  if (path.length === 0) {
    return node.resolveRef();
  }
  const key = path.shift();
  const nextNode = node.draft.step(node, key, data);
  if (isJsonError(nextNode)) {
    return nextNode;
  }
  data = data[key];
  return _getSchema(nextNode, path, data);
}

// node_modules/json-schema-library/dist/module/lib/utils/merge.js
var import_deepmerge = __toESM(require_cjs());
var overwriteMerge = (destinationArray, sourceArray) => sourceArray;
var merge_default = (a, b) => (0, import_deepmerge.default)(a, b, { arrayMerge: overwriteMerge });

// node_modules/json-schema-library/dist/module/lib/utils/isEmpty.js
function isEmpty(v) {
  const type = getTypeOf(v);
  switch (type) {
    case "string":
    case "array":
      return (v === null || v === void 0 ? void 0 : v.length) === 0;
    case "null":
    case "undefined":
      return true;
    case "object":
      return Object.keys(v).length === 0;
    default:
      return false;
  }
}

// node_modules/json-schema-library/dist/module/lib/getTemplate.js
var defaultOptions = settings_default.templateDefaultOptions;
var cache;
function shouldResolveRef(schema, pointer) {
  const { $ref } = schema;
  if ($ref == null) {
    return true;
  }
  const value = cache[pointer] == null || cache[pointer][$ref] == null ? 0 : cache[pointer][$ref];
  return value < settings_default.GET_TEMPLATE_RECURSION_LIMIT;
}
function resolveRef4(draft, schema, pointer) {
  const { $ref } = schema;
  if ($ref == null) {
    return schema;
  }
  cache[pointer] = cache[pointer] || {};
  cache[pointer][$ref] = cache[pointer][$ref] || 0;
  cache[pointer][$ref] += 1;
  return draft.createNode(schema, pointer).resolveRef().schema;
}
function convertValue(type, value) {
  if (type === "string") {
    return JSON.stringify(value);
  } else if (typeof value !== "string") {
    return null;
  }
  try {
    value = JSON.parse(value);
    if (typeof value === type) {
      return value;
    }
  } catch (e) {
  }
  return null;
}
function createTemplateSchema(draft, schema, data, pointer, opts) {
  if (getTypeOf(schema) !== "object") {
    return Object.assign({ pointer }, schema);
  }
  if (shouldResolveRef(schema, pointer) === false && data == null) {
    return false;
  }
  let templateSchema = copy_default(resolveRef4(draft, schema, pointer));
  if (Array.isArray(schema.anyOf) && schema.anyOf.length > 0) {
    if (shouldResolveRef(schema.anyOf[0], `${pointer}/anyOf/0`)) {
      const resolvedAnyOf = resolveRef4(draft, schema.anyOf[0], `${pointer}/anyOf/0`);
      templateSchema = merge_default(templateSchema, resolvedAnyOf);
      templateSchema.pointer = schema.anyOf[0].$ref || templateSchema.pointer;
    }
    delete templateSchema.anyOf;
  }
  if (Array.isArray(schema.allOf)) {
    const mayResolve = schema.allOf.map((allOf, index3) => shouldResolveRef(allOf, `${pointer}/allOf/${index3}`)).reduceRight((next2, before) => next2 && before, true);
    if (mayResolve) {
      const allOf = [];
      let extendedData = copy_default(data);
      for (let i = 0; i < schema.allOf.length; i += 1) {
        const allNode = draft.createNode(schema.allOf[i], pointer);
        allOf.push(resolveSchema(allNode, extendedData).schema);
        extendedData = getTemplate(draft, extendedData, { type: schema.type, ...allOf[i] }, `${pointer}/allOf/${i}`, opts);
      }
      const resolvedSchema = mergeAllOfSchema(draft, { allOf });
      if (resolvedSchema) {
        templateSchema = mergeSchema(templateSchema, resolvedSchema);
      }
    }
  }
  templateSchema.pointer = templateSchema.pointer || schema.$ref || pointer;
  return templateSchema;
}
var isJsonSchema = (template) => template && typeof template === "object";
function getTemplate(draft, data, _schema, pointer, opts) {
  var _a2;
  if (_schema == null) {
    throw new Error(`getTemplate: missing schema for data: ${JSON.stringify(data)}`);
  }
  if (pointer == null) {
    throw new Error("Missing pointer");
  }
  let schema = createTemplateSchema(draft, _schema, data, pointer, opts);
  if (!isJsonSchema(schema)) {
    return void 0;
  }
  pointer = schema.pointer;
  if (schema === null || schema === void 0 ? void 0 : schema.const) {
    return schema.const;
  }
  if (Array.isArray(schema.oneOf)) {
    if (isEmpty(data)) {
      const type2 = schema.oneOf[0].type || schema.type || schema.const && typeof schema.const || getTypeOf(data);
      schema = { ...schema.oneOf[0], type: type2 };
    } else {
      const oneNode = draft.createNode(schema, pointer);
      const resolvedNode = resolveOneOfFuzzy(oneNode, data);
      if (isJsonError(resolvedNode)) {
        if (data != null && opts.removeInvalidData !== true) {
          return data;
        }
        schema = schema.oneOf[0];
        data = void 0;
      } else {
        const resolvedSchema = resolvedNode.schema;
        resolvedSchema.type = (_a2 = resolvedSchema.type) !== null && _a2 !== void 0 ? _a2 : schema.type;
        schema = resolvedSchema;
      }
    }
  }
  if (!isJsonSchema(schema) || schema.type == null) {
    return void 0;
  }
  if (data instanceof File) {
    return data;
  }
  const type = Array.isArray(schema.type) ? selectType(schema.type, data, schema.default) : schema.type;
  const javascriptTypeOfData = getTypeOf(data);
  if (data != null && javascriptTypeOfData !== type && !(javascriptTypeOfData === "number" && type === "integer")) {
    data = convertValue(type, data);
  }
  if (TYPE[type] == null) {
    if (opts.removeInvalidData) {
      return void 0;
    }
    return data;
  }
  const templateData = TYPE[type](draft, schema, data, pointer, opts);
  return templateData;
}
function selectType(types, data, defaultValue) {
  if (data == void 0) {
    if (defaultValue != null) {
      const defaultType = getTypeOf(defaultValue);
      if (types.includes(defaultType)) {
        return defaultType;
      }
    }
    return types[0];
  }
  const dataType = getTypeOf(data);
  if (types.includes(dataType)) {
    return dataType;
  }
  return types[0];
}
var TYPE = {
  null: (draft, schema, data) => getDefault(schema, data, null),
  string: (draft, schema, data) => getDefault(schema, data, ""),
  number: (draft, schema, data) => getDefault(schema, data, 0),
  integer: (draft, schema, data) => getDefault(schema, data, 0),
  boolean: (draft, schema, data) => getDefault(schema, data, false),
  object: (draft, schema, data, pointer, opts) => {
    var _a2;
    const template = schema.default === void 0 ? {} : schema.default;
    const d = {};
    const required = opts.extendDefaults === false && schema.default !== void 0 ? [] : (_a2 = schema.required) !== null && _a2 !== void 0 ? _a2 : [];
    if (schema.properties) {
      Object.keys(schema.properties).forEach((key) => {
        const value = data == null || data[key] == null ? template[key] : data[key];
        const isRequired = required.includes(key);
        if (value != null || isRequired || opts.addOptionalProps) {
          d[key] = getTemplate(draft, value, schema.properties[key], `${pointer}/properties/${key}`, opts);
        }
      });
    }
    const dNode = draft.createNode(schema, pointer);
    let dependenciesSchema = resolveDependencies(dNode, d);
    if (dependenciesSchema) {
      dependenciesSchema = mergeSchema(schema, dependenciesSchema);
      delete dependenciesSchema.dependencies;
      const dependencyData = getTemplate(draft, data, dependenciesSchema, `${pointer}/dependencies`, opts);
      Object.assign(d, dependencyData);
    }
    if (data) {
      if (opts.removeInvalidData === true && (schema.additionalProperties === false || getTypeOf(schema.additionalProperties) === "object")) {
        if (getTypeOf(schema.additionalProperties) === "object") {
          Object.keys(data).forEach((key) => {
            if (d[key] == null) {
              if (draft.isValid(data[key], schema.additionalProperties)) {
                d[key] = data[key];
              }
            }
          });
        }
      } else {
        Object.keys(data).forEach((key) => d[key] == null && (d[key] = data[key]));
      }
    }
    const node = draft.createNode(schema, pointer);
    const ifSchema = resolveIfSchema(node, d);
    if (isSchemaNode(ifSchema)) {
      const additionalData = getTemplate(draft, d, { type: "object", ...ifSchema.schema }, pointer, opts);
      Object.assign(d, additionalData);
    }
    return d;
  },
  // build array type of items, ignores additionalItems
  array: (draft, schema, data, pointer, opts) => {
    var _a2, _b, _c;
    const template = schema.default === void 0 ? [] : schema.default;
    const d = data || template;
    const minItems = opts.extendDefaults === false && schema.default !== void 0 ? 0 : (_a2 = schema.minItems) !== null && _a2 !== void 0 ? _a2 : 0;
    if (schema.items == null) {
      if (schema.additionalItems) {
        const itemCount = Math.max(minItems, d.length);
        for (let i = 0; i < itemCount; i += 1) {
          d[i] = getTemplate(draft, d[i], schema.additionalItems, `${pointer}/additionalItems`, opts);
        }
      }
      return data || [];
    }
    if (Array.isArray(schema.items)) {
      const length = Math.max(minItems !== null && minItems !== void 0 ? minItems : 0, (_c = (_b = schema.items) === null || _b === void 0 ? void 0 : _b.length) !== null && _c !== void 0 ? _c : 0);
      for (let i = 0; i < length; i += 1) {
        if (schema.items[i]) {
          d[i] = getTemplate(draft, d[i] == null ? template[i] : d[i], schema.items[i], `${pointer}/items/${i}`, opts);
        } else if (schema.additionalItems) {
          d[i] = getTemplate(draft, d[i] == null ? template[i] : d[i], schema.additionalItems, `${pointer}/additionalItems`, opts);
        }
      }
      return d;
    }
    if (getTypeOf(schema.items) !== "object") {
      return d;
    }
    const templateSchema = createTemplateSchema(draft, schema.items, data, pointer, opts);
    if (templateSchema === false) {
      return d;
    }
    pointer = templateSchema.pointer || pointer;
    if (templateSchema.oneOf && d.length === 0) {
      const oneOfSchema = templateSchema.oneOf[0];
      for (let i = 0; i < minItems; i += 1) {
        d[i] = getTemplate(draft, d[i] == null ? template[i] : d[i], oneOfSchema, `${pointer}/oneOf/0`, opts);
      }
      return d;
    }
    if (templateSchema.oneOf && d.length > 0) {
      const itemCount = Math.max(minItems, d.length);
      for (let i = 0; i < itemCount; i += 1) {
        let value = d[i] == null ? template[i] : d[i];
        const oneNode = draft.createNode(templateSchema, pointer);
        let one = resolveOneOfFuzzy(oneNode, value);
        if (one == null || isJsonError(one)) {
          if (value != null && opts.removeInvalidData !== true) {
            d[i] = value;
          } else {
            value = void 0;
            one = templateSchema.oneOf[0];
            d[i] = getTemplate(draft, value, one, `${pointer}/oneOf/${i}`, opts);
          }
        } else {
          d[i] = getTemplate(draft, value, one.schema, `${pointer}/oneOf/${i}`, opts);
        }
      }
      return d;
    }
    if (templateSchema.type) {
      for (let i = 0, l = Math.max(minItems, d.length); i < l; i += 1) {
        d[i] = getTemplate(draft, d[i] == null ? template[i] : d[i], templateSchema, `${pointer}/items`, opts);
      }
      return d;
    }
    return d;
  }
};
function getDefault(schema, templateValue, initValue) {
  if (templateValue != null) {
    return templateValue;
  } else if (schema.const) {
    return schema.const;
  } else if (schema.default === void 0 && Array.isArray(schema.enum)) {
    return schema.enum[0];
  } else if (schema.default === void 0) {
    return initValue;
  }
  return schema.default;
}
var getTemplate_default = (draft, data, schema = draft.rootSchema, opts) => {
  cache = {};
  if (opts) {
    return getTemplate(draft, data, schema, "#", { ...defaultOptions, ...opts });
  }
  return getTemplate(draft, data, schema, "#", defaultOptions);
};

// node_modules/json-schema-library/dist/module/lib/isValid.js
function isValid2(draft, value, schema = draft.rootSchema, pointer = "#") {
  const node = draft.createNode(schema, pointer);
  return draft.validate(node, value).length === 0;
}

// node_modules/json-schema-library/dist/module/lib/utils/punycode.ucs2decode.js
function ucs2decode(string) {
  const output = [];
  let counter = 0;
  const length = string.length;
  while (counter < length) {
    const value = string.charCodeAt(counter++);
    if (value >= 55296 && value <= 56319 && counter < length) {
      const extra = string.charCodeAt(counter++);
      if ((extra & 64512) == 56320) {
        output.push(((value & 1023) << 10) + (extra & 1023) + 65536);
      } else {
        output.push(value);
        counter--;
      }
    } else {
      output.push(value);
    }
  }
  return output;
}

// node_modules/json-schema-library/dist/module/lib/utils/getPrecision.js
function getPrecision(value) {
  const string = `${value}`;
  if (string.includes("e-")) {
    return parseInt(string.replace(/.*e-/, ""));
  }
  const index3 = string.indexOf(".");
  return index3 === -1 ? 0 : string.length - (index3 + 1);
}

// node_modules/json-schema-library/dist/module/lib/validation/keyword.js
var import_fast_deep_equal = __toESM(require_fast_deep_equal());
var hasOwnProperty2 = Object.prototype.hasOwnProperty;
var hasProperty = (value, property) => !(value[property] === void 0 || !hasOwnProperty2.call(value, property));
var KeywordValidation = {
  additionalProperties: (node, value) => {
    const { draft, schema, pointer } = node;
    if (schema.additionalProperties === true || schema.additionalProperties == null) {
      return void 0;
    }
    if (getTypeOf(schema.patternProperties) === "object" && schema.additionalProperties === false) {
      return void 0;
    }
    const errors2 = [];
    let receivedProperties = Object.keys(value).filter((prop) => settings_default.propertyBlacklist.includes(prop) === false);
    const expectedProperties = Object.keys(schema.properties || {});
    if (getTypeOf(schema.patternProperties) === "object") {
      const patterns = Object.keys(schema.patternProperties).map((pattern) => new RegExp(pattern));
      receivedProperties = receivedProperties.filter((prop) => {
        for (let i = 0; i < patterns.length; i += 1) {
          if (patterns[i].test(prop)) {
            return false;
          }
        }
        return true;
      });
    }
    for (let i = 0, l = receivedProperties.length; i < l; i += 1) {
      const property = receivedProperties[i];
      if (expectedProperties.indexOf(property) === -1) {
        const additionalIsObject = isObject(schema.additionalProperties);
        if (additionalIsObject && Array.isArray(schema.additionalProperties.oneOf)) {
          const result = draft.resolveOneOf(node.next(schema.additionalProperties), value[property]);
          if (isJsonError(result)) {
            errors2.push(draft.errors.additionalPropertiesError({
              pointer,
              schema: schema.additionalProperties,
              value,
              property: receivedProperties[i],
              properties: expectedProperties,
              // pass all validation errors
              errors: result.data.errors
            }));
          } else {
            errors2.push(...draft.validate(node.next(result, property), value[property]));
          }
        } else if (additionalIsObject) {
          const res = draft.validate(node.next(schema.additionalProperties, property), value[property]);
          errors2.push(...res);
        } else {
          errors2.push(draft.errors.noAdditionalPropertiesError({
            pointer,
            schema,
            value,
            property: receivedProperties[i],
            properties: expectedProperties
          }));
        }
      }
    }
    return errors2;
  },
  allOf: validateAllOf,
  anyOf: validateAnyOf,
  dependencies: validateDependencies,
  enum: (node, value) => {
    const { draft, schema, pointer } = node;
    const type = getTypeOf(value);
    if (type === "object" || type === "array") {
      const valueStr = JSON.stringify(value);
      for (let i = 0; i < schema.enum.length; i += 1) {
        if (JSON.stringify(schema.enum[i]) === valueStr) {
          return void 0;
        }
      }
    } else if (schema.enum.includes(value)) {
      return void 0;
    }
    return draft.errors.enumError({ pointer, schema, value, values: schema.enum });
  },
  format: (node, value) => {
    const { draft, schema } = node;
    if (draft.validateFormat[schema.format]) {
      const errors2 = draft.validateFormat[schema.format](node, value);
      return errors2;
    }
    return void 0;
  },
  items: (node, value) => {
    const { draft, schema, pointer } = node;
    if (schema.items === false) {
      if (Array.isArray(value) && value.length === 0) {
        return void 0;
      }
      return draft.errors.invalidDataError({ pointer, value, schema });
    }
    const errors2 = [];
    for (let i = 0; i < value.length; i += 1) {
      const itemData = value[i];
      const itemNode = draft.step(node.next(schema), i, value);
      if (isJsonError(itemNode)) {
        return [itemNode];
      }
      const itemErrors = draft.validate(itemNode, itemData);
      errors2.push(...itemErrors);
    }
    return errors2;
  },
  maximum: (node, value) => {
    const { draft, schema, pointer } = node;
    if (isNaN(schema.maximum)) {
      return void 0;
    }
    if (schema.maximum && schema.maximum < value) {
      return draft.errors.maximumError({
        maximum: schema.maximum,
        length: value,
        value,
        pointer,
        schema
      });
    }
    if (schema.maximum && schema.exclusiveMaximum === true && schema.maximum === value) {
      return draft.errors.maximumError({
        maximum: schema.maximum,
        length: value,
        pointer,
        schema,
        value
      });
    }
    return void 0;
  },
  maxItems: (node, value) => {
    const { draft, schema, pointer } = node;
    if (isNaN(schema.maxItems)) {
      return void 0;
    }
    if (schema.maxItems < value.length) {
      return draft.errors.maxItemsError({
        maximum: schema.maxItems,
        length: value.length,
        schema,
        value,
        pointer
      });
    }
    return void 0;
  },
  maxLength: (node, value) => {
    const { draft, schema, pointer } = node;
    if (isNaN(schema.maxLength)) {
      return void 0;
    }
    const lengthOfString = ucs2decode(value).length;
    if (schema.maxLength < lengthOfString) {
      return draft.errors.maxLengthError({
        maxLength: schema.maxLength,
        length: lengthOfString,
        pointer,
        schema,
        value
      });
    }
    return void 0;
  },
  maxProperties: (node, value) => {
    const { draft, schema, pointer } = node;
    const propertyCount = Object.keys(value).length;
    if (isNaN(schema.maxProperties) === false && schema.maxProperties < propertyCount) {
      return draft.errors.maxPropertiesError({
        maxProperties: schema.maxProperties,
        length: propertyCount,
        pointer,
        schema,
        value
      });
    }
    return void 0;
  },
  minLength: (node, value) => {
    const { draft, schema, pointer } = node;
    if (isNaN(schema.minLength)) {
      return void 0;
    }
    const lengthOfString = ucs2decode(value).length;
    if (schema.minLength > lengthOfString) {
      if (schema.minLength === 1) {
        return draft.errors.minLengthOneError({
          minLength: schema.minLength,
          length: lengthOfString,
          pointer,
          schema,
          value
        });
      }
      return draft.errors.minLengthError({
        minLength: schema.minLength,
        length: lengthOfString,
        pointer,
        schema,
        value
      });
    }
    return void 0;
  },
  minimum: (node, value) => {
    const { draft, schema, pointer } = node;
    if (isNaN(schema.minimum)) {
      return void 0;
    }
    if (schema.minimum > value) {
      return draft.errors.minimumError({
        minimum: schema.minimum,
        length: value,
        pointer,
        schema,
        value
      });
    }
    if (schema.exclusiveMinimum === true && schema.minimum === value) {
      return draft.errors.minimumError({
        minimum: schema.minimum,
        length: value,
        pointer,
        schema,
        value
      });
    }
    return void 0;
  },
  minItems: (node, value) => {
    const { draft, schema, pointer } = node;
    if (isNaN(schema.minItems)) {
      return void 0;
    }
    if (schema.minItems > value.length) {
      if (schema.minItems === 1) {
        return draft.errors.minItemsOneError({
          minItems: schema.minItems,
          length: value.length,
          pointer,
          schema,
          value
        });
      }
      return draft.errors.minItemsError({
        minItems: schema.minItems,
        length: value.length,
        pointer,
        schema,
        value
      });
    }
    return void 0;
  },
  minProperties: (node, value) => {
    const { draft, schema, pointer } = node;
    if (isNaN(schema.minProperties)) {
      return void 0;
    }
    const propertyCount = Object.keys(value).length;
    if (schema.minProperties > propertyCount) {
      return draft.errors.minPropertiesError({
        minProperties: schema.minProperties,
        length: propertyCount,
        pointer,
        schema,
        value
      });
    }
    return void 0;
  },
  multipleOf: (node, value) => {
    const { draft, schema, pointer } = node;
    if (isNaN(schema.multipleOf) || typeof value !== "number") {
      return void 0;
    }
    const valuePrecision = getPrecision(value);
    const multiplePrecision = getPrecision(schema.multipleOf);
    if (valuePrecision > multiplePrecision) {
      return draft.errors.multipleOfError({
        multipleOf: schema.multipleOf,
        value,
        pointer,
        schema
      });
    }
    const precision = Math.pow(10, multiplePrecision);
    const val = Math.round(value * precision);
    const multiple = Math.round(schema.multipleOf * precision);
    if (val % multiple / precision !== 0) {
      return draft.errors.multipleOfError({
        multipleOf: schema.multipleOf,
        value,
        pointer,
        schema
      });
    }
    return void 0;
  },
  not: (node, value) => {
    const { draft, schema, pointer } = node;
    const errors2 = [];
    if (draft.validate(node.next(schema.not), value).length === 0) {
      errors2.push(draft.errors.notError({ value, not: schema.not, pointer, schema }));
    }
    return errors2;
  },
  oneOf: validateOneOf,
  pattern: (node, value) => {
    const { draft, schema, pointer } = node;
    const pattern = new RegExp(schema.pattern, "u");
    if (pattern.test(value) === false) {
      return draft.errors.patternError({
        pattern: schema.pattern,
        description: schema.patternExample || schema.pattern,
        received: value,
        schema,
        value,
        pointer
      });
    }
    return void 0;
  },
  patternProperties: (node, value) => {
    const { draft, schema, pointer } = node;
    const properties = schema.properties || {};
    const pp = schema.patternProperties;
    if (getTypeOf(pp) !== "object") {
      return void 0;
    }
    const errors2 = [];
    const keys = Object.keys(value);
    const patterns = Object.keys(pp).map((expr) => ({
      regex: new RegExp(expr),
      patternSchema: pp[expr]
    }));
    keys.forEach((key) => {
      let patternFound = false;
      for (let i = 0, l = patterns.length; i < l; i += 1) {
        if (patterns[i].regex.test(key)) {
          patternFound = true;
          const valErrors = draft.validate(node.next(patterns[i].patternSchema, key), value[key]);
          if (valErrors && valErrors.length > 0) {
            errors2.push(...valErrors);
          }
        }
      }
      if (properties[key]) {
        return;
      }
      if (patternFound === false && schema.additionalProperties === false) {
        errors2.push(draft.errors.patternPropertiesError({
          key,
          pointer,
          schema,
          value,
          patterns: Object.keys(pp).join(",")
        }));
      }
    });
    return errors2;
  },
  properties: (node, value) => {
    const { draft, schema } = node;
    const errors2 = [];
    const keys = Object.keys(schema.properties || {});
    for (let i = 0; i < keys.length; i += 1) {
      const key = keys[i];
      if (hasProperty(value, key)) {
        const itemNode = draft.step(node, key, value);
        if (isJsonError(itemNode)) {
          errors2.push(itemNode);
        } else {
          const keyErrors = draft.validate(itemNode, value[key]);
          errors2.push(...keyErrors);
        }
      }
    }
    return errors2;
  },
  // @todo move to separate file: this is custom keyword validation for JsonEditor.properties keyword
  propertiesRequired: (node, value) => {
    const { draft, schema, pointer } = node;
    const errors2 = [];
    const keys = Object.keys(schema.properties || {});
    for (let i = 0; i < keys.length; i += 1) {
      const key = keys[i];
      if (value[key] === void 0) {
        errors2.push(draft.errors.requiredPropertyError({ key, pointer, schema, value }));
      } else {
        const itemNode = draft.step(node, key, value);
        const keyErrors = draft.validate(itemNode, value[key]);
        errors2.push(...keyErrors);
      }
    }
    return errors2;
  },
  required: (node, value) => {
    const { draft, schema, pointer } = node;
    if (Array.isArray(schema.required) === false) {
      return void 0;
    }
    return schema.required.map((property) => {
      if (!hasProperty(value, property)) {
        return draft.errors.requiredPropertyError({
          key: property,
          pointer,
          schema,
          value
        });
      }
      return void 0;
    });
  },
  // @todo move to separate file: this is custom keyword validation for JsonEditor.required keyword
  requiredNotEmpty: (node, value) => {
    const { schema } = node;
    if (Array.isArray(schema.required) === false) {
      return void 0;
    }
    return schema.required.map((property) => {
      const { draft, schema: schema2, pointer } = node;
      if (value[property] == null || value[property] === "") {
        return draft.errors.valueNotEmptyError({
          property,
          pointer: `${pointer}/${property}`,
          schema: schema2,
          value
        });
      }
      return void 0;
    });
  },
  uniqueItems: (node, value) => {
    const { draft, schema, pointer } = node;
    if ((Array.isArray(value) && schema.uniqueItems) === false) {
      return void 0;
    }
    const duplicates = [];
    const errors2 = [];
    value.forEach((item, index3) => {
      for (let i = index3 + 1; i < value.length; i += 1) {
        if ((0, import_fast_deep_equal.default)(item, value[i]) && !duplicates.includes(i)) {
          errors2.push(draft.errors.uniqueItemsError({
            pointer: `${pointer}/${i}`,
            duplicatePointer: `${pointer}/${index3}`,
            arrayPointer: pointer,
            value: JSON.stringify(item),
            schema
          }));
          duplicates.push(i);
        }
      }
    });
    return errors2;
  }
};
var keyword_default = KeywordValidation;

// node_modules/json-schema-library/dist/module/lib/step.js
var stepType = {
  array: (node, key, data) => {
    const { draft, schema, pointer } = node;
    const itemValue = data === null || data === void 0 ? void 0 : data[key];
    const itemsType = getTypeOf(schema.items);
    if (itemsType === "object") {
      return reduceSchema(node.next(schema.items, key), itemValue);
    }
    if (itemsType === "array") {
      if (schema.items[key] === true) {
        return node.next(createSchemaOf(itemValue), key);
      }
      if (schema.items[key] === false) {
        return draft.errors.invalidDataError({
          key,
          value: itemValue,
          pointer,
          schema
        });
      }
      if (schema.items[key]) {
        return draft.resolveRef(node.next(schema.items[key], key));
      }
      if (schema.additionalItems === false) {
        return draft.errors.additionalItemsError({
          key,
          value: itemValue,
          pointer,
          schema
        });
      }
      if (schema.additionalItems === true || schema.additionalItems === void 0) {
        return node.next(createSchemaOf(itemValue), key);
      }
      if (getTypeOf(schema.additionalItems) === "object") {
        return node.next(schema.additionalItems, key);
      }
      throw new Error(`Invalid schema ${JSON.stringify(schema, null, 2)} for ${JSON.stringify(data, null, 2)}`);
    }
    if (schema.additionalItems !== false && itemValue) {
      return node.next(createSchemaOf(itemValue), key);
    }
    return new Error(`Invalid array schema for ${key} at ${pointer}`);
  },
  object: (node, key, data) => {
    var _a2, _b;
    const { draft, pointer } = node;
    const reduction = reduceSchema(node, data);
    const schema = (_a2 = reduction.schema) !== null && _a2 !== void 0 ? _a2 : reduction;
    const property = (_b = schema === null || schema === void 0 ? void 0 : schema.properties) === null || _b === void 0 ? void 0 : _b[key];
    if (property !== void 0) {
      if (property === false) {
        return draft.errors.forbiddenPropertyError({
          property: key,
          value: data,
          pointer,
          schema
        });
      } else if (property === true) {
        return node.next(createSchemaOf(data === null || data === void 0 ? void 0 : data[key]), key);
      }
      const nextPropertyNode = draft.resolveRef(node.next(property, key));
      if (isJsonError(nextPropertyNode)) {
        return nextPropertyNode;
      }
      if (nextPropertyNode && Array.isArray(nextPropertyNode.schema.oneOf)) {
        const nextNode = node.next(nextPropertyNode.schema, key);
        const result = draft.resolveOneOf(nextNode, data[key]);
        if (isJsonError(result)) {
          return result;
        }
        return nextNode.merge(result.schema, "oneOf");
      }
      if (nextPropertyNode) {
        return nextPropertyNode;
      }
    }
    const { patternProperties } = schema;
    if (getTypeOf(patternProperties) === "object") {
      let regex;
      const patterns = Object.keys(patternProperties);
      for (let i = 0, l = patterns.length; i < l; i += 1) {
        regex = new RegExp(patterns[i]);
        if (regex.test(key)) {
          return node.next(patternProperties[patterns[i]], key);
        }
      }
    }
    const { additionalProperties } = schema;
    if (getTypeOf(additionalProperties) === "object") {
      return node.next(schema.additionalProperties, key);
    }
    if (data && (additionalProperties === void 0 || additionalProperties === true)) {
      const generatedSchema = createSchemaOf(data[key]);
      return generatedSchema ? node.next(generatedSchema, key) : void 0;
    }
    return draft.errors.unknownPropertyError({
      property: key,
      value: data,
      pointer: `${pointer}`,
      schema
    });
  }
};
function step(node, key, data) {
  var _a2;
  const { draft, schema, pointer } = node;
  const typeOfData = getTypeOf(data);
  let schemaType = (_a2 = schema.type) !== null && _a2 !== void 0 ? _a2 : typeOfData;
  if (Array.isArray(schemaType)) {
    if (!schemaType.includes(typeOfData)) {
      return draft.errors.typeError({
        value: data,
        pointer,
        expected: schema.type,
        received: typeOfData,
        schema
      });
    }
    schemaType = typeOfData;
  }
  const stepFunction = stepType[schemaType];
  if (stepFunction) {
    const childNode = stepFunction(node, `${key}`, data);
    if (childNode === void 0) {
      return draft.errors.schemaWarning({ pointer, value: data, schema, key });
    }
    return childNode;
  }
  return new Error(`Unsupported schema type ${schema.type} for key ${key}`);
}

// node_modules/json-schema-library/dist/module/lib/validation/type.js
var typeValidators = {
  array: (node, value) => node.draft.typeKeywords.array.filter((key) => node.schema && node.schema[key] != null).map((key) => node.draft.validateKeyword[key](node, value)),
  object: (node, value) => node.draft.typeKeywords.object.filter((key) => node.schema && node.schema[key] != null).map((key) => node.draft.validateKeyword[key](node, value)),
  string: (node, value) => node.draft.typeKeywords.string.filter((key) => node.schema && node.schema[key] != null).map((key) => node.draft.validateKeyword[key](node, value)),
  integer: (node, value) => node.draft.typeKeywords.number.filter((key) => node.schema && node.schema[key] != null).map((key) => node.draft.validateKeyword[key](node, value)),
  number: (node, value) => node.draft.typeKeywords.number.filter((key) => node.schema && node.schema[key] != null).map((key) => node.draft.validateKeyword[key](node, value)),
  boolean: (node, value) => node.draft.typeKeywords.boolean.filter((key) => node.schema && node.schema[key] != null).map((key) => node.draft.validateKeyword[key](node, value)),
  null: (node, value) => node.draft.typeKeywords.null.filter((key) => node.schema && node.schema[key] != null).map((key) => node.draft.validateKeyword[key](node, value))
};
var type_default = typeValidators;

// node_modules/json-schema-library/dist/module/lib/validate.js
var import_fast_deep_equal2 = __toESM(require_fast_deep_equal());
function getJsonSchemaType(value, expectedType) {
  const jsType = getTypeOf(value);
  if (jsType === "number" && (expectedType === "integer" || Array.isArray(expectedType) && expectedType.includes("integer"))) {
    return Number.isInteger(value) || isNaN(value) ? "integer" : "number";
  }
  return jsType;
}
function validate(node, value) {
  if (!isSchemaNode(node)) {
    throw new Error("node expected");
  }
  const { draft, pointer } = node;
  node = node.resolveRef();
  const schema = node.schema;
  if (schema == null) {
    throw new Error("missing schema");
  }
  if (getTypeOf(schema) === "boolean") {
    if (schema) {
      return [];
    }
    return [draft.errors.invalidDataError({ pointer, schema, value })];
  }
  if (isJsonError(schema)) {
    return [schema];
  }
  if (schema.const !== void 0) {
    if ((0, import_fast_deep_equal2.default)(schema.const, value)) {
      return [];
    }
    return [draft.errors.constError({ pointer, schema, value, expected: schema.const })];
  }
  const receivedType = getJsonSchemaType(value, schema.type);
  const expectedType = schema.type || receivedType;
  if (receivedType !== expectedType && (!Array.isArray(expectedType) || !expectedType.includes(receivedType))) {
    return [
      draft.errors.typeError({
        pointer,
        schema,
        value,
        received: receivedType,
        expected: expectedType
      })
    ];
  }
  if (draft.validateType[receivedType] == null) {
    return [draft.errors.invalidTypeError({ pointer, schema, value, receivedType })];
  }
  const errors2 = flattenArray(draft.validateType[receivedType](node, value));
  return errors2.filter(errorOrPromise);
}

// node_modules/json-schema-library/dist/module/lib/each.js
function each(schemaNode, data, callback) {
  const node = schemaNode.resolveRef();
  const { draft, schema, pointer } = node;
  callback(schema, data, pointer);
  const dataType = getTypeOf(data);
  if (dataType === "object") {
    Object.keys(data).forEach((key) => {
      const nextNode = draft.step(node, key, data);
      if (isSchemaNode(nextNode)) {
        each(nextNode, data[key], callback);
      }
    });
  } else if (dataType === "array") {
    data.forEach((next2, key) => {
      const nextNode = draft.step(node, key, data);
      if (isSchemaNode(nextNode)) {
        each(nextNode, data[key], callback);
      }
    });
  }
}

// node_modules/json-schema-library/dist/module/lib/draft04/index.js
var draft04Config = {
  typeKeywords: {
    array: [
      "allOf",
      "anyOf",
      "enum",
      "items",
      "maxItems",
      "minItems",
      "not",
      "oneOf",
      "uniqueItems"
    ],
    boolean: ["enum", "not", "allOf", "anyOf", "oneOf"],
    object: [
      "additionalProperties",
      "dependencies",
      "enum",
      "format",
      "minProperties",
      "maxProperties",
      "patternProperties",
      "properties",
      "required",
      "not",
      "oneOf",
      "allOf",
      "anyOf"
    ],
    string: [
      "allOf",
      "anyOf",
      "enum",
      "format",
      "maxLength",
      "minLength",
      "not",
      "oneOf",
      "pattern"
    ],
    number: [
      "allOf",
      "anyOf",
      "enum",
      "format",
      "maximum",
      "minimum",
      "multipleOf",
      "not",
      "oneOf"
    ],
    null: ["allOf", "anyOf", "enum", "format", "not", "oneOf"]
  },
  createNode,
  validateKeyword: keyword_default,
  validateType: type_default,
  validateFormat: format_default,
  errors: errors_default,
  addRemoteSchema,
  compileSchema,
  createSchemaOf,
  each,
  eachSchema,
  getChildSchemaSelection,
  getSchema,
  getTemplate: getTemplate_default,
  isValid: isValid2,
  resolveAllOf,
  resolveAnyOf,
  resolveOneOf,
  resolveRef: resolveRef2,
  step,
  validate,
  templateDefaultOptions: settings_default.templateDefaultOptions
};

// node_modules/json-schema-library/dist/module/lib/addRemoteSchema.js
function addRemoteSchema2(draft, url, schema) {
  schema.$id = schema.$id || url;
  draft.remotes[url] = draft.compileSchema(schema);
}

// node_modules/json-schema-library/dist/module/lib/draft06/compile/index.js
var import_json_pointer4 = __toESM(require_jsonPointer());
var COMPILED2 = "__compiled";
var COMPILED_REF2 = "__ref";
var GET_REF2 = "getRef";
var GET_ROOT2 = "getRoot";
var GET_CONTEXT = "getContext";
var suffixes5 = /(#|\/)+$/g;
function compileSchema2(draft, schemaToCompile, rootSchema = schemaToCompile, force = false) {
  if (schemaToCompile === true || schemaToCompile === false || schemaToCompile === void 0) {
    return schemaToCompile;
  }
  if (schemaToCompile[COMPILED2] !== void 0) {
    return schemaToCompile;
  }
  const context = { ids: {}, anchors: {}, remotes: draft.remotes };
  const rootSchemaAsString = JSON.stringify(schemaToCompile);
  const compiledSchema = JSON.parse(rootSchemaAsString);
  Object.defineProperties(compiledSchema, {
    [COMPILED2]: { enumerable: false, value: true },
    [GET_CONTEXT]: { enumerable: false, value: () => context },
    [GET_REF2]: {
      enumerable: false,
      value: getRef.bind(null, context, compiledSchema)
    }
  });
  if (force === false && rootSchemaAsString.includes("$ref") === false) {
    return compiledSchema;
  }
  if (compiledSchema !== rootSchema) {
    Object.defineProperty(compiledSchema, "$defs", {
      enumerable: true,
      value: Object.assign({}, rootSchema.definitions, rootSchema.$defs, compiledSchema.definitions, compiledSchema.$defs)
    });
  }
  const scopes = {};
  const getRoot = () => compiledSchema;
  eachSchema(compiledSchema, (schema, pointer) => {
    var _a2;
    if (schema.$id) {
      if (schema.$id.startsWith("http") && /(allOf|anyOf|oneOf|if)\/\d+$/.test(pointer)) {
        const parentPointer2 = pointer.replace(/\/(allOf|anyOf|oneOf|if)\/\d+$/, "");
        const parentSchema = (0, import_json_pointer4.get)(compiledSchema, parentPointer2);
        schema.$id = (_a2 = parentSchema.$id) !== null && _a2 !== void 0 ? _a2 : schema.$id;
      }
      context.ids[schema.$id.replace(suffixes5, "")] = pointer;
    }
    pointer = `#${pointer}`.replace(/##+/, "#");
    const previousPointer = pointer.replace(/\/[^/]+$/, "");
    const parentPointer = pointer.replace(/\/[^/]+\/[^/]+$/, "");
    const previousScope = scopes[previousPointer] || scopes[parentPointer];
    const scope = joinScope(previousScope, schema.$id);
    scopes[pointer] = scope;
    if (context.ids[scope] == null) {
      context.ids[scope] = pointer;
    }
    if (schema.$anchor) {
      context.anchors[`${scope}#${schema.$anchor}`] = pointer;
    }
    if (schema.$ref && !schema[COMPILED_REF2]) {
      Object.defineProperty(schema, COMPILED_REF2, {
        enumerable: false,
        value: joinScope(scope, schema.$ref)
      });
      Object.defineProperty(schema, GET_ROOT2, { enumerable: false, value: getRoot });
    }
  });
  return compiledSchema;
}

// node_modules/json-schema-library/dist/module/lib/draft06/validation/keyword.js
var KeywordValidation2 = {
  ...keyword_default,
  // @draft >= 6
  contains: (node, value) => {
    var _a2, _b;
    const { draft, schema, pointer } = node;
    if (schema.contains === false) {
      return draft.errors.containsArrayError({ pointer, value, schema });
    }
    if (schema.contains === true) {
      if (Array.isArray(value) && value.length === 0) {
        return draft.errors.containsAnyError({ pointer, value, schema });
      }
      return void 0;
    }
    if (getTypeOf(schema.contains) !== "object") {
      return void 0;
    }
    let count = 0;
    for (let i = 0; i < value.length; i += 1) {
      if (draft.validate(node.next(schema.contains, i), value[i]).length === 0) {
        count++;
      }
    }
    const max = (_a2 = schema.maxContains) !== null && _a2 !== void 0 ? _a2 : Infinity;
    const min = (_b = schema.minContains) !== null && _b !== void 0 ? _b : 1;
    if (max >= count && min <= count) {
      return void 0;
    }
    if (max < count) {
      return draft.errors.containsMaxError({ pointer, schema, delta: count - max, value });
    }
    if (min > count) {
      return draft.errors.containsMinError({ pointer, schema, delta: min - count, value });
    }
    return draft.errors.containsError({ pointer, schema, value });
  },
  exclusiveMaximum: (node, value) => {
    const { draft, schema, pointer } = node;
    if (isNaN(schema.exclusiveMaximum)) {
      return void 0;
    }
    if (schema.exclusiveMaximum <= value) {
      return draft.errors.maximumError({
        maximum: schema.exclusiveMaximum,
        length: value,
        pointer,
        schema,
        value
      });
    }
    return void 0;
  },
  exclusiveMinimum: (node, value) => {
    const { draft, schema, pointer } = node;
    if (isNaN(schema.exclusiveMinimum)) {
      return void 0;
    }
    if (schema.exclusiveMinimum >= value) {
      return draft.errors.minimumError({
        minimum: schema.exclusiveMinimum,
        length: value,
        pointer,
        schema,
        value
      });
    }
    return void 0;
  },
  // @feature if-then-else
  if: validateIf,
  maximum: (node, value) => {
    const { draft, schema, pointer } = node;
    if (isNaN(schema.maximum)) {
      return void 0;
    }
    if (schema.maximum && schema.maximum < value) {
      return draft.errors.maximumError({
        maximum: schema.maximum,
        length: value,
        pointer,
        schema,
        value
      });
    }
    return void 0;
  },
  minimum: (node, value) => {
    const { draft, schema, pointer } = node;
    if (isNaN(schema.minimum)) {
      return void 0;
    }
    if (schema.minimum > value) {
      return draft.errors.minimumError({
        minimum: schema.minimum,
        length: value,
        pointer,
        schema,
        value
      });
    }
    return void 0;
  },
  patternProperties: (node, value) => {
    const { draft, schema, pointer } = node;
    const properties = schema.properties || {};
    const pp = schema.patternProperties;
    if (getTypeOf(pp) !== "object") {
      return void 0;
    }
    const errors2 = [];
    const keys = Object.keys(value);
    const patterns = Object.keys(pp).map((expr) => ({
      regex: new RegExp(expr),
      patternSchema: pp[expr]
    }));
    keys.forEach((key) => {
      let patternFound = false;
      for (let i = 0, l = patterns.length; i < l; i += 1) {
        if (patterns[i].regex.test(key)) {
          patternFound = true;
          if (patterns[i].patternSchema === false) {
            errors2.push(draft.errors.patternPropertiesError({
              key,
              pointer,
              patterns: Object.keys(pp).join(","),
              schema,
              value
            }));
            return;
          }
          const valErrors = draft.validate(node.next(patterns[i].patternSchema, key), value[key]);
          if (valErrors && valErrors.length > 0) {
            errors2.push(...valErrors);
          }
        }
      }
      if (properties[key]) {
        return;
      }
      if (patternFound === false && schema.additionalProperties === false) {
        errors2.push(draft.errors.patternPropertiesError({
          key,
          pointer,
          patterns: Object.keys(pp).join(","),
          schema,
          value
        }));
      }
    });
    return errors2;
  },
  // @draft >= 6
  propertyNames: (node, value) => {
    const { draft, schema, pointer } = node;
    if (schema.propertyNames === false) {
      if (Object.keys(value).length === 0) {
        return void 0;
      }
      return draft.errors.invalidPropertyNameError({
        property: Object.keys(value),
        pointer,
        value,
        schema
      });
    }
    if (schema.propertyNames === true) {
      return void 0;
    }
    if (getTypeOf(schema.propertyNames) !== "object") {
      return void 0;
    }
    const errors2 = [];
    const properties = Object.keys(value);
    const propertySchema = { ...schema.propertyNames, type: "string" };
    properties.forEach((prop) => {
      const nextNode = node.next(propertySchema, prop);
      const validationResult = draft.validate(nextNode, prop);
      if (validationResult.length > 0) {
        errors2.push(draft.errors.invalidPropertyNameError({
          property: prop,
          pointer,
          validationError: validationResult[0],
          value: value[prop],
          schema
        }));
      }
    });
    return errors2;
  }
};
var keyword_default2 = KeywordValidation2;

// node_modules/json-schema-library/dist/module/lib/draft06/index.js
var draft06Config = {
  typeKeywords: {
    array: [
      "allOf",
      "anyOf",
      "contains",
      "enum",
      "if",
      "items",
      "maxItems",
      "minItems",
      "not",
      "oneOf",
      "uniqueItems"
    ],
    boolean: ["allOf", "anyOf", "enum", "not", "oneOf"],
    object: [
      "additionalProperties",
      "allOf",
      "anyOf",
      "dependencies",
      "enum",
      "format",
      "if",
      "maxProperties",
      "minProperties",
      "not",
      "oneOf",
      "patternProperties",
      "properties",
      "propertyNames",
      "required"
    ],
    string: [
      "allOf",
      "anyOf",
      "enum",
      "format",
      "if",
      "maxLength",
      "minLength",
      "not",
      "oneOf",
      "pattern"
    ],
    number: [
      "enum",
      "exclusiveMaximum",
      "exclusiveMinimum",
      "format",
      "maximum",
      "minimum",
      "multipleOf",
      "not",
      "oneOf",
      "allOf",
      "anyOf",
      "if"
    ],
    null: ["allOf", "anyOf", "enum", "format", "not", "oneOf"]
  },
  validateKeyword: keyword_default2,
  validateType: type_default,
  validateFormat: format_default,
  errors: errors_default,
  createNode,
  addRemoteSchema: addRemoteSchema2,
  compileSchema: compileSchema2,
  createSchemaOf,
  each,
  eachSchema,
  getChildSchemaSelection,
  getSchema,
  getTemplate: getTemplate_default,
  isValid: isValid2,
  resolveAllOf,
  resolveAnyOf,
  resolveOneOf,
  resolveRef: resolveRef2,
  step,
  validate,
  templateDefaultOptions: settings_default.templateDefaultOptions
};

// node_modules/json-schema-library/dist/module/lib/draft07/index.js
var draft07Config = {
  typeKeywords: {
    array: [
      "allOf",
      "anyOf",
      "contains",
      "enum",
      "if",
      "items",
      "maxItems",
      "minItems",
      "not",
      "oneOf",
      "uniqueItems"
    ],
    boolean: ["allOf", "anyOf", "enum", "not", "oneOf"],
    object: [
      "additionalProperties",
      "allOf",
      "anyOf",
      "dependencies",
      "enum",
      "format",
      "if",
      "maxProperties",
      "minProperties",
      "not",
      "oneOf",
      "patternProperties",
      "properties",
      "propertyNames",
      "required"
    ],
    string: [
      "allOf",
      "anyOf",
      "enum",
      "format",
      "if",
      "maxLength",
      "minLength",
      "not",
      "oneOf",
      "pattern"
    ],
    number: [
      "allOf",
      "anyOf",
      "enum",
      "exclusiveMaximum",
      "exclusiveMinimum",
      "format",
      "if",
      "maximum",
      "minimum",
      "multipleOf",
      "not",
      "oneOf"
    ],
    null: ["allOf", "anyOf", "enum", "format", "not", "oneOf"]
  },
  validateKeyword: keyword_default2,
  validateType: type_default,
  validateFormat: format_default,
  errors: errors_default,
  createNode,
  addRemoteSchema: addRemoteSchema2,
  compileSchema: compileSchema2,
  createSchemaOf,
  each,
  eachSchema,
  getChildSchemaSelection,
  getSchema,
  getTemplate: getTemplate_default,
  isValid: isValid2,
  resolveAllOf,
  resolveAnyOf,
  resolveOneOf,
  resolveRef: resolveRef2,
  step,
  validate,
  templateDefaultOptions: settings_default.templateDefaultOptions
};

// node_modules/json-schema-library/dist/module/lib/draft2019/validation/keyword.js
var getPatternTests = (patternProperties) => isObject(patternProperties) ? Object.keys(patternProperties).map((pattern) => new RegExp(pattern)) : [];
function isPropertyEvaluated(schemaNode, propertyName, value) {
  var _a2, _b;
  const node = schemaNode.draft.resolveRef(schemaNode);
  const { schema } = node;
  if (schema.additionalProperties === true) {
    return true;
  }
  if ((_a2 = schema.properties) === null || _a2 === void 0 ? void 0 : _a2[propertyName]) {
    const nextSchema = (_b = schema.properties) === null || _b === void 0 ? void 0 : _b[propertyName];
    if (node.draft.isValid(value, nextSchema)) {
      return true;
    }
  }
  const patterns = getPatternTests(schema.patternProperties);
  if (patterns.find((pattern) => pattern.test(propertyName))) {
    return true;
  }
  if (isObject(schema.additionalProperties)) {
    const nextSchema = schema.additionalProperties;
    return node.draft.validate(node.next(nextSchema), value);
  }
  return false;
}
var KeywordValidation3 = {
  // ...omit(Keywords, "dependencies"),
  ...keyword_default2,
  dependencies: void 0,
  dependentSchemas: validateDependentSchemas,
  dependentRequired: validateDependentRequired,
  /**
   * @draft >= 2019-09
   * Similar to additionalProperties, but can "see" into subschemas and across references
   * https://json-schema.org/draft/2019-09/json-schema-core#rfc.section.9.3.2.4
   */
  unevaluatedProperties: (node, value) => {
    var _a2;
    const { draft, schema, pointer } = node;
    if (!isObject(value) || schema.unevaluatedProperties == null) {
      return void 0;
    }
    let unevaluated = Object.keys(value);
    if (unevaluated.length === 0) {
      return void 0;
    }
    const reduction = reduceSchema(node, value);
    const resolvedSchema = (_a2 = reduction.schema) !== null && _a2 !== void 0 ? _a2 : reduction;
    if (resolvedSchema.unevaluatedProperties === true) {
      return void 0;
    }
    const testPatterns = getPatternTests(resolvedSchema.patternProperties);
    unevaluated = unevaluated.filter((key) => {
      var _a3;
      if ((_a3 = resolvedSchema.properties) === null || _a3 === void 0 ? void 0 : _a3[key]) {
        return false;
      }
      if (isObject(schema.if) && isPropertyEvaluated(node.next({ type: "object", ...schema.if }), key, value[key])) {
        return false;
      }
      if (testPatterns.find((pattern) => pattern.test(key))) {
        return false;
      }
      if (resolvedSchema.additionalProperties) {
        return false;
      }
      return true;
    });
    if (unevaluated.length === 0) {
      return void 0;
    }
    const errors2 = [];
    if (resolvedSchema.unevaluatedProperties === false) {
      unevaluated.forEach((key) => {
        errors2.push(draft.errors.unevaluatedPropertyError({
          pointer: `${pointer}/${key}`,
          value: JSON.stringify(value[key]),
          schema
        }));
      });
      return errors2;
    }
    unevaluated.forEach((key) => {
      if (isObject(resolvedSchema.unevaluatedProperties)) {
        const keyErrors = draft.validate(node.next(resolvedSchema.unevaluatedProperties, key), value[key]);
        errors2.push(...keyErrors);
      }
    });
    return errors2;
  },
  /**
   * @draft >= 2019-09
   * Similar to additionalItems, but can "see" into subschemas and across references
   * https://json-schema.org/draft/2019-09/json-schema-core#rfc.section.9.3.1.3
   */
  unevaluatedItems: (node, value) => {
    var _a2;
    const { draft, schema, pointer } = node;
    if (!Array.isArray(value) || value.length === 0 || schema.unevaluatedItems == null || schema.unevaluatedItems === true) {
      return void 0;
    }
    const reduction = reduceSchema(draft.resolveRef(node), value);
    const resolvedSchema = (_a2 = reduction.schema) !== null && _a2 !== void 0 ? _a2 : reduction;
    if (resolvedSchema.unevaluatedItems === true || resolvedSchema.additionalItems === true) {
      return void 0;
    }
    if (isObject(schema.if)) {
      const nextSchemaNode = { type: "array", ...schema.if };
      if (draft.isValid(value, nextSchemaNode)) {
        if (Array.isArray(nextSchemaNode.items) && nextSchemaNode.items.length === value.length) {
          return void 0;
        }
      }
    }
    if (isObject(resolvedSchema.items)) {
      const nextSchemaNode = { ...resolvedSchema, unevaluatedItems: void 0 };
      const errors3 = draft.validate(node.next(nextSchemaNode), value);
      return errors3.map((e) => draft.errors.unevaluatedItemsError({ ...e.data }));
    }
    if (Array.isArray(resolvedSchema.items)) {
      const items = [];
      for (let i = resolvedSchema.items.length; i < value.length; i += 1) {
        if (i < resolvedSchema.items.length) {
          if (draft.validate(node.next(resolvedSchema.items[i], i), value[i]).length > 0) {
            items.push({ index: i, value: value[i] });
          }
        } else {
          items.push({ index: i, value: value[i] });
        }
      }
      return items.map((item) => draft.errors.unevaluatedItemsError({
        pointer: `${pointer}/${item.index}`,
        value: JSON.stringify(item.value),
        schema: resolvedSchema.unevaluatedItems
      }));
    }
    if (isObject(resolvedSchema.unevaluatedItems)) {
      return value.map((item, index3) => {
        if (!draft.isValid(item, resolvedSchema.unevaluatedItems)) {
          return draft.errors.unevaluatedItemsError({
            pointer: `${pointer}/${index3}`,
            value: JSON.stringify(item),
            schema: resolvedSchema.unevaluatedItems
          });
        }
      });
    }
    const errors2 = [];
    value.forEach((item, index3) => {
      errors2.push(draft.errors.unevaluatedItemsError({
        pointer: `${pointer}/${index3}`,
        value: JSON.stringify(item),
        schema
      }));
    });
    return errors2;
  }
};
var keyword_default3 = KeywordValidation3;

// node_modules/json-schema-library/dist/module/lib/draft2019/index.js
var draft2019Config = {
  typeKeywords: {
    array: [
      "allOf",
      "anyOf",
      "contains",
      "enum",
      "if",
      "items",
      "maxItems",
      "minItems",
      "not",
      "oneOf",
      "unevaluatedItems",
      "uniqueItems"
    ],
    boolean: ["allOf", "anyOf", "enum", "not", "oneOf"],
    object: [
      "additionalProperties",
      "allOf",
      "anyOf",
      // "dependencies",
      "dependentSchemas",
      "dependentRequired",
      "enum",
      "format",
      "if",
      "maxProperties",
      "minProperties",
      "not",
      "oneOf",
      "patternProperties",
      "properties",
      "propertyNames",
      "required",
      "unevaluatedProperties"
      // 2019-09
    ],
    string: [
      "allOf",
      "anyOf",
      "enum",
      "format",
      "if",
      "maxLength",
      "minLength",
      "not",
      "oneOf",
      "pattern"
    ],
    number: [
      "allOf",
      "anyOf",
      "enum",
      "exclusiveMaximum",
      "exclusiveMinimum",
      "format",
      "if",
      "maximum",
      "minimum",
      "multipleOf",
      "not",
      "oneOf"
    ],
    null: ["allOf", "anyOf", "enum", "format", "not", "oneOf"]
  },
  validateKeyword: keyword_default3,
  validateType: type_default,
  validateFormat: format_default,
  errors: errors_default,
  createNode,
  addRemoteSchema: addRemoteSchema2,
  compileSchema: compileSchema2,
  createSchemaOf,
  each,
  eachSchema,
  getChildSchemaSelection,
  getSchema,
  getTemplate: getTemplate_default,
  isValid: isValid2,
  resolveAllOf,
  resolveAnyOf,
  resolveOneOf,
  resolveRef: resolveRef3,
  step,
  validate,
  templateDefaultOptions: settings_default.templateDefaultOptions
};
var Draft2019 = class extends Draft {
  constructor(schema, config = {}) {
    super(merge_default(draft2019Config, config), schema);
  }
};

// node_modules/json-schema-library/dist/module/lib/jsoneditor/index.js
var draftJsonEditorConfig = {
  ...draft07Config,
  resolveOneOf: resolveOneOfFuzzy,
  resolveRef: resolveRef3
};

// node_modules/@fiberplane/hono/dist/schemas/workflows.js
var StepParameterSchema = z.object({
  name: z.string().describe("Name of the parameter. Example: email"),
  in: z.enum(["query", "path", "header", "cookie"]).describe("Where the parameter is located. Example: query"),
  value: z.string().describe("Value or reference to input/previous step output. Example: $.inputs.userEmail")
});
var StepRequestBodySchema = z.object({
  contentType: z.enum([
    "application/json",
    "application/x-www-form-urlencoded",
    "multipart/form-data"
  ]).describe("The MIME type of the body of the request. Example: application/json"),
  payload: z.union([
    // JSON Object Example - direct object payload
    z.record(z.union([
      z.string(),
      z.number(),
      z.boolean(),
      z.null(),
      z.array(z.union([z.string(), z.number(), z.boolean(), z.null()])),
      z.record(z.union([z.string(), z.number(), z.boolean(), z.null()]))
    ])).describe("Direct JSON object payload"),
    // Complete Runtime Expression - string starting with $
    z.string().describe("Runtime expression reference"),
    // Form Data Example - record of primitive values
    z.record(z.union([z.string(), z.number(), z.boolean()])).describe("Form data payload")
  ]).describe("The payload of the request. Can be a direct JSON object, runtime expression, or form data."),
  replacements: z.array(z.object({
    target: z.string().describe("The target of the replacement - JSON pointer to the value to replace. Example: /email"),
    value: z.any().describe("The value to replace the target with. Example: test@example.com")
  })).describe("Replacements to make to the payload. Example: [{ target: '/email', value: 'test@example.com' }]")
});
var StepSuccessCriteriaSchema = z.object({
  condition: z.string().describe("Success condition expression. Example: $response.statusCode === 200")
});
var OutputSchema = z.object({
  key: z.string().describe("Output key name. Example: userId"),
  value: z.string().describe("Path to value in response. Example: $response.body#/data/id")
});
var StepSchema = z.object({
  stepId: z.string().describe("A unique identifier for this step. Example: create-user"),
  description: z.string().describe("What this step does. Example: Create a new user account in the database"),
  operation: z.object({
    method: z.enum([
      "get",
      "post",
      "put",
      "delete",
      "patch",
      "head",
      "options",
      "trace"
    ]).describe("The HTTP method to use for the operation. Example: post"),
    path: z.string().describe("The path to the operation. Example: /users")
  }),
  parameters: z.array(StepParameterSchema).default([]).describe("Parameters needed for the operation"),
  requestBody: StepRequestBodySchema.optional(),
  successCriteria: z.array(StepSuccessCriteriaSchema).default([]).describe("Conditions that must be met for the step to be considered successful"),
  outputs: z.array(OutputSchema).default([]).describe("Values to extract from the response for use in subsequent steps")
});
var BaseInputSchema = z.object({
  type: z.enum(["string", "number", "integer", "boolean", "object", "array"]),
  id: z.string().optional(),
  required: z.array(z.string()).optional().describe("Required properties of the input")
});
var InputSchema = BaseInputSchema.extend({
  properties: z.record(z.string(), z.lazy(() => InputSchema)).optional().describe("Properties of the input")
}).describe("JSON Schema definition");
var WorkflowSchema = z.object({
  workflowId: z.string().describe("A unique identifier for the workflow. Example: loginUserAndCreateWorkflow"),
  prompt: z.string().describe("Original user story/prompt. Example: Create a workflow that registers a new user"),
  summary: z.string().describe("A very short summary of what the workflow does (acts as a name). Example: Process new user registration"),
  description: z.string().describe("A detailed description of the workflow's purpose and steps. Example: Handles the complete user registration flow including account creation and welcome email"),
  steps: z.array(StepSchema).min(1).describe("The sequence of API operations to perform"),
  inputs: InputSchema,
  outputs: z.array(OutputSchema).default([]).describe("Final output values from the steps of the workflow"),
  createdAt: z.date(),
  updatedAt: z.date()
});
var GenerateWorkflowRequestSchema = z.object({
  prompt: z.string(),
  openApiSchema: z.string()
});

// node_modules/@fiberplane/hono/dist/utils/env.js
function getFromEnv(honoEnv, key) {
  const env = getPlatformSafeEnv(honoEnv);
  if (typeof env !== "object" || env === null) {
    return null;
  }
  const envRecord = env;
  if (typeof key === "string") {
    return envRecord?.[key] ?? null;
  }
  for (const k of key) {
    const value = envRecord?.[k];
    if (value) {
      return value;
    }
  }
  return null;
}
function getPlatformSafeEnv(honoEnv) {
  const hasProcessEnv = runtimeHasProcessEnv();
  const hasDenoEnv = runtimeHasDenoEnv();
  const isRunningInHonoNode = isHonoNodeEnv(honoEnv);
  if (hasProcessEnv && isRunningInHonoNode) {
    return process.env;
  }
  if (hasDenoEnv) {
    const denoEnv = globalThis?.Deno?.env?.toObject?.();
    return {
      ...denoEnv ?? {},
      ...typeof honoEnv === "object" && honoEnv !== null ? honoEnv : {}
    };
  }
  return honoEnv;
}
function runtimeHasProcessEnv() {
  if (typeof process !== "undefined" && typeof process.env !== "undefined") {
    return true;
  }
  return false;
}
function runtimeHasDenoEnv() {
  try {
    const denoGlobal = globalThis.Deno;
    return typeof denoGlobal?.env?.toObject === "function";
  } catch {
    return false;
  }
}
function isHonoNodeEnv(env) {
  if (typeof env !== "object" || env === null) {
    return false;
  }
  const envKeys = Object.keys(env).map((key) => key.toLowerCase());
  return envKeys.length === 2 && envKeys.includes("incoming") && envKeys.includes("outgoing");
}

// node_modules/@fiberplane/hono/dist/utils/context-storage.js
import { AsyncLocalStorage } from "node:async_hooks";
var asyncLocalStorage = new AsyncLocalStorage();
var polyfillContextStorage = () => {
  return async function contextStorage2(c, next2) {
    await asyncLocalStorage.run(c, next2);
  };
};
var polyfillGetContext = () => {
  const context = asyncLocalStorage.getStore();
  if (!context) {
    throw new Error("Context is not available");
  }
  return context;
};
var contextStorage = polyfillContextStorage;
var getContext = polyfillGetContext;
import("./context-storage-N2S7HNH7.js").then((honoContextStorage) => {
  contextStorage = honoContextStorage.contextStorage;
  getContext = honoContextStorage.getContext;
}).catch(() => {
});

// node_modules/jsonpath-plus/dist/index-browser-esm.js
var Hooks = class {
  /**
   * @callback HookCallback
   * @this {*|Jsep} this
   * @param {Jsep} env
   * @returns: void
   */
  /**
   * Adds the given callback to the list of callbacks for the given hook.
   *
   * The callback will be invoked when the hook it is registered for is run.
   *
   * One callback function can be registered to multiple hooks and the same hook multiple times.
   *
   * @param {string|object} name The name of the hook, or an object of callbacks keyed by name
   * @param {HookCallback|boolean} callback The callback function which is given environment variables.
   * @param {?boolean} [first=false] Will add the hook to the top of the list (defaults to the bottom)
   * @public
   */
  add(name, callback, first) {
    if (typeof arguments[0] != "string") {
      for (let name2 in arguments[0]) {
        this.add(name2, arguments[0][name2], arguments[1]);
      }
    } else {
      (Array.isArray(name) ? name : [name]).forEach(function(name2) {
        this[name2] = this[name2] || [];
        if (callback) {
          this[name2][first ? "unshift" : "push"](callback);
        }
      }, this);
    }
  }
  /**
   * Runs a hook invoking all registered callbacks with the given environment variables.
   *
   * Callbacks will be invoked synchronously and in the order in which they were registered.
   *
   * @param {string} name The name of the hook.
   * @param {Object<string, any>} env The environment variables of the hook passed to all callbacks registered.
   * @public
   */
  run(name, env) {
    this[name] = this[name] || [];
    this[name].forEach(function(callback) {
      callback.call(env && env.context ? env.context : env, env);
    });
  }
};
var Plugins = class {
  constructor(jsep2) {
    this.jsep = jsep2;
    this.registered = {};
  }
  /**
   * @callback PluginSetup
   * @this {Jsep} jsep
   * @returns: void
   */
  /**
   * Adds the given plugin(s) to the registry
   *
   * @param {object} plugins
   * @param {string} plugins.name The name of the plugin
   * @param {PluginSetup} plugins.init The init function
   * @public
   */
  register() {
    for (var _len = arguments.length, plugins = new Array(_len), _key = 0; _key < _len; _key++) {
      plugins[_key] = arguments[_key];
    }
    plugins.forEach((plugin2) => {
      if (typeof plugin2 !== "object" || !plugin2.name || !plugin2.init) {
        throw new Error("Invalid JSEP plugin format");
      }
      if (this.registered[plugin2.name]) {
        return;
      }
      plugin2.init(this.jsep);
      this.registered[plugin2.name] = plugin2;
    });
  }
};
var Jsep = class _Jsep {
  /**
   * @returns {string}
   */
  static get version() {
    return "1.4.0";
  }
  /**
   * @returns {string}
   */
  static toString() {
    return "JavaScript Expression Parser (JSEP) v" + _Jsep.version;
  }
  // ==================== CONFIG ================================
  /**
   * @method addUnaryOp
   * @param {string} op_name The name of the unary op to add
   * @returns {Jsep}
   */
  static addUnaryOp(op_name) {
    _Jsep.max_unop_len = Math.max(op_name.length, _Jsep.max_unop_len);
    _Jsep.unary_ops[op_name] = 1;
    return _Jsep;
  }
  /**
   * @method jsep.addBinaryOp
   * @param {string} op_name The name of the binary op to add
   * @param {number} precedence The precedence of the binary op (can be a float). Higher number = higher precedence
   * @param {boolean} [isRightAssociative=false] whether operator is right-associative
   * @returns {Jsep}
   */
  static addBinaryOp(op_name, precedence, isRightAssociative) {
    _Jsep.max_binop_len = Math.max(op_name.length, _Jsep.max_binop_len);
    _Jsep.binary_ops[op_name] = precedence;
    if (isRightAssociative) {
      _Jsep.right_associative.add(op_name);
    } else {
      _Jsep.right_associative.delete(op_name);
    }
    return _Jsep;
  }
  /**
   * @method addIdentifierChar
   * @param {string} char The additional character to treat as a valid part of an identifier
   * @returns {Jsep}
   */
  static addIdentifierChar(char) {
    _Jsep.additional_identifier_chars.add(char);
    return _Jsep;
  }
  /**
   * @method addLiteral
   * @param {string} literal_name The name of the literal to add
   * @param {*} literal_value The value of the literal
   * @returns {Jsep}
   */
  static addLiteral(literal_name, literal_value) {
    _Jsep.literals[literal_name] = literal_value;
    return _Jsep;
  }
  /**
   * @method removeUnaryOp
   * @param {string} op_name The name of the unary op to remove
   * @returns {Jsep}
   */
  static removeUnaryOp(op_name) {
    delete _Jsep.unary_ops[op_name];
    if (op_name.length === _Jsep.max_unop_len) {
      _Jsep.max_unop_len = _Jsep.getMaxKeyLen(_Jsep.unary_ops);
    }
    return _Jsep;
  }
  /**
   * @method removeAllUnaryOps
   * @returns {Jsep}
   */
  static removeAllUnaryOps() {
    _Jsep.unary_ops = {};
    _Jsep.max_unop_len = 0;
    return _Jsep;
  }
  /**
   * @method removeIdentifierChar
   * @param {string} char The additional character to stop treating as a valid part of an identifier
   * @returns {Jsep}
   */
  static removeIdentifierChar(char) {
    _Jsep.additional_identifier_chars.delete(char);
    return _Jsep;
  }
  /**
   * @method removeBinaryOp
   * @param {string} op_name The name of the binary op to remove
   * @returns {Jsep}
   */
  static removeBinaryOp(op_name) {
    delete _Jsep.binary_ops[op_name];
    if (op_name.length === _Jsep.max_binop_len) {
      _Jsep.max_binop_len = _Jsep.getMaxKeyLen(_Jsep.binary_ops);
    }
    _Jsep.right_associative.delete(op_name);
    return _Jsep;
  }
  /**
   * @method removeAllBinaryOps
   * @returns {Jsep}
   */
  static removeAllBinaryOps() {
    _Jsep.binary_ops = {};
    _Jsep.max_binop_len = 0;
    return _Jsep;
  }
  /**
   * @method removeLiteral
   * @param {string} literal_name The name of the literal to remove
   * @returns {Jsep}
   */
  static removeLiteral(literal_name) {
    delete _Jsep.literals[literal_name];
    return _Jsep;
  }
  /**
   * @method removeAllLiterals
   * @returns {Jsep}
   */
  static removeAllLiterals() {
    _Jsep.literals = {};
    return _Jsep;
  }
  // ==================== END CONFIG ============================
  /**
   * @returns {string}
   */
  get char() {
    return this.expr.charAt(this.index);
  }
  /**
   * @returns {number}
   */
  get code() {
    return this.expr.charCodeAt(this.index);
  }
  /**
   * @param {string} expr a string with the passed in express
   * @returns Jsep
   */
  constructor(expr) {
    this.expr = expr;
    this.index = 0;
  }
  /**
   * static top-level parser
   * @returns {jsep.Expression}
   */
  static parse(expr) {
    return new _Jsep(expr).parse();
  }
  /**
   * Get the longest key length of any object
   * @param {object} obj
   * @returns {number}
   */
  static getMaxKeyLen(obj) {
    return Math.max(0, ...Object.keys(obj).map((k) => k.length));
  }
  /**
   * `ch` is a character code in the next three functions
   * @param {number} ch
   * @returns {boolean}
   */
  static isDecimalDigit(ch) {
    return ch >= 48 && ch <= 57;
  }
  /**
   * Returns the precedence of a binary operator or `0` if it isn't a binary operator. Can be float.
   * @param {string} op_val
   * @returns {number}
   */
  static binaryPrecedence(op_val) {
    return _Jsep.binary_ops[op_val] || 0;
  }
  /**
   * Looks for start of identifier
   * @param {number} ch
   * @returns {boolean}
   */
  static isIdentifierStart(ch) {
    return ch >= 65 && ch <= 90 || // A...Z
    ch >= 97 && ch <= 122 || // a...z
    ch >= 128 && !_Jsep.binary_ops[String.fromCharCode(ch)] || // any non-ASCII that is not an operator
    _Jsep.additional_identifier_chars.has(String.fromCharCode(ch));
  }
  /**
   * @param {number} ch
   * @returns {boolean}
   */
  static isIdentifierPart(ch) {
    return _Jsep.isIdentifierStart(ch) || _Jsep.isDecimalDigit(ch);
  }
  /**
   * throw error at index of the expression
   * @param {string} message
   * @throws
   */
  throwError(message) {
    const error = new Error(message + " at character " + this.index);
    error.index = this.index;
    error.description = message;
    throw error;
  }
  /**
   * Run a given hook
   * @param {string} name
   * @param {jsep.Expression|false} [node]
   * @returns {?jsep.Expression}
   */
  runHook(name, node) {
    if (_Jsep.hooks[name]) {
      const env = {
        context: this,
        node
      };
      _Jsep.hooks.run(name, env);
      return env.node;
    }
    return node;
  }
  /**
   * Runs a given hook until one returns a node
   * @param {string} name
   * @returns {?jsep.Expression}
   */
  searchHook(name) {
    if (_Jsep.hooks[name]) {
      const env = {
        context: this
      };
      _Jsep.hooks[name].find(function(callback) {
        callback.call(env.context, env);
        return env.node;
      });
      return env.node;
    }
  }
  /**
   * Push `index` up to the next non-space character
   */
  gobbleSpaces() {
    let ch = this.code;
    while (ch === _Jsep.SPACE_CODE || ch === _Jsep.TAB_CODE || ch === _Jsep.LF_CODE || ch === _Jsep.CR_CODE) {
      ch = this.expr.charCodeAt(++this.index);
    }
    this.runHook("gobble-spaces");
  }
  /**
   * Top-level method to parse all expressions and returns compound or single node
   * @returns {jsep.Expression}
   */
  parse() {
    this.runHook("before-all");
    const nodes = this.gobbleExpressions();
    const node = nodes.length === 1 ? nodes[0] : {
      type: _Jsep.COMPOUND,
      body: nodes
    };
    return this.runHook("after-all", node);
  }
  /**
   * top-level parser (but can be reused within as well)
   * @param {number} [untilICode]
   * @returns {jsep.Expression[]}
   */
  gobbleExpressions(untilICode) {
    let nodes = [], ch_i, node;
    while (this.index < this.expr.length) {
      ch_i = this.code;
      if (ch_i === _Jsep.SEMCOL_CODE || ch_i === _Jsep.COMMA_CODE) {
        this.index++;
      } else {
        if (node = this.gobbleExpression()) {
          nodes.push(node);
        } else if (this.index < this.expr.length) {
          if (ch_i === untilICode) {
            break;
          }
          this.throwError('Unexpected "' + this.char + '"');
        }
      }
    }
    return nodes;
  }
  /**
   * The main parsing function.
   * @returns {?jsep.Expression}
   */
  gobbleExpression() {
    const node = this.searchHook("gobble-expression") || this.gobbleBinaryExpression();
    this.gobbleSpaces();
    return this.runHook("after-expression", node);
  }
  /**
   * Search for the operation portion of the string (e.g. `+`, `===`)
   * Start by taking the longest possible binary operations (3 characters: `===`, `!==`, `>>>`)
   * and move down from 3 to 2 to 1 character until a matching binary operation is found
   * then, return that binary operation
   * @returns {string|boolean}
   */
  gobbleBinaryOp() {
    this.gobbleSpaces();
    let to_check = this.expr.substr(this.index, _Jsep.max_binop_len);
    let tc_len = to_check.length;
    while (tc_len > 0) {
      if (_Jsep.binary_ops.hasOwnProperty(to_check) && (!_Jsep.isIdentifierStart(this.code) || this.index + to_check.length < this.expr.length && !_Jsep.isIdentifierPart(this.expr.charCodeAt(this.index + to_check.length)))) {
        this.index += tc_len;
        return to_check;
      }
      to_check = to_check.substr(0, --tc_len);
    }
    return false;
  }
  /**
   * This function is responsible for gobbling an individual expression,
   * e.g. `1`, `1+2`, `a+(b*2)-Math.sqrt(2)`
   * @returns {?jsep.BinaryExpression}
   */
  gobbleBinaryExpression() {
    let node, biop, prec, stack, biop_info, left, right, i, cur_biop;
    left = this.gobbleToken();
    if (!left) {
      return left;
    }
    biop = this.gobbleBinaryOp();
    if (!biop) {
      return left;
    }
    biop_info = {
      value: biop,
      prec: _Jsep.binaryPrecedence(biop),
      right_a: _Jsep.right_associative.has(biop)
    };
    right = this.gobbleToken();
    if (!right) {
      this.throwError("Expected expression after " + biop);
    }
    stack = [left, biop_info, right];
    while (biop = this.gobbleBinaryOp()) {
      prec = _Jsep.binaryPrecedence(biop);
      if (prec === 0) {
        this.index -= biop.length;
        break;
      }
      biop_info = {
        value: biop,
        prec,
        right_a: _Jsep.right_associative.has(biop)
      };
      cur_biop = biop;
      const comparePrev = (prev) => biop_info.right_a && prev.right_a ? prec > prev.prec : prec <= prev.prec;
      while (stack.length > 2 && comparePrev(stack[stack.length - 2])) {
        right = stack.pop();
        biop = stack.pop().value;
        left = stack.pop();
        node = {
          type: _Jsep.BINARY_EXP,
          operator: biop,
          left,
          right
        };
        stack.push(node);
      }
      node = this.gobbleToken();
      if (!node) {
        this.throwError("Expected expression after " + cur_biop);
      }
      stack.push(biop_info, node);
    }
    i = stack.length - 1;
    node = stack[i];
    while (i > 1) {
      node = {
        type: _Jsep.BINARY_EXP,
        operator: stack[i - 1].value,
        left: stack[i - 2],
        right: node
      };
      i -= 2;
    }
    return node;
  }
  /**
   * An individual part of a binary expression:
   * e.g. `foo.bar(baz)`, `1`, `"abc"`, `(a % 2)` (because it's in parenthesis)
   * @returns {boolean|jsep.Expression}
   */
  gobbleToken() {
    let ch, to_check, tc_len, node;
    this.gobbleSpaces();
    node = this.searchHook("gobble-token");
    if (node) {
      return this.runHook("after-token", node);
    }
    ch = this.code;
    if (_Jsep.isDecimalDigit(ch) || ch === _Jsep.PERIOD_CODE) {
      return this.gobbleNumericLiteral();
    }
    if (ch === _Jsep.SQUOTE_CODE || ch === _Jsep.DQUOTE_CODE) {
      node = this.gobbleStringLiteral();
    } else if (ch === _Jsep.OBRACK_CODE) {
      node = this.gobbleArray();
    } else {
      to_check = this.expr.substr(this.index, _Jsep.max_unop_len);
      tc_len = to_check.length;
      while (tc_len > 0) {
        if (_Jsep.unary_ops.hasOwnProperty(to_check) && (!_Jsep.isIdentifierStart(this.code) || this.index + to_check.length < this.expr.length && !_Jsep.isIdentifierPart(this.expr.charCodeAt(this.index + to_check.length)))) {
          this.index += tc_len;
          const argument = this.gobbleToken();
          if (!argument) {
            this.throwError("missing unaryOp argument");
          }
          return this.runHook("after-token", {
            type: _Jsep.UNARY_EXP,
            operator: to_check,
            argument,
            prefix: true
          });
        }
        to_check = to_check.substr(0, --tc_len);
      }
      if (_Jsep.isIdentifierStart(ch)) {
        node = this.gobbleIdentifier();
        if (_Jsep.literals.hasOwnProperty(node.name)) {
          node = {
            type: _Jsep.LITERAL,
            value: _Jsep.literals[node.name],
            raw: node.name
          };
        } else if (node.name === _Jsep.this_str) {
          node = {
            type: _Jsep.THIS_EXP
          };
        }
      } else if (ch === _Jsep.OPAREN_CODE) {
        node = this.gobbleGroup();
      }
    }
    if (!node) {
      return this.runHook("after-token", false);
    }
    node = this.gobbleTokenProperty(node);
    return this.runHook("after-token", node);
  }
  /**
   * Gobble properties of of identifiers/strings/arrays/groups.
   * e.g. `foo`, `bar.baz`, `foo['bar'].baz`
   * It also gobbles function calls:
   * e.g. `Math.acos(obj.angle)`
   * @param {jsep.Expression} node
   * @returns {jsep.Expression}
   */
  gobbleTokenProperty(node) {
    this.gobbleSpaces();
    let ch = this.code;
    while (ch === _Jsep.PERIOD_CODE || ch === _Jsep.OBRACK_CODE || ch === _Jsep.OPAREN_CODE || ch === _Jsep.QUMARK_CODE) {
      let optional;
      if (ch === _Jsep.QUMARK_CODE) {
        if (this.expr.charCodeAt(this.index + 1) !== _Jsep.PERIOD_CODE) {
          break;
        }
        optional = true;
        this.index += 2;
        this.gobbleSpaces();
        ch = this.code;
      }
      this.index++;
      if (ch === _Jsep.OBRACK_CODE) {
        node = {
          type: _Jsep.MEMBER_EXP,
          computed: true,
          object: node,
          property: this.gobbleExpression()
        };
        if (!node.property) {
          this.throwError('Unexpected "' + this.char + '"');
        }
        this.gobbleSpaces();
        ch = this.code;
        if (ch !== _Jsep.CBRACK_CODE) {
          this.throwError("Unclosed [");
        }
        this.index++;
      } else if (ch === _Jsep.OPAREN_CODE) {
        node = {
          type: _Jsep.CALL_EXP,
          "arguments": this.gobbleArguments(_Jsep.CPAREN_CODE),
          callee: node
        };
      } else if (ch === _Jsep.PERIOD_CODE || optional) {
        if (optional) {
          this.index--;
        }
        this.gobbleSpaces();
        node = {
          type: _Jsep.MEMBER_EXP,
          computed: false,
          object: node,
          property: this.gobbleIdentifier()
        };
      }
      if (optional) {
        node.optional = true;
      }
      this.gobbleSpaces();
      ch = this.code;
    }
    return node;
  }
  /**
   * Parse simple numeric literals: `12`, `3.4`, `.5`. Do this by using a string to
   * keep track of everything in the numeric literal and then calling `parseFloat` on that string
   * @returns {jsep.Literal}
   */
  gobbleNumericLiteral() {
    let number = "", ch, chCode;
    while (_Jsep.isDecimalDigit(this.code)) {
      number += this.expr.charAt(this.index++);
    }
    if (this.code === _Jsep.PERIOD_CODE) {
      number += this.expr.charAt(this.index++);
      while (_Jsep.isDecimalDigit(this.code)) {
        number += this.expr.charAt(this.index++);
      }
    }
    ch = this.char;
    if (ch === "e" || ch === "E") {
      number += this.expr.charAt(this.index++);
      ch = this.char;
      if (ch === "+" || ch === "-") {
        number += this.expr.charAt(this.index++);
      }
      while (_Jsep.isDecimalDigit(this.code)) {
        number += this.expr.charAt(this.index++);
      }
      if (!_Jsep.isDecimalDigit(this.expr.charCodeAt(this.index - 1))) {
        this.throwError("Expected exponent (" + number + this.char + ")");
      }
    }
    chCode = this.code;
    if (_Jsep.isIdentifierStart(chCode)) {
      this.throwError("Variable names cannot start with a number (" + number + this.char + ")");
    } else if (chCode === _Jsep.PERIOD_CODE || number.length === 1 && number.charCodeAt(0) === _Jsep.PERIOD_CODE) {
      this.throwError("Unexpected period");
    }
    return {
      type: _Jsep.LITERAL,
      value: parseFloat(number),
      raw: number
    };
  }
  /**
   * Parses a string literal, staring with single or double quotes with basic support for escape codes
   * e.g. `"hello world"`, `'this is\nJSEP'`
   * @returns {jsep.Literal}
   */
  gobbleStringLiteral() {
    let str = "";
    const startIndex = this.index;
    const quote = this.expr.charAt(this.index++);
    let closed = false;
    while (this.index < this.expr.length) {
      let ch = this.expr.charAt(this.index++);
      if (ch === quote) {
        closed = true;
        break;
      } else if (ch === "\\") {
        ch = this.expr.charAt(this.index++);
        switch (ch) {
          case "n":
            str += "\n";
            break;
          case "r":
            str += "\r";
            break;
          case "t":
            str += "	";
            break;
          case "b":
            str += "\b";
            break;
          case "f":
            str += "\f";
            break;
          case "v":
            str += "\v";
            break;
          default:
            str += ch;
        }
      } else {
        str += ch;
      }
    }
    if (!closed) {
      this.throwError('Unclosed quote after "' + str + '"');
    }
    return {
      type: _Jsep.LITERAL,
      value: str,
      raw: this.expr.substring(startIndex, this.index)
    };
  }
  /**
   * Gobbles only identifiers
   * e.g.: `foo`, `_value`, `$x1`
   * Also, this function checks if that identifier is a literal:
   * (e.g. `true`, `false`, `null`) or `this`
   * @returns {jsep.Identifier}
   */
  gobbleIdentifier() {
    let ch = this.code, start = this.index;
    if (_Jsep.isIdentifierStart(ch)) {
      this.index++;
    } else {
      this.throwError("Unexpected " + this.char);
    }
    while (this.index < this.expr.length) {
      ch = this.code;
      if (_Jsep.isIdentifierPart(ch)) {
        this.index++;
      } else {
        break;
      }
    }
    return {
      type: _Jsep.IDENTIFIER,
      name: this.expr.slice(start, this.index)
    };
  }
  /**
   * Gobbles a list of arguments within the context of a function call
   * or array literal. This function also assumes that the opening character
   * `(` or `[` has already been gobbled, and gobbles expressions and commas
   * until the terminator character `)` or `]` is encountered.
   * e.g. `foo(bar, baz)`, `my_func()`, or `[bar, baz]`
   * @param {number} termination
   * @returns {jsep.Expression[]}
   */
  gobbleArguments(termination) {
    const args = [];
    let closed = false;
    let separator_count = 0;
    while (this.index < this.expr.length) {
      this.gobbleSpaces();
      let ch_i = this.code;
      if (ch_i === termination) {
        closed = true;
        this.index++;
        if (termination === _Jsep.CPAREN_CODE && separator_count && separator_count >= args.length) {
          this.throwError("Unexpected token " + String.fromCharCode(termination));
        }
        break;
      } else if (ch_i === _Jsep.COMMA_CODE) {
        this.index++;
        separator_count++;
        if (separator_count !== args.length) {
          if (termination === _Jsep.CPAREN_CODE) {
            this.throwError("Unexpected token ,");
          } else if (termination === _Jsep.CBRACK_CODE) {
            for (let arg = args.length; arg < separator_count; arg++) {
              args.push(null);
            }
          }
        }
      } else if (args.length !== separator_count && separator_count !== 0) {
        this.throwError("Expected comma");
      } else {
        const node = this.gobbleExpression();
        if (!node || node.type === _Jsep.COMPOUND) {
          this.throwError("Expected comma");
        }
        args.push(node);
      }
    }
    if (!closed) {
      this.throwError("Expected " + String.fromCharCode(termination));
    }
    return args;
  }
  /**
   * Responsible for parsing a group of things within parentheses `()`
   * that have no identifier in front (so not a function call)
   * This function assumes that it needs to gobble the opening parenthesis
   * and then tries to gobble everything within that parenthesis, assuming
   * that the next thing it should see is the close parenthesis. If not,
   * then the expression probably doesn't have a `)`
   * @returns {boolean|jsep.Expression}
   */
  gobbleGroup() {
    this.index++;
    let nodes = this.gobbleExpressions(_Jsep.CPAREN_CODE);
    if (this.code === _Jsep.CPAREN_CODE) {
      this.index++;
      if (nodes.length === 1) {
        return nodes[0];
      } else if (!nodes.length) {
        return false;
      } else {
        return {
          type: _Jsep.SEQUENCE_EXP,
          expressions: nodes
        };
      }
    } else {
      this.throwError("Unclosed (");
    }
  }
  /**
   * Responsible for parsing Array literals `[1, 2, 3]`
   * This function assumes that it needs to gobble the opening bracket
   * and then tries to gobble the expressions as arguments.
   * @returns {jsep.ArrayExpression}
   */
  gobbleArray() {
    this.index++;
    return {
      type: _Jsep.ARRAY_EXP,
      elements: this.gobbleArguments(_Jsep.CBRACK_CODE)
    };
  }
};
var hooks = new Hooks();
Object.assign(Jsep, {
  hooks,
  plugins: new Plugins(Jsep),
  // Node Types
  // ----------
  // This is the full set of types that any JSEP node can be.
  // Store them here to save space when minified
  COMPOUND: "Compound",
  SEQUENCE_EXP: "SequenceExpression",
  IDENTIFIER: "Identifier",
  MEMBER_EXP: "MemberExpression",
  LITERAL: "Literal",
  THIS_EXP: "ThisExpression",
  CALL_EXP: "CallExpression",
  UNARY_EXP: "UnaryExpression",
  BINARY_EXP: "BinaryExpression",
  ARRAY_EXP: "ArrayExpression",
  TAB_CODE: 9,
  LF_CODE: 10,
  CR_CODE: 13,
  SPACE_CODE: 32,
  PERIOD_CODE: 46,
  // '.'
  COMMA_CODE: 44,
  // ','
  SQUOTE_CODE: 39,
  // single quote
  DQUOTE_CODE: 34,
  // double quotes
  OPAREN_CODE: 40,
  // (
  CPAREN_CODE: 41,
  // )
  OBRACK_CODE: 91,
  // [
  CBRACK_CODE: 93,
  // ]
  QUMARK_CODE: 63,
  // ?
  SEMCOL_CODE: 59,
  // ;
  COLON_CODE: 58,
  // :
  // Operations
  // ----------
  // Use a quickly-accessible map to store all of the unary operators
  // Values are set to `1` (it really doesn't matter)
  unary_ops: {
    "-": 1,
    "!": 1,
    "~": 1,
    "+": 1
  },
  // Also use a map for the binary operations but set their values to their
  // binary precedence for quick reference (higher number = higher precedence)
  // see [Order of operations](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Operator_Precedence)
  binary_ops: {
    "||": 1,
    "??": 1,
    "&&": 2,
    "|": 3,
    "^": 4,
    "&": 5,
    "==": 6,
    "!=": 6,
    "===": 6,
    "!==": 6,
    "<": 7,
    ">": 7,
    "<=": 7,
    ">=": 7,
    "<<": 8,
    ">>": 8,
    ">>>": 8,
    "+": 9,
    "-": 9,
    "*": 10,
    "/": 10,
    "%": 10,
    "**": 11
  },
  // sets specific binary_ops as right-associative
  right_associative: /* @__PURE__ */ new Set(["**"]),
  // Additional valid identifier chars, apart from a-z, A-Z and 0-9 (except on the starting char)
  additional_identifier_chars: /* @__PURE__ */ new Set(["$", "_"]),
  // Literals
  // ----------
  // Store the values to return for the various literals we may encounter
  literals: {
    "true": true,
    "false": false,
    "null": null
  },
  // Except for `this`, which is special. This could be changed to something like `'self'` as well
  this_str: "this"
});
Jsep.max_unop_len = Jsep.getMaxKeyLen(Jsep.unary_ops);
Jsep.max_binop_len = Jsep.getMaxKeyLen(Jsep.binary_ops);
var jsep = (expr) => new Jsep(expr).parse();
var stdClassProps = Object.getOwnPropertyNames(class Test {
});
Object.getOwnPropertyNames(Jsep).filter((prop) => !stdClassProps.includes(prop) && jsep[prop] === void 0).forEach((m) => {
  jsep[m] = Jsep[m];
});
jsep.Jsep = Jsep;
var CONDITIONAL_EXP = "ConditionalExpression";
var ternary = {
  name: "ternary",
  init(jsep2) {
    jsep2.hooks.add("after-expression", function gobbleTernary(env) {
      if (env.node && this.code === jsep2.QUMARK_CODE) {
        this.index++;
        const test = env.node;
        const consequent = this.gobbleExpression();
        if (!consequent) {
          this.throwError("Expected expression");
        }
        this.gobbleSpaces();
        if (this.code === jsep2.COLON_CODE) {
          this.index++;
          const alternate = this.gobbleExpression();
          if (!alternate) {
            this.throwError("Expected expression");
          }
          env.node = {
            type: CONDITIONAL_EXP,
            test,
            consequent,
            alternate
          };
          if (test.operator && jsep2.binary_ops[test.operator] <= 0.9) {
            let newTest = test;
            while (newTest.right.operator && jsep2.binary_ops[newTest.right.operator] <= 0.9) {
              newTest = newTest.right;
            }
            env.node.test = newTest.right;
            newTest.right = env.node;
            env.node = test;
          }
        } else {
          this.throwError("Expected :");
        }
      }
    });
  }
};
jsep.plugins.register(ternary);
var FSLASH_CODE = 47;
var BSLASH_CODE = 92;
var index2 = {
  name: "regex",
  init(jsep2) {
    jsep2.hooks.add("gobble-token", function gobbleRegexLiteral(env) {
      if (this.code === FSLASH_CODE) {
        const patternIndex = ++this.index;
        let inCharSet = false;
        while (this.index < this.expr.length) {
          if (this.code === FSLASH_CODE && !inCharSet) {
            const pattern = this.expr.slice(patternIndex, this.index);
            let flags = "";
            while (++this.index < this.expr.length) {
              const code = this.code;
              if (code >= 97 && code <= 122 || code >= 65 && code <= 90 || code >= 48 && code <= 57) {
                flags += this.char;
              } else {
                break;
              }
            }
            let value;
            try {
              value = new RegExp(pattern, flags);
            } catch (e) {
              this.throwError(e.message);
            }
            env.node = {
              type: jsep2.LITERAL,
              value,
              raw: this.expr.slice(patternIndex - 1, this.index)
            };
            env.node = this.gobbleTokenProperty(env.node);
            return env.node;
          }
          if (this.code === jsep2.OBRACK_CODE) {
            inCharSet = true;
          } else if (inCharSet && this.code === jsep2.CBRACK_CODE) {
            inCharSet = false;
          }
          this.index += this.code === BSLASH_CODE ? 2 : 1;
        }
        this.throwError("Unclosed Regex");
      }
    });
  }
};
var PLUS_CODE = 43;
var MINUS_CODE = 45;
var plugin = {
  name: "assignment",
  assignmentOperators: /* @__PURE__ */ new Set(["=", "*=", "**=", "/=", "%=", "+=", "-=", "<<=", ">>=", ">>>=", "&=", "^=", "|=", "||=", "&&=", "??="]),
  updateOperators: [PLUS_CODE, MINUS_CODE],
  assignmentPrecedence: 0.9,
  init(jsep2) {
    const updateNodeTypes = [jsep2.IDENTIFIER, jsep2.MEMBER_EXP];
    plugin.assignmentOperators.forEach((op) => jsep2.addBinaryOp(op, plugin.assignmentPrecedence, true));
    jsep2.hooks.add("gobble-token", function gobbleUpdatePrefix(env) {
      const code = this.code;
      if (plugin.updateOperators.some((c) => c === code && c === this.expr.charCodeAt(this.index + 1))) {
        this.index += 2;
        env.node = {
          type: "UpdateExpression",
          operator: code === PLUS_CODE ? "++" : "--",
          argument: this.gobbleTokenProperty(this.gobbleIdentifier()),
          prefix: true
        };
        if (!env.node.argument || !updateNodeTypes.includes(env.node.argument.type)) {
          this.throwError(`Unexpected ${env.node.operator}`);
        }
      }
    });
    jsep2.hooks.add("after-token", function gobbleUpdatePostfix(env) {
      if (env.node) {
        const code = this.code;
        if (plugin.updateOperators.some((c) => c === code && c === this.expr.charCodeAt(this.index + 1))) {
          if (!updateNodeTypes.includes(env.node.type)) {
            this.throwError(`Unexpected ${env.node.operator}`);
          }
          this.index += 2;
          env.node = {
            type: "UpdateExpression",
            operator: code === PLUS_CODE ? "++" : "--",
            argument: env.node,
            prefix: false
          };
        }
      }
    });
    jsep2.hooks.add("after-expression", function gobbleAssignment(env) {
      if (env.node) {
        updateBinariesToAssignments(env.node);
      }
    });
    function updateBinariesToAssignments(node) {
      if (plugin.assignmentOperators.has(node.operator)) {
        node.type = "AssignmentExpression";
        updateBinariesToAssignments(node.left);
        updateBinariesToAssignments(node.right);
      } else if (!node.operator) {
        Object.values(node).forEach((val) => {
          if (val && typeof val === "object") {
            updateBinariesToAssignments(val);
          }
        });
      }
    }
  }
};
jsep.plugins.register(index2, plugin);
jsep.addUnaryOp("typeof");
jsep.addLiteral("null", null);
jsep.addLiteral("undefined", void 0);
var BLOCKED_PROTO_PROPERTIES = /* @__PURE__ */ new Set(["constructor", "__proto__", "__defineGetter__", "__defineSetter__"]);
var SafeEval = {
  /**
   * @param {jsep.Expression} ast
   * @param {Record<string, any>} subs
   */
  evalAst(ast, subs) {
    switch (ast.type) {
      case "BinaryExpression":
      case "LogicalExpression":
        return SafeEval.evalBinaryExpression(ast, subs);
      case "Compound":
        return SafeEval.evalCompound(ast, subs);
      case "ConditionalExpression":
        return SafeEval.evalConditionalExpression(ast, subs);
      case "Identifier":
        return SafeEval.evalIdentifier(ast, subs);
      case "Literal":
        return SafeEval.evalLiteral(ast, subs);
      case "MemberExpression":
        return SafeEval.evalMemberExpression(ast, subs);
      case "UnaryExpression":
        return SafeEval.evalUnaryExpression(ast, subs);
      case "ArrayExpression":
        return SafeEval.evalArrayExpression(ast, subs);
      case "CallExpression":
        return SafeEval.evalCallExpression(ast, subs);
      case "AssignmentExpression":
        return SafeEval.evalAssignmentExpression(ast, subs);
      default:
        throw SyntaxError("Unexpected expression", ast);
    }
  },
  evalBinaryExpression(ast, subs) {
    const result = {
      "||": (a, b) => a || b(),
      "&&": (a, b) => a && b(),
      "|": (a, b) => a | b(),
      "^": (a, b) => a ^ b(),
      "&": (a, b) => a & b(),
      // eslint-disable-next-line eqeqeq -- API
      "==": (a, b) => a == b(),
      // eslint-disable-next-line eqeqeq -- API
      "!=": (a, b) => a != b(),
      "===": (a, b) => a === b(),
      "!==": (a, b) => a !== b(),
      "<": (a, b) => a < b(),
      ">": (a, b) => a > b(),
      "<=": (a, b) => a <= b(),
      ">=": (a, b) => a >= b(),
      "<<": (a, b) => a << b(),
      ">>": (a, b) => a >> b(),
      ">>>": (a, b) => a >>> b(),
      "+": (a, b) => a + b(),
      "-": (a, b) => a - b(),
      "*": (a, b) => a * b(),
      "/": (a, b) => a / b(),
      "%": (a, b) => a % b()
    }[ast.operator](SafeEval.evalAst(ast.left, subs), () => SafeEval.evalAst(ast.right, subs));
    return result;
  },
  evalCompound(ast, subs) {
    let last;
    for (let i = 0; i < ast.body.length; i++) {
      if (ast.body[i].type === "Identifier" && ["var", "let", "const"].includes(ast.body[i].name) && ast.body[i + 1] && ast.body[i + 1].type === "AssignmentExpression") {
        i += 1;
      }
      const expr = ast.body[i];
      last = SafeEval.evalAst(expr, subs);
    }
    return last;
  },
  evalConditionalExpression(ast, subs) {
    if (SafeEval.evalAst(ast.test, subs)) {
      return SafeEval.evalAst(ast.consequent, subs);
    }
    return SafeEval.evalAst(ast.alternate, subs);
  },
  evalIdentifier(ast, subs) {
    if (Object.hasOwn(subs, ast.name)) {
      return subs[ast.name];
    }
    throw ReferenceError(`${ast.name} is not defined`);
  },
  evalLiteral(ast) {
    return ast.value;
  },
  evalMemberExpression(ast, subs) {
    const prop = String(
      // NOTE: `String(value)` throws error when
      // value has overwritten the toString method to return non-string
      // i.e. `value = {toString: () => []}`
      ast.computed ? SafeEval.evalAst(ast.property) : ast.property.name
      // `object.property` property is Identifier
    );
    const obj = SafeEval.evalAst(ast.object, subs);
    if (obj === void 0 || obj === null) {
      throw TypeError(`Cannot read properties of ${obj} (reading '${prop}')`);
    }
    if (!Object.hasOwn(obj, prop) && BLOCKED_PROTO_PROPERTIES.has(prop)) {
      throw TypeError(`Cannot read properties of ${obj} (reading '${prop}')`);
    }
    const result = obj[prop];
    if (typeof result === "function") {
      return result.bind(obj);
    }
    return result;
  },
  evalUnaryExpression(ast, subs) {
    const result = {
      "-": (a) => -SafeEval.evalAst(a, subs),
      "!": (a) => !SafeEval.evalAst(a, subs),
      "~": (a) => ~SafeEval.evalAst(a, subs),
      // eslint-disable-next-line no-implicit-coercion -- API
      "+": (a) => +SafeEval.evalAst(a, subs),
      typeof: (a) => typeof SafeEval.evalAst(a, subs)
    }[ast.operator](ast.argument);
    return result;
  },
  evalArrayExpression(ast, subs) {
    return ast.elements.map((el) => SafeEval.evalAst(el, subs));
  },
  evalCallExpression(ast, subs) {
    const args = ast.arguments.map((arg) => SafeEval.evalAst(arg, subs));
    const func = SafeEval.evalAst(ast.callee, subs);
    return func(...args);
  },
  evalAssignmentExpression(ast, subs) {
    if (ast.left.type !== "Identifier") {
      throw SyntaxError("Invalid left-hand side in assignment");
    }
    const id = ast.left.name;
    const value = SafeEval.evalAst(ast.right, subs);
    subs[id] = value;
    return subs[id];
  }
};
var SafeScript = class {
  /**
   * @param {string} expr Expression to evaluate
   */
  constructor(expr) {
    this.code = expr;
    this.ast = jsep(this.code);
  }
  /**
   * @param {object} context Object whose items will be added
   *   to evaluation
   * @returns {EvaluatedResult} Result of evaluated code
   */
  runInNewContext(context) {
    const keyMap = Object.assign(/* @__PURE__ */ Object.create(null), context);
    return SafeEval.evalAst(this.ast, keyMap);
  }
};
function push(arr, item) {
  arr = arr.slice();
  arr.push(item);
  return arr;
}
function unshift(item, arr) {
  arr = arr.slice();
  arr.unshift(item);
  return arr;
}
var NewError = class extends Error {
  /**
   * @param {AnyResult} value The evaluated scalar value
   */
  constructor(value) {
    super('JSONPath should not be called with "new" (it prevents return of (unwrapped) scalar values)');
    this.avoidNew = true;
    this.value = value;
    this.name = "NewError";
  }
};
function JSONPath(opts, expr, obj, callback, otherTypeCallback) {
  if (!(this instanceof JSONPath)) {
    try {
      return new JSONPath(opts, expr, obj, callback, otherTypeCallback);
    } catch (e) {
      if (!e.avoidNew) {
        throw e;
      }
      return e.value;
    }
  }
  if (typeof opts === "string") {
    otherTypeCallback = callback;
    callback = obj;
    obj = expr;
    expr = opts;
    opts = null;
  }
  const optObj = opts && typeof opts === "object";
  opts = opts || {};
  this.json = opts.json || obj;
  this.path = opts.path || expr;
  this.resultType = opts.resultType || "value";
  this.flatten = opts.flatten || false;
  this.wrap = Object.hasOwn(opts, "wrap") ? opts.wrap : true;
  this.sandbox = opts.sandbox || {};
  this.eval = opts.eval === void 0 ? "safe" : opts.eval;
  this.ignoreEvalErrors = typeof opts.ignoreEvalErrors === "undefined" ? false : opts.ignoreEvalErrors;
  this.parent = opts.parent || null;
  this.parentProperty = opts.parentProperty || null;
  this.callback = opts.callback || callback || null;
  this.otherTypeCallback = opts.otherTypeCallback || otherTypeCallback || function() {
    throw new TypeError("You must supply an otherTypeCallback callback option with the @other() operator.");
  };
  if (opts.autostart !== false) {
    const args = {
      path: optObj ? opts.path : expr
    };
    if (!optObj) {
      args.json = obj;
    } else if ("json" in opts) {
      args.json = opts.json;
    }
    const ret = this.evaluate(args);
    if (!ret || typeof ret !== "object") {
      throw new NewError(ret);
    }
    return ret;
  }
}
JSONPath.prototype.evaluate = function(expr, json, callback, otherTypeCallback) {
  let currParent = this.parent, currParentProperty = this.parentProperty;
  let {
    flatten,
    wrap
  } = this;
  this.currResultType = this.resultType;
  this.currEval = this.eval;
  this.currSandbox = this.sandbox;
  callback = callback || this.callback;
  this.currOtherTypeCallback = otherTypeCallback || this.otherTypeCallback;
  json = json || this.json;
  expr = expr || this.path;
  if (expr && typeof expr === "object" && !Array.isArray(expr)) {
    if (!expr.path && expr.path !== "") {
      throw new TypeError('You must supply a "path" property when providing an object argument to JSONPath.evaluate().');
    }
    if (!Object.hasOwn(expr, "json")) {
      throw new TypeError('You must supply a "json" property when providing an object argument to JSONPath.evaluate().');
    }
    ({
      json
    } = expr);
    flatten = Object.hasOwn(expr, "flatten") ? expr.flatten : flatten;
    this.currResultType = Object.hasOwn(expr, "resultType") ? expr.resultType : this.currResultType;
    this.currSandbox = Object.hasOwn(expr, "sandbox") ? expr.sandbox : this.currSandbox;
    wrap = Object.hasOwn(expr, "wrap") ? expr.wrap : wrap;
    this.currEval = Object.hasOwn(expr, "eval") ? expr.eval : this.currEval;
    callback = Object.hasOwn(expr, "callback") ? expr.callback : callback;
    this.currOtherTypeCallback = Object.hasOwn(expr, "otherTypeCallback") ? expr.otherTypeCallback : this.currOtherTypeCallback;
    currParent = Object.hasOwn(expr, "parent") ? expr.parent : currParent;
    currParentProperty = Object.hasOwn(expr, "parentProperty") ? expr.parentProperty : currParentProperty;
    expr = expr.path;
  }
  currParent = currParent || null;
  currParentProperty = currParentProperty || null;
  if (Array.isArray(expr)) {
    expr = JSONPath.toPathString(expr);
  }
  if (!expr && expr !== "" || !json) {
    return void 0;
  }
  const exprList = JSONPath.toPathArray(expr);
  if (exprList[0] === "$" && exprList.length > 1) {
    exprList.shift();
  }
  this._hasParentSelector = null;
  const result = this._trace(exprList, json, ["$"], currParent, currParentProperty, callback).filter(function(ea) {
    return ea && !ea.isParentSelector;
  });
  if (!result.length) {
    return wrap ? [] : void 0;
  }
  if (!wrap && result.length === 1 && !result[0].hasArrExpr) {
    return this._getPreferredOutput(result[0]);
  }
  return result.reduce((rslt, ea) => {
    const valOrPath = this._getPreferredOutput(ea);
    if (flatten && Array.isArray(valOrPath)) {
      rslt = rslt.concat(valOrPath);
    } else {
      rslt.push(valOrPath);
    }
    return rslt;
  }, []);
};
JSONPath.prototype._getPreferredOutput = function(ea) {
  const resultType = this.currResultType;
  switch (resultType) {
    case "all": {
      const path = Array.isArray(ea.path) ? ea.path : JSONPath.toPathArray(ea.path);
      ea.pointer = JSONPath.toPointer(path);
      ea.path = typeof ea.path === "string" ? ea.path : JSONPath.toPathString(ea.path);
      return ea;
    }
    case "value":
    case "parent":
    case "parentProperty":
      return ea[resultType];
    case "path":
      return JSONPath.toPathString(ea[resultType]);
    case "pointer":
      return JSONPath.toPointer(ea.path);
    default:
      throw new TypeError("Unknown result type");
  }
};
JSONPath.prototype._handleCallback = function(fullRetObj, callback, type) {
  if (callback) {
    const preferredOutput = this._getPreferredOutput(fullRetObj);
    fullRetObj.path = typeof fullRetObj.path === "string" ? fullRetObj.path : JSONPath.toPathString(fullRetObj.path);
    callback(preferredOutput, type, fullRetObj);
  }
};
JSONPath.prototype._trace = function(expr, val, path, parent, parentPropName, callback, hasArrExpr, literalPriority) {
  let retObj;
  if (!expr.length) {
    retObj = {
      path,
      value: val,
      parent,
      parentProperty: parentPropName,
      hasArrExpr
    };
    this._handleCallback(retObj, callback, "value");
    return retObj;
  }
  const loc = expr[0], x = expr.slice(1);
  const ret = [];
  function addRet(elems) {
    if (Array.isArray(elems)) {
      elems.forEach((t) => {
        ret.push(t);
      });
    } else {
      ret.push(elems);
    }
  }
  if ((typeof loc !== "string" || literalPriority) && val && Object.hasOwn(val, loc)) {
    addRet(this._trace(x, val[loc], push(path, loc), val, loc, callback, hasArrExpr));
  } else if (loc === "*") {
    this._walk(val, (m) => {
      addRet(this._trace(x, val[m], push(path, m), val, m, callback, true, true));
    });
  } else if (loc === "..") {
    addRet(this._trace(x, val, path, parent, parentPropName, callback, hasArrExpr));
    this._walk(val, (m) => {
      if (typeof val[m] === "object") {
        addRet(this._trace(expr.slice(), val[m], push(path, m), val, m, callback, true));
      }
    });
  } else if (loc === "^") {
    this._hasParentSelector = true;
    return {
      path: path.slice(0, -1),
      expr: x,
      isParentSelector: true
    };
  } else if (loc === "~") {
    retObj = {
      path: push(path, loc),
      value: parentPropName,
      parent,
      parentProperty: null
    };
    this._handleCallback(retObj, callback, "property");
    return retObj;
  } else if (loc === "$") {
    addRet(this._trace(x, val, path, null, null, callback, hasArrExpr));
  } else if (/^(-?\d*):(-?\d*):?(\d*)$/u.test(loc)) {
    addRet(this._slice(loc, x, val, path, parent, parentPropName, callback));
  } else if (loc.indexOf("?(") === 0) {
    if (this.currEval === false) {
      throw new Error("Eval [?(expr)] prevented in JSONPath expression.");
    }
    const safeLoc = loc.replace(/^\?\((.*?)\)$/u, "$1");
    const nested = /@.?([^?]*)[['](\??\(.*?\))(?!.\)\])[\]']/gu.exec(safeLoc);
    if (nested) {
      this._walk(val, (m) => {
        const npath = [nested[2]];
        const nvalue = nested[1] ? val[m][nested[1]] : val[m];
        const filterResults = this._trace(npath, nvalue, path, parent, parentPropName, callback, true);
        if (filterResults.length > 0) {
          addRet(this._trace(x, val[m], push(path, m), val, m, callback, true));
        }
      });
    } else {
      this._walk(val, (m) => {
        if (this._eval(safeLoc, val[m], m, path, parent, parentPropName)) {
          addRet(this._trace(x, val[m], push(path, m), val, m, callback, true));
        }
      });
    }
  } else if (loc[0] === "(") {
    if (this.currEval === false) {
      throw new Error("Eval [(expr)] prevented in JSONPath expression.");
    }
    addRet(this._trace(unshift(this._eval(loc, val, path.at(-1), path.slice(0, -1), parent, parentPropName), x), val, path, parent, parentPropName, callback, hasArrExpr));
  } else if (loc[0] === "@") {
    let addType = false;
    const valueType = loc.slice(1, -2);
    switch (valueType) {
      case "scalar":
        if (!val || !["object", "function"].includes(typeof val)) {
          addType = true;
        }
        break;
      case "boolean":
      case "string":
      case "undefined":
      case "function":
        if (typeof val === valueType) {
          addType = true;
        }
        break;
      case "integer":
        if (Number.isFinite(val) && !(val % 1)) {
          addType = true;
        }
        break;
      case "number":
        if (Number.isFinite(val)) {
          addType = true;
        }
        break;
      case "nonFinite":
        if (typeof val === "number" && !Number.isFinite(val)) {
          addType = true;
        }
        break;
      case "object":
        if (val && typeof val === valueType) {
          addType = true;
        }
        break;
      case "array":
        if (Array.isArray(val)) {
          addType = true;
        }
        break;
      case "other":
        addType = this.currOtherTypeCallback(val, path, parent, parentPropName);
        break;
      case "null":
        if (val === null) {
          addType = true;
        }
        break;
      /* c8 ignore next 2 */
      default:
        throw new TypeError("Unknown value type " + valueType);
    }
    if (addType) {
      retObj = {
        path,
        value: val,
        parent,
        parentProperty: parentPropName
      };
      this._handleCallback(retObj, callback, "value");
      return retObj;
    }
  } else if (loc[0] === "`" && val && Object.hasOwn(val, loc.slice(1))) {
    const locProp = loc.slice(1);
    addRet(this._trace(x, val[locProp], push(path, locProp), val, locProp, callback, hasArrExpr, true));
  } else if (loc.includes(",")) {
    const parts = loc.split(",");
    for (const part of parts) {
      addRet(this._trace(unshift(part, x), val, path, parent, parentPropName, callback, true));
    }
  } else if (!literalPriority && val && Object.hasOwn(val, loc)) {
    addRet(this._trace(x, val[loc], push(path, loc), val, loc, callback, hasArrExpr, true));
  }
  if (this._hasParentSelector) {
    for (let t = 0; t < ret.length; t++) {
      const rett = ret[t];
      if (rett && rett.isParentSelector) {
        const tmp = this._trace(rett.expr, val, rett.path, parent, parentPropName, callback, hasArrExpr);
        if (Array.isArray(tmp)) {
          ret[t] = tmp[0];
          const tl = tmp.length;
          for (let tt = 1; tt < tl; tt++) {
            t++;
            ret.splice(t, 0, tmp[tt]);
          }
        } else {
          ret[t] = tmp;
        }
      }
    }
  }
  return ret;
};
JSONPath.prototype._walk = function(val, f) {
  if (Array.isArray(val)) {
    const n = val.length;
    for (let i = 0; i < n; i++) {
      f(i);
    }
  } else if (val && typeof val === "object") {
    Object.keys(val).forEach((m) => {
      f(m);
    });
  }
};
JSONPath.prototype._slice = function(loc, expr, val, path, parent, parentPropName, callback) {
  if (!Array.isArray(val)) {
    return void 0;
  }
  const len = val.length, parts = loc.split(":"), step2 = parts[2] && Number.parseInt(parts[2]) || 1;
  let start = parts[0] && Number.parseInt(parts[0]) || 0, end = parts[1] && Number.parseInt(parts[1]) || len;
  start = start < 0 ? Math.max(0, start + len) : Math.min(len, start);
  end = end < 0 ? Math.max(0, end + len) : Math.min(len, end);
  const ret = [];
  for (let i = start; i < end; i += step2) {
    const tmp = this._trace(unshift(i, expr), val, path, parent, parentPropName, callback, true);
    tmp.forEach((t) => {
      ret.push(t);
    });
  }
  return ret;
};
JSONPath.prototype._eval = function(code, _v, _vname, path, parent, parentPropName) {
  this.currSandbox._$_parentProperty = parentPropName;
  this.currSandbox._$_parent = parent;
  this.currSandbox._$_property = _vname;
  this.currSandbox._$_root = this.json;
  this.currSandbox._$_v = _v;
  const containsPath = code.includes("@path");
  if (containsPath) {
    this.currSandbox._$_path = JSONPath.toPathString(path.concat([_vname]));
  }
  const scriptCacheKey = this.currEval + "Script:" + code;
  if (!JSONPath.cache[scriptCacheKey]) {
    let script2 = code.replaceAll("@parentProperty", "_$_parentProperty").replaceAll("@parent", "_$_parent").replaceAll("@property", "_$_property").replaceAll("@root", "_$_root").replaceAll(/@([.\s)[])/gu, "_$_v$1");
    if (containsPath) {
      script2 = script2.replaceAll("@path", "_$_path");
    }
    if (this.currEval === "safe" || this.currEval === true || this.currEval === void 0) {
      JSONPath.cache[scriptCacheKey] = new this.safeVm.Script(script2);
    } else if (this.currEval === "native") {
      JSONPath.cache[scriptCacheKey] = new this.vm.Script(script2);
    } else if (typeof this.currEval === "function" && this.currEval.prototype && Object.hasOwn(this.currEval.prototype, "runInNewContext")) {
      const CurrEval = this.currEval;
      JSONPath.cache[scriptCacheKey] = new CurrEval(script2);
    } else if (typeof this.currEval === "function") {
      JSONPath.cache[scriptCacheKey] = {
        runInNewContext: (context) => this.currEval(script2, context)
      };
    } else {
      throw new TypeError(`Unknown "eval" property "${this.currEval}"`);
    }
  }
  try {
    return JSONPath.cache[scriptCacheKey].runInNewContext(this.currSandbox);
  } catch (e) {
    if (this.ignoreEvalErrors) {
      return false;
    }
    throw new Error("jsonPath: " + e.message + ": " + code);
  }
};
JSONPath.cache = {};
JSONPath.toPathString = function(pathArr) {
  const x = pathArr, n = x.length;
  let p = "$";
  for (let i = 1; i < n; i++) {
    if (!/^(~|\^|@.*?\(\))$/u.test(x[i])) {
      p += /^[0-9*]+$/u.test(x[i]) ? "[" + x[i] + "]" : "['" + x[i] + "']";
    }
  }
  return p;
};
JSONPath.toPointer = function(pointer) {
  const x = pointer, n = x.length;
  let p = "";
  for (let i = 1; i < n; i++) {
    if (!/^(~|\^|@.*?\(\))$/u.test(x[i])) {
      p += "/" + x[i].toString().replaceAll("~", "~0").replaceAll("/", "~1");
    }
  }
  return p;
};
JSONPath.toPathArray = function(expr) {
  const {
    cache: cache2
  } = JSONPath;
  if (cache2[expr]) {
    return cache2[expr].concat();
  }
  const subx = [];
  const normalized = expr.replaceAll(/@(?:null|boolean|number|string|integer|undefined|nonFinite|scalar|array|object|function|other)\(\)/gu, ";$&;").replaceAll(/[['](\??\(.*?\))[\]'](?!.\])/gu, function($0, $1) {
    return "[#" + (subx.push($1) - 1) + "]";
  }).replaceAll(/\[['"]([^'\]]*)['"]\]/gu, function($0, prop) {
    return "['" + prop.replaceAll(".", "%@%").replaceAll("~", "%%@@%%") + "']";
  }).replaceAll("~", ";~;").replaceAll(/['"]?\.['"]?(?![^[]*\])|\[['"]?/gu, ";").replaceAll("%@%", ".").replaceAll("%%@@%%", "~").replaceAll(/(?:;)?(\^+)(?:;)?/gu, function($0, ups) {
    return ";" + ups.split("").join(";") + ";";
  }).replaceAll(/;;;|;;/gu, ";..;").replaceAll(/;$|'?\]|'$/gu, "");
  const exprList = normalized.split(";").map(function(exp) {
    const match = exp.match(/#(\d+)/u);
    return !match || !match[1] ? exp : subx[match[1]];
  });
  cache2[expr] = exprList;
  return cache2[expr].concat();
};
JSONPath.prototype.safeVm = {
  Script: SafeScript
};
var moveToAnotherArray = function(source, target, conditionCb) {
  const il = source.length;
  for (let i = 0; i < il; i++) {
    const item = source[i];
    if (conditionCb(item)) {
      target.push(source.splice(i--, 1)[0]);
    }
  }
};
var Script = class {
  /**
   * @param {string} expr Expression to evaluate
   */
  constructor(expr) {
    this.code = expr;
  }
  /**
   * @param {object} context Object whose items will be added
   *   to evaluation
   * @returns {EvaluatedResult} Result of evaluated code
   */
  runInNewContext(context) {
    let expr = this.code;
    const keys = Object.keys(context);
    const funcs = [];
    moveToAnotherArray(keys, funcs, (key) => {
      return typeof context[key] === "function";
    });
    const values = keys.map((vr) => {
      return context[vr];
    });
    const funcString = funcs.reduce((s, func) => {
      let fString = context[func].toString();
      if (!/function/u.test(fString)) {
        fString = "function " + fString;
      }
      return "var " + func + "=" + fString + ";" + s;
    }, "");
    expr = funcString + expr;
    if (!/(['"])use strict\1/u.test(expr) && !keys.includes("arguments")) {
      expr = "var arguments = undefined;" + expr;
    }
    expr = expr.replace(/;\s*$/u, "");
    const lastStatementEnd = expr.lastIndexOf(";");
    const code = lastStatementEnd !== -1 ? expr.slice(0, lastStatementEnd + 1) + " return " + expr.slice(lastStatementEnd + 1) : " return " + expr;
    return new Function(...keys, code)(...values);
  }
};
JSONPath.prototype.vm = {
  Script
};

// node_modules/@fiberplane/hono/dist/routes/runner/resolvers.js
var import_jsonpointer = __toESM(require_jsonpointer(), 1);
function resolvePathAndMethod(step2) {
  return {
    path: step2.operation.path,
    method: step2.operation.method
  };
}
function resolveParameters(parameters, context) {
  return parameters.reduce((acc, param) => {
    acc[param.name] = String(resolveReference(param.value, context));
    return acc;
  }, {});
}
function resolveBody(requestBody, context) {
  if (!requestBody) {
    return void 0;
  }
  const { payload } = requestBody;
  if (typeof payload === "string") {
    return resolveReference(payload, context);
  }
  if (typeof payload === "object") {
    const resolvedBody = Object.entries(payload).reduce((acc, [key, value]) => {
      acc[key] = typeof value === "string" && value.startsWith("$") ? resolveReference(value, context) : value;
      return acc;
    }, {});
    return resolvedBody;
  }
  return void 0;
}
async function resolveStepParams(step2, context) {
  const parameters = resolveParameters(step2.parameters, context);
  const body = resolveBody(step2.requestBody, context);
  return {
    parameters,
    ...body ? { body } : {}
  };
}
function resolveOutputs(workflow, context) {
  return workflow.outputs.reduce((acc, output) => {
    acc[output.key] = resolveReference(output.value, context);
    return acc;
  }, {});
}
function resolveReference(value, context) {
  if (!value.startsWith("$") && !value.includes("{$")) {
    return value;
  }
  if (value.includes("{$")) {
    return value.replace(/\{([^}]+)\}/g, (_, expr) => {
      const resolved = resolveReference(expr, context);
      return resolved === void 0 ? "" : String(resolved);
    });
  }
  const [jsonPath, jsonPointerPath] = value.split("#");
  if (jsonPath.startsWith("$response") && "response" in context) {
    const path = jsonPath.replace("$response", "$");
    const result2 = JSONPath({
      path,
      json: context.response,
      resultType: "value"
    })[0];
    if (jsonPointerPath && result2) {
      return import_jsonpointer.default.get(result2, jsonPointerPath.startsWith("/") ? jsonPointerPath : `/${jsonPointerPath}`);
    }
    return result2;
  }
  const transformedPath = jsonPath.replace(/^\$/, "$.");
  const result = JSONPath({
    path: transformedPath,
    json: context,
    resultType: "value"
  })[0];
  if (jsonPointerPath && result) {
    return import_jsonpointer.default.get(result, jsonPointerPath.startsWith("/") ? jsonPointerPath : `/${jsonPointerPath}`);
  }
  return result;
}
function resolveStepOutputs(step2, response) {
  if (!step2.outputs?.length) {
    return void 0;
  }
  return step2.outputs.reduce((acc, output) => {
    acc[output.key] = resolveReference(output.value, { response });
    return acc;
  }, {});
}

// node_modules/@fiberplane/hono/dist/routes/runner/utils.js
async function getWorkflowById(workflowId, apiKey, fiberplaneServicesUrl, partitionKey) {
  const c = getContext();
  const app = c.get("userApp");
  const env = c.get("userEnv");
  if (!app) {
    throw new HTTPException(500, {
      message: "app is not configured for running workflows"
    });
  }
  const path = `/api/workflows/${workflowId}`;
  const request = new Request(`${fiberplaneServicesUrl}${path}`, {
    method: "GET",
    headers: {
      Authorization: `Bearer ${apiKey}`,
      "X-Fiberplane-Partition-Key": partitionKey
    }
  });
  if (new URL(c.req.url).origin === fiberplaneServicesUrl) {
    const response = await app.request(request, {}, env);
    if (!response.ok) {
      throw new HTTPException(response.status, {
        message: await response.text()
      });
    }
    return await response.json();
  }
  const workflowResponse = await fetch(request);
  return await workflowResponse.json();
}

// node_modules/@fiberplane/hono/dist/routes/runner/index.js
var WorkflowError = class extends HTTPException {
  details;
  cause;
  constructor(status, message, details, cause) {
    super(status, {
      message,
      cause
    });
    this.details = details;
    this.cause = cause;
  }
  toResponse() {
    const { body, ...details } = this.details;
    return {
      type: "EXECUTION_ERROR",
      message: this.message,
      payload: details
    };
  }
};
function serialize2(content) {
  if (typeof content === "string") {
    return content;
  }
  if (content === void 0) {
    return void 0;
  }
  return JSON.stringify(content);
}
var BaseJsonErrorSchema = z.object({
  type: z.literal("error"),
  name: z.string(),
  message: z.string()
});
var RequiredPropertyErrorDataSchema = z.object({
  key: z.string(),
  pointer: z.string(),
  schema: InputSchema,
  value: z.any()
});
var TypeErrorDataSchema = z.object({
  value: z.any(),
  pointer: z.string(),
  expected: z.string(),
  received: z.string(),
  schema: InputSchema
});
var RequiredPropertyErrorSchema = BaseJsonErrorSchema.extend({
  code: z.literal("required-property-error"),
  data: RequiredPropertyErrorDataSchema
});
var TypeErrorSchema = BaseJsonErrorSchema.extend({
  code: z.literal("type-error"),
  data: TypeErrorDataSchema
});
var SupportedValidationErrorSchema = z.discriminatedUnion("code", [
  RequiredPropertyErrorSchema,
  TypeErrorSchema
]);
function createRunnerRoute(apiKey, fiberplaneServicesUrl) {
  const runner = new Hono().post("/:workflowId", sValidator("param", z.object({ workflowId: z.string() })), async (c) => {
    const { workflowId } = c.req.valid("param");
    const partitionKey = c.req.header("X-Fiberplane-Partition-Key");
    if (!partitionKey) {
      return c.json({ error: "Missing `X-Fiberplane-Partition-Key` header" }, 400);
    }
    const { data: workflow } = await getWorkflowById(workflowId, apiKey, fiberplaneServicesUrl, partitionKey);
    const inputs = workflow.inputs;
    if (inputs.type === "object" && inputs.properties) {
      inputs.properties = Object.fromEntries(Object.entries(inputs.properties).map(([key, value]) => {
        return [key, { ...value, id: key }];
      }));
    }
    const draft = new Draft2019(inputs);
    const body = await c.req.json();
    const errors2 = draft.validate(body);
    if (errors2.length) {
      const details = errors2.map((item) => {
        const parsedResult = SupportedValidationErrorSchema.safeParse(item);
        if (parsedResult.success) {
          return parsedResult.data;
        }
        return null;
      }).filter((item) => item !== null).map((item) => {
        if (item.code === "required-property-error") {
          return {
            key: item.data.key,
            message: item.message,
            code: item.code
          };
        }
        return {
          code: item.code,
          key: item.data.pointer,
          message: item.message
        };
      });
      const response = {
        type: "VALIDATION_ERROR",
        message: "validation failed",
        payload: details
      };
      return c.json(response, 400);
    }
    const context = getContext();
    const userApp = context.get("userApp");
    if (!userApp) {
      return c.json({
        type: "CONFIGURATION_ERROR",
        message: "Missing `app` parameter for @fiberplane/hono middleware"
      }, 500);
    }
    try {
      const result = await executeWorkflow(workflow, body);
      return c.json(result);
    } catch (error) {
      if (error instanceof WorkflowError) {
        return c.json(error.toResponse(), error.status);
      }
      throw error;
    }
  });
  return runner;
}
async function executeWorkflow(workflow, inputs) {
  const workflowContext = {
    inputs,
    steps: {}
  };
  for (const step2 of workflow.steps) {
    try {
      const stepParameters = await resolveStepParams(step2, workflowContext);
      const c = getContext();
      const baseUrl = new URL(c.req.url).origin;
      const request = createRequest(step2, stepParameters, baseUrl);
      const response = await executeRequest(request);
      if (response.statusCode >= 400) {
        const request2 = createRequest(step2, stepParameters, baseUrl);
        const errorDetails = {
          stepId: step2.stepId,
          parameters: stepParameters.parameters,
          request: {
            url: request2.url,
            method: request2.method,
            headers: Object.fromEntries(request2.headers.entries()),
            body: stepParameters.body ? serialize2(stepParameters.body) : void 0
          },
          response: {
            status: response.statusCode,
            headers: response.headers,
            body: serialize2(response.body)
          }
        };
        throw new WorkflowError(response.statusCode, "Workflow failed", errorDetails);
      }
      const outputs = resolveStepOutputs(step2, response);
      workflowContext.steps[step2.stepId] = {
        ...outputs ? { outputs } : {}
      };
    } catch (error) {
      if (error instanceof WorkflowError) {
        throw error;
      }
      throw new WorkflowError(500, "Unknown step execution error", {
        stepId: step2.stepId
      });
    }
  }
  return resolveOutputs(workflow, workflowContext);
}
async function executeRequest(request) {
  const c = getContext();
  const userApp = c.get("userApp");
  const userEnv = c.get("userEnv");
  const userExecutionCtx = c.get("userExecutionCtx");
  const response = await userApp.request(request, {}, userEnv, userExecutionCtx);
  const contentType = response.headers.get("content-type");
  const responseBody = contentType?.includes("application/json") ? await response.json() : await response.text() || null;
  return {
    statusCode: response.status,
    headers: Object.fromEntries(response.headers.entries()),
    body: responseBody
  };
}
function createRequest(step2, params, origin) {
  const baseUrl = new URL(origin);
  const headers = new Headers();
  const { method, path: uri } = resolvePathAndMethod(step2);
  const { pathname, searchParams } = step2.parameters.reduce((acc, param) => {
    const value = String(params.parameters[param.name]);
    switch (param.in) {
      case "path":
        acc.pathname = acc.pathname.replace(`{${param.name}}`, value);
        break;
      case "query":
        acc.searchParams += `${acc.searchParams ? "&" : ""}${encodeURIComponent(param.name)}=${encodeURIComponent(value)}`;
        break;
      case "header":
        headers.append(param.name, value);
        break;
    }
    return acc;
  }, { pathname: uri, searchParams: "" });
  const url = new URL(pathname + (searchParams ? `?${searchParams}` : ""), baseUrl);
  if (params.body) {
    headers.append("Content-Type", "application/json");
  }
  return new Request(url, {
    method: method.toUpperCase(),
    headers,
    body: params.body ? JSON.stringify(params.body) : void 0
  });
}

// node_modules/@fiberplane/hono/dist/router.js
function createRouter(options) {
  const { apiKey, otelEndpoint, otelToken, debug, fiberplaneServicesUrl, ...sanitizedOptions } = options;
  const fetchFn = options.fetch ?? webStandardFetch;
  const app = new Hono();
  const isDebugEnabled = debug ?? false;
  app.use(async (c, next2) => {
    c.set("debug", isDebugEnabled);
    await next2();
  });
  app.use(contextStorage());
  app.use(async (c, next2) => {
    await next2();
    logIfDebug(isDebugEnabled, "==== matched routes ====");
    for (const [i, { handler, method, path }] of c.req.matchedRoutes.entries()) {
      const name = handler.name || (handler.length < 2 ? "[handler]" : "[middleware]");
      logIfDebug(isDebugEnabled, method, " ", path, " ".repeat(Math.max(10 - path.length, 0)), name, i === c.req.routeIndex ? "<- respond from here" : "");
    }
    logIfDebug(isDebugEnabled, "==== end of matched routes ====");
  });
  if (otelEndpoint) {
    logIfDebug(isDebugEnabled, "OpenTelemetry Endpoint Present. Creating internal traces API router.");
    app.route("/api/traces", createTracesApiRoute(fetchFn, otelEndpoint, otelToken));
  } else {
    logIfDebug(isDebugEnabled, "OpenTelemetry Endpoint *NOT* Present. Internal traces API router disabled.");
    app.use("/api/traces/*", async (c) => {
      return c.json({ error: "OpenTelemetry endpoint is not set" }, 401);
    });
  }
  app.use(async (c, next2) => {
    c.set("userApp", options.userApp);
    c.set("userEnv", options.userEnv);
    c.set("userExecutionCtx", options.userExecutionCtx);
    await next2();
  });
  if (apiKey) {
    logIfDebug(isDebugEnabled, "Fiberplane API Key Present. Creating internal API router.");
    app.route("/w", createRunnerRoute(apiKey, fiberplaneServicesUrl));
    app.route("/api", createApiRoutes(fetchFn, apiKey, fiberplaneServicesUrl));
  } else {
    logIfDebug(isDebugEnabled, "Fiberplane API Key *NOT* Present. Internal API router disabled.");
    app.use("/api/*", async (c) => {
      return c.json({ error: "Fiberplane API key is not set" }, 402);
    });
    app.use("/w/*", async (c) => {
      return c.json({ error: "Fiberplane API key is not set" }, 402);
    });
  }
  const embeddedPlayground = createPlayground(sanitizedOptions);
  app.route("/", embeddedPlayground);
  return app;
}

// node_modules/@fiberplane/hono/dist/middleware.js
var ASSETS_VERSION = "0.5.2";
var CDN_URL = `https://cdn.jsdelivr.net/npm/@fiberplane/hono@${ASSETS_VERSION}/dist/playground/`;
var createFiberplane = (options) => async (c, next2) => {
  const debug = options.debug ?? false;
  const userApp = options.app;
  const userEnv = c.env;
  const userExecutionCtx = getExecutionCtxSafely(c);
  logIfDebug(debug, "debug logs are enabled");
  const apiKey = options.apiKey ?? getApiKey(c, debug);
  const { mountedPath, internalPath } = getPaths(c);
  const fiberplaneServicesUrl = options.fiberplaneServicesUrl ?? getFiberplaneServicesUrl(c);
  const otelEndpoint = getOtelEndpoint(c);
  const otelToken = getOtelToken(c);
  logIfDebug(debug, "mountedPath:", mountedPath);
  logIfDebug(debug, "internalPath:", internalPath);
  logIfDebug(debug, "fiberplaneServicesUrl:", fiberplaneServicesUrl);
  logIfDebug(debug, "otelEndpoint:", otelEndpoint);
  if (otelEndpoint && !otelToken) {
    logIfDebug(debug, "otelToken is not set, tracing requests will not use bearer auth");
  }
  if (!userExecutionCtx) {
    logIfDebug(debug, "userExecutionCtx is null");
  }
  const router = createRouter({
    cdn: options.cdn ?? CDN_URL,
    mountedPath,
    otelEndpoint,
    otelToken,
    userApp,
    userEnv,
    userExecutionCtx,
    ...options,
    // Add the services url here because we already specified a fallback to the DEFAULT_PLAYGROUND_SERVICES_URL
    fiberplaneServicesUrl,
    // Add the api key with a fallback to the env var FIBERPLANE_API_KEY
    apiKey
  });
  const newUrl = new URL(c.req.url);
  newUrl.pathname = internalPath;
  const newRequest = new Request(newUrl, c.req.raw);
  logIfDebug(debug, "Making internal api request:", newRequest.method, newUrl.toString());
  const response = await router.fetch(newRequest);
  logIfDebug(debug, "Finished internal api request:", newRequest.method, newUrl.toString(), "- returned", response.status);
  if (response.status === 404 && response.headers.get("content-type") !== "application/json") {
    return next2();
  }
  return response;
};
function getPaths(c) {
  const mountedPath = c.req.routePath.replace("/*", "");
  const internalPath = c.req.path.replace(mountedPath, "");
  return {
    mountedPath,
    internalPath
  };
}
function getOtelEndpoint(c) {
  const otelEndpoint = getFromEnv(c?.env, [
    ENV_FIBERPLANE_OTEL_ENDPOINT,
    ENV_FPX_ENDPOINT
  ]);
  return otelEndpoint ?? void 0;
}
function getOtelToken(c) {
  const otelToken = getFromEnv(c?.env, [
    ENV_FIBERPLANE_OTEL_TOKEN,
    ENV_FPX_AUTH_TOKEN
  ]);
  return otelToken ?? void 0;
}
function getFiberplaneServicesUrl(c) {
  const fiberplaneServicesUrl = getFromEnv(c?.env, [
    ENV_FIBERPLANE_SERVICES_URL
  ]);
  return fiberplaneServicesUrl ?? DEFAULT_PLAYGROUND_SERVICES_URL;
}
function getApiKey(c, debug) {
  const FIBERPLANE_API_KEY = c?.env?.FIBERPLANE_API_KEY;
  if (debug) {
    if (FIBERPLANE_API_KEY) {
      logIfDebug(debug, "FIBERPLANE_API_KEY present in env");
    } else {
      logIfDebug(debug, "FIBERPLANE_API_KEY not present in env");
    }
  }
  return FIBERPLANE_API_KEY;
}
function getExecutionCtxSafely(c) {
  try {
    return c.executionCtx;
  } catch (_e) {
    return null;
  }
}

// node_modules/@fiberplane/hono/dist/index.js
var createMiddleware = createFiberplane;
export {
  FpService,
  createFiberplane,
  createMiddleware,
  createOpenAPISpec
};
//# sourceMappingURL=@fiberplane_hono.js.map
