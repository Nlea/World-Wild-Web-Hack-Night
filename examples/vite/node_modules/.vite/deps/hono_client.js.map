{
  "version": 3,
  "sources": ["../../hono/dist/utils/cookie.js", "../../hono/dist/client/utils.js", "../../hono/dist/client/client.js"],
  "sourcesContent": ["// src/utils/cookie.ts\nimport { decodeURIComponent_ } from \"./url.js\";\nvar algorithm = { name: \"HMAC\", hash: \"SHA-256\" };\nvar getCryptoKey = async (secret) => {\n  const secretBuf = typeof secret === \"string\" ? new TextEncoder().encode(secret) : secret;\n  return await crypto.subtle.importKey(\"raw\", secretBuf, algorithm, false, [\"sign\", \"verify\"]);\n};\nvar makeSignature = async (value, secret) => {\n  const key = await getCryptoKey(secret);\n  const signature = await crypto.subtle.sign(algorithm.name, key, new TextEncoder().encode(value));\n  return btoa(String.fromCharCode(...new Uint8Array(signature)));\n};\nvar verifySignature = async (base64Signature, value, secret) => {\n  try {\n    const signatureBinStr = atob(base64Signature);\n    const signature = new Uint8Array(signatureBinStr.length);\n    for (let i = 0, len = signatureBinStr.length; i < len; i++) {\n      signature[i] = signatureBinStr.charCodeAt(i);\n    }\n    return await crypto.subtle.verify(algorithm, secret, signature, new TextEncoder().encode(value));\n  } catch {\n    return false;\n  }\n};\nvar validCookieNameRegEx = /^[\\w!#$%&'*.^`|~+-]+$/;\nvar validCookieValueRegEx = /^[ !#-:<-[\\]-~]*$/;\nvar parse = (cookie, name) => {\n  if (name && cookie.indexOf(name) === -1) {\n    return {};\n  }\n  const pairs = cookie.trim().split(\";\");\n  const parsedCookie = {};\n  for (let pairStr of pairs) {\n    pairStr = pairStr.trim();\n    const valueStartPos = pairStr.indexOf(\"=\");\n    if (valueStartPos === -1) {\n      continue;\n    }\n    const cookieName = pairStr.substring(0, valueStartPos).trim();\n    if (name && name !== cookieName || !validCookieNameRegEx.test(cookieName)) {\n      continue;\n    }\n    let cookieValue = pairStr.substring(valueStartPos + 1).trim();\n    if (cookieValue.startsWith('\"') && cookieValue.endsWith('\"')) {\n      cookieValue = cookieValue.slice(1, -1);\n    }\n    if (validCookieValueRegEx.test(cookieValue)) {\n      parsedCookie[cookieName] = decodeURIComponent_(cookieValue);\n      if (name) {\n        break;\n      }\n    }\n  }\n  return parsedCookie;\n};\nvar parseSigned = async (cookie, secret, name) => {\n  const parsedCookie = {};\n  const secretKey = await getCryptoKey(secret);\n  for (const [key, value] of Object.entries(parse(cookie, name))) {\n    const signatureStartPos = value.lastIndexOf(\".\");\n    if (signatureStartPos < 1) {\n      continue;\n    }\n    const signedValue = value.substring(0, signatureStartPos);\n    const signature = value.substring(signatureStartPos + 1);\n    if (signature.length !== 44 || !signature.endsWith(\"=\")) {\n      continue;\n    }\n    const isVerified = await verifySignature(signature, signedValue, secretKey);\n    parsedCookie[key] = isVerified ? signedValue : false;\n  }\n  return parsedCookie;\n};\nvar _serialize = (name, value, opt = {}) => {\n  let cookie = `${name}=${value}`;\n  if (name.startsWith(\"__Secure-\") && !opt.secure) {\n    throw new Error(\"__Secure- Cookie must have Secure attributes\");\n  }\n  if (name.startsWith(\"__Host-\")) {\n    if (!opt.secure) {\n      throw new Error(\"__Host- Cookie must have Secure attributes\");\n    }\n    if (opt.path !== \"/\") {\n      throw new Error('__Host- Cookie must have Path attributes with \"/\"');\n    }\n    if (opt.domain) {\n      throw new Error(\"__Host- Cookie must not have Domain attributes\");\n    }\n  }\n  if (opt && typeof opt.maxAge === \"number\" && opt.maxAge >= 0) {\n    if (opt.maxAge > 3456e4) {\n      throw new Error(\n        \"Cookies Max-Age SHOULD NOT be greater than 400 days (34560000 seconds) in duration.\"\n      );\n    }\n    cookie += `; Max-Age=${opt.maxAge | 0}`;\n  }\n  if (opt.domain && opt.prefix !== \"host\") {\n    cookie += `; Domain=${opt.domain}`;\n  }\n  if (opt.path) {\n    cookie += `; Path=${opt.path}`;\n  }\n  if (opt.expires) {\n    if (opt.expires.getTime() - Date.now() > 3456e7) {\n      throw new Error(\n        \"Cookies Expires SHOULD NOT be greater than 400 days (34560000 seconds) in the future.\"\n      );\n    }\n    cookie += `; Expires=${opt.expires.toUTCString()}`;\n  }\n  if (opt.httpOnly) {\n    cookie += \"; HttpOnly\";\n  }\n  if (opt.secure) {\n    cookie += \"; Secure\";\n  }\n  if (opt.sameSite) {\n    cookie += `; SameSite=${opt.sameSite.charAt(0).toUpperCase() + opt.sameSite.slice(1)}`;\n  }\n  if (opt.priority) {\n    cookie += `; Priority=${opt.priority}`;\n  }\n  if (opt.partitioned) {\n    if (!opt.secure) {\n      throw new Error(\"Partitioned Cookie must have Secure attributes\");\n    }\n    cookie += \"; Partitioned\";\n  }\n  return cookie;\n};\nvar serialize = (name, value, opt) => {\n  value = encodeURIComponent(value);\n  return _serialize(name, value, opt);\n};\nvar serializeSigned = async (name, value, secret, opt = {}) => {\n  const signature = await makeSignature(value, secret);\n  value = `${value}.${signature}`;\n  value = encodeURIComponent(value);\n  return _serialize(name, value, opt);\n};\nexport {\n  parse,\n  parseSigned,\n  serialize,\n  serializeSigned\n};\n", "// src/client/utils.ts\nvar mergePath = (base, path) => {\n  base = base.replace(/\\/+$/, \"\");\n  base = base + \"/\";\n  path = path.replace(/^\\/+/, \"\");\n  return base + path;\n};\nvar replaceUrlParam = (urlString, params) => {\n  for (const [k, v] of Object.entries(params)) {\n    const reg = new RegExp(\"/:\" + k + \"(?:{[^/]+})?\\\\??\");\n    urlString = urlString.replace(reg, v ? `/${v}` : \"\");\n  }\n  return urlString;\n};\nvar buildSearchParams = (query) => {\n  const searchParams = new URLSearchParams();\n  for (const [k, v] of Object.entries(query)) {\n    if (v === void 0) {\n      continue;\n    }\n    if (Array.isArray(v)) {\n      for (const v2 of v) {\n        searchParams.append(k, v2);\n      }\n    } else {\n      searchParams.set(k, v);\n    }\n  }\n  return searchParams;\n};\nvar replaceUrlProtocol = (urlString, protocol) => {\n  switch (protocol) {\n    case \"ws\":\n      return urlString.replace(/^http/, \"ws\");\n    case \"http\":\n      return urlString.replace(/^ws/, \"http\");\n  }\n};\nvar removeIndexString = (urlSting) => {\n  if (/^https?:\\/\\/[^\\/]+?\\/index$/.test(urlSting)) {\n    return urlSting.replace(/\\/index$/, \"/\");\n  }\n  return urlSting.replace(/\\/index$/, \"\");\n};\nfunction isObject(item) {\n  return typeof item === \"object\" && item !== null && !Array.isArray(item);\n}\nfunction deepMerge(target, source) {\n  if (!isObject(target) && !isObject(source)) {\n    return source;\n  }\n  const merged = { ...target };\n  for (const key in source) {\n    const value = source[key];\n    if (isObject(merged[key]) && isObject(value)) {\n      merged[key] = deepMerge(merged[key], value);\n    } else {\n      merged[key] = value;\n    }\n  }\n  return merged;\n}\nexport {\n  buildSearchParams,\n  deepMerge,\n  mergePath,\n  removeIndexString,\n  replaceUrlParam,\n  replaceUrlProtocol\n};\n", "// src/client/client.ts\nimport { serialize } from \"../utils/cookie.js\";\nimport {\n  buildSearchParams,\n  deepMerge,\n  mergePath,\n  removeIndexString,\n  replaceUrlParam,\n  replaceUrlProtocol\n} from \"./utils.js\";\nvar createProxy = (callback, path) => {\n  const proxy = new Proxy(() => {\n  }, {\n    get(_obj, key) {\n      if (typeof key !== \"string\" || key === \"then\") {\n        return void 0;\n      }\n      return createProxy(callback, [...path, key]);\n    },\n    apply(_1, _2, args) {\n      return callback({\n        path,\n        args\n      });\n    }\n  });\n  return proxy;\n};\nvar ClientRequestImpl = class {\n  url;\n  method;\n  queryParams = void 0;\n  pathParams = {};\n  rBody;\n  cType = void 0;\n  constructor(url, method) {\n    this.url = url;\n    this.method = method;\n  }\n  fetch = async (args, opt) => {\n    if (args) {\n      if (args.query) {\n        this.queryParams = buildSearchParams(args.query);\n      }\n      if (args.form) {\n        const form = new FormData();\n        for (const [k, v] of Object.entries(args.form)) {\n          if (Array.isArray(v)) {\n            for (const v2 of v) {\n              form.append(k, v2);\n            }\n          } else {\n            form.append(k, v);\n          }\n        }\n        this.rBody = form;\n      }\n      if (args.json) {\n        this.rBody = JSON.stringify(args.json);\n        this.cType = \"application/json\";\n      }\n      if (args.param) {\n        this.pathParams = args.param;\n      }\n    }\n    let methodUpperCase = this.method.toUpperCase();\n    const headerValues = {\n      ...args?.header,\n      ...typeof opt?.headers === \"function\" ? await opt.headers() : opt?.headers\n    };\n    if (args?.cookie) {\n      const cookies = [];\n      for (const [key, value] of Object.entries(args.cookie)) {\n        cookies.push(serialize(key, value, { path: \"/\" }));\n      }\n      headerValues[\"Cookie\"] = cookies.join(\",\");\n    }\n    if (this.cType) {\n      headerValues[\"Content-Type\"] = this.cType;\n    }\n    const headers = new Headers(headerValues ?? void 0);\n    let url = this.url;\n    url = removeIndexString(url);\n    url = replaceUrlParam(url, this.pathParams);\n    if (this.queryParams) {\n      url = url + \"?\" + this.queryParams.toString();\n    }\n    methodUpperCase = this.method.toUpperCase();\n    const setBody = !(methodUpperCase === \"GET\" || methodUpperCase === \"HEAD\");\n    return (opt?.fetch || fetch)(url, {\n      body: setBody ? this.rBody : void 0,\n      method: methodUpperCase,\n      headers,\n      ...opt?.init\n    });\n  };\n};\nvar hc = (baseUrl, options) => createProxy(function proxyCallback(opts) {\n  const parts = [...opts.path];\n  if (parts.at(-1) === \"toString\") {\n    if (parts.at(-2) === \"name\") {\n      return parts.at(-3) || \"\";\n    }\n    return proxyCallback.toString();\n  }\n  if (parts.at(-1) === \"valueOf\") {\n    if (parts.at(-2) === \"name\") {\n      return parts.at(-3) || \"\";\n    }\n    return proxyCallback;\n  }\n  let method = \"\";\n  if (/^\\$/.test(parts.at(-1))) {\n    const last = parts.pop();\n    if (last) {\n      method = last.replace(/^\\$/, \"\");\n    }\n  }\n  const path = parts.join(\"/\");\n  const url = mergePath(baseUrl, path);\n  if (method === \"url\") {\n    let result = url;\n    if (opts.args[0]) {\n      if (opts.args[0].param) {\n        result = replaceUrlParam(url, opts.args[0].param);\n      }\n      if (opts.args[0].query) {\n        result = result + \"?\" + buildSearchParams(opts.args[0].query).toString();\n      }\n    }\n    return new URL(result);\n  }\n  if (method === \"ws\") {\n    const webSocketUrl = replaceUrlProtocol(\n      opts.args[0] && opts.args[0].param ? replaceUrlParam(url, opts.args[0].param) : url,\n      \"ws\"\n    );\n    const targetUrl = new URL(webSocketUrl);\n    const queryParams = opts.args[0]?.query;\n    if (queryParams) {\n      Object.entries(queryParams).forEach(([key, value]) => {\n        if (Array.isArray(value)) {\n          value.forEach((item) => targetUrl.searchParams.append(key, item));\n        } else {\n          targetUrl.searchParams.set(key, value);\n        }\n      });\n    }\n    const establishWebSocket = (...args) => {\n      if (options?.webSocket !== void 0 && typeof options.webSocket === \"function\") {\n        return options.webSocket(...args);\n      }\n      return new WebSocket(...args);\n    };\n    return establishWebSocket(targetUrl.toString());\n  }\n  const req = new ClientRequestImpl(url, method);\n  if (method) {\n    options ??= {};\n    const args = deepMerge(options, { ...opts.args[1] });\n    return req.fetch(opts.args[0], args);\n  }\n  return req;\n}, []);\nexport {\n  hc\n};\n"],
  "mappings": "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",
  "names": []
}
