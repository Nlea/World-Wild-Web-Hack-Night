// TODO: ideally we'd replace this with a zod validator but cheaper and simpler
// to use a basic json schema validator for now
import { sValidator } from "@hono/standard-validator";
import { Hono } from "hono";
import { HTTPException } from "hono/http-exception";
import { Draft2019 } from "json-schema-library";
import { z } from "zod";
import { InputSchema } from "../../schemas/workflows.js";
import { getContext } from "../../utils/index.js";
import { resolveOutputs, resolvePathAndMethod, resolveStepOutputs, resolveStepParams, } from "./resolvers.js";
import { getWorkflowById } from "./utils.js";
class WorkflowError extends HTTPException {
    details;
    cause;
    constructor(status, message, details, cause) {
        super(status, {
            message,
            cause,
        });
        this.details = details;
        this.cause = cause;
    }
    toResponse() {
        const { body, ...details } = this.details;
        return {
            type: "EXECUTION_ERROR",
            message: this.message,
            payload: details,
        };
    }
}
function serialize(content) {
    if (typeof content === "string") {
        return content;
    }
    if (content === undefined) {
        return undefined;
    }
    return JSON.stringify(content);
}
const BaseJsonErrorSchema = z.object({
    type: z.literal("error"),
    name: z.string(),
    message: z.string(),
});
const RequiredPropertyErrorDataSchema = z.object({
    key: z.string(),
    pointer: z.string(),
    schema: InputSchema,
    value: z.any(),
});
const TypeErrorDataSchema = z.object({
    value: z.any(),
    pointer: z.string(),
    expected: z.string(),
    received: z.string(),
    schema: InputSchema,
});
const RequiredPropertyErrorSchema = BaseJsonErrorSchema.extend({
    code: z.literal("required-property-error"),
    data: RequiredPropertyErrorDataSchema,
});
const TypeErrorSchema = BaseJsonErrorSchema.extend({
    code: z.literal("type-error"),
    data: TypeErrorDataSchema,
});
const SupportedValidationErrorSchema = z.discriminatedUnion("code", [
    RequiredPropertyErrorSchema,
    TypeErrorSchema,
]);
export default function createRunnerRoute(apiKey, fiberplaneServicesUrl) {
    const runner = new Hono().post("/:workflowId", sValidator("param", z.object({ workflowId: z.string() })), async (c) => {
        const { workflowId } = c.req.valid("param");
        const partitionKey = c.req.header("X-Fiberplane-Partition-Key");
        if (!partitionKey) {
            return c.json({ error: "Missing `X-Fiberplane-Partition-Key` header" }, 400);
        }
        const { data: workflow } = await getWorkflowById(workflowId, apiKey, fiberplaneServicesUrl, partitionKey);
        const inputs = workflow.inputs;
        if (inputs.type === "object" && inputs.properties) {
            inputs.properties = Object.fromEntries(Object.entries(inputs.properties).map(([key, value]) => {
                return [key, { ...value, id: key }];
            }));
        }
        const draft = new Draft2019(inputs);
        const body = await c.req.json();
        const errors = draft.validate(body);
        if (errors.length) {
            const details = errors
                .map((item) => {
                const parsedResult = SupportedValidationErrorSchema.safeParse(item);
                if (parsedResult.success) {
                    return parsedResult.data;
                }
                return null;
            })
                .filter((item) => item !== null)
                .map((item) => {
                if (item.code === "required-property-error") {
                    return {
                        key: item.data.key,
                        message: item.message,
                        code: item.code,
                    };
                }
                return {
                    code: item.code,
                    key: item.data.pointer,
                    message: item.message,
                };
            });
            const response = {
                type: "VALIDATION_ERROR",
                message: "validation failed",
                payload: details,
            };
            return c.json(response, 400);
        }
        const context = getContext();
        const userApp = context.get("userApp");
        if (!userApp) {
            return c.json({
                type: "CONFIGURATION_ERROR",
                message: "Missing `app` parameter for @fiberplane/hono middleware",
            }, 500);
        }
        try {
            const result = await executeWorkflow(workflow, body);
            return c.json(result);
        }
        catch (error) {
            if (error instanceof WorkflowError) {
                return c.json(error.toResponse(), error.status);
            }
            throw error;
        }
    });
    return runner;
}
async function executeWorkflow(workflow, inputs) {
    const workflowContext = {
        inputs,
        steps: {},
    };
    for (const step of workflow.steps) {
        try {
            const stepParameters = await resolveStepParams(step, workflowContext);
            const c = getContext();
            const baseUrl = new URL(c.req.url).origin;
            const request = createRequest(step, stepParameters, baseUrl);
            const response = await executeRequest(request);
            if (response.statusCode >= 400) {
                const request = createRequest(step, stepParameters, baseUrl);
                const errorDetails = {
                    stepId: step.stepId,
                    parameters: stepParameters.parameters,
                    request: {
                        url: request.url,
                        method: request.method,
                        headers: Object.fromEntries(request.headers.entries()),
                        body: stepParameters.body
                            ? serialize(stepParameters.body)
                            : undefined,
                    },
                    response: {
                        status: response.statusCode,
                        headers: response.headers,
                        body: serialize(response.body),
                    },
                };
                throw new WorkflowError(response.statusCode, "Workflow failed", errorDetails);
            }
            const outputs = resolveStepOutputs(step, response);
            workflowContext.steps[step.stepId] = {
                ...(outputs ? { outputs } : {}),
            };
        }
        catch (error) {
            if (error instanceof WorkflowError) {
                throw error;
            }
            throw new WorkflowError(500, "Unknown step execution error", {
                stepId: step.stepId,
            });
        }
    }
    return resolveOutputs(workflow, workflowContext);
}
async function executeRequest(request) {
    const c = getContext();
    const userApp = c.get("userApp");
    const userEnv = c.get("userEnv");
    const userExecutionCtx = c.get("userExecutionCtx");
    const response = await userApp.request(request, {}, userEnv, userExecutionCtx);
    const contentType = response.headers.get("content-type");
    const responseBody = contentType?.includes("application/json")
        ? await response.json()
        : (await response.text()) || null;
    return {
        statusCode: response.status,
        headers: Object.fromEntries(response.headers.entries()),
        body: responseBody,
    };
}
function createRequest(step, params, origin) {
    const baseUrl = new URL(origin);
    const headers = new Headers();
    const { method, path: uri } = resolvePathAndMethod(step);
    // Collect all parameters in a single pass
    const { pathname, searchParams } = step.parameters.reduce((acc, param) => {
        const value = String(params.parameters[param.name]);
        switch (param.in) {
            case "path":
                acc.pathname = acc.pathname.replace(`{${param.name}}`, value);
                break;
            case "query":
                acc.searchParams += `${acc.searchParams ? "&" : ""}${encodeURIComponent(param.name)}=${encodeURIComponent(value)}`;
                break;
            case "header":
                headers.append(param.name, value);
                break;
        }
        return acc;
    }, { pathname: uri, searchParams: "" });
    // Construct URL with all parameters
    const url = new URL(pathname + (searchParams ? `?${searchParams}` : ""), baseUrl);
    if (params.body) {
        headers.append("Content-Type", "application/json");
    }
    return new Request(url, {
        method: method.toUpperCase(),
        headers,
        body: params.body ? JSON.stringify(params.body) : undefined,
    });
}
